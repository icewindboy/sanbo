--------------------------------------------
-- Export file for user ENGNINE           --
-- Created by hukn on 2011/8/10, 11:21:43 --
--------------------------------------------

spool obj810.log

prompt
prompt Creating table BM
prompt =================
prompt
create table BM
(
  DEPTID       INTEGER not null,
  PARENTDEPTID INTEGER,
  DM           VARCHAR2(32) not null,
  MC           VARCHAR2(100) not null,
  QC           VARCHAR2(64),
  DEPT_ADDR    VARCHAR2(64),
  DEPT_PHONE   VARCHAR2(32),
  DEPT_FAX     VARCHAR2(32),
  HZR          VARCHAR2(32),
  FRDB         VARCHAR2(16),
  DEPT_EMAIL   VARCHAR2(32),
  ISMEMBER     INTEGER default 0,
  ISDELETE     INTEGER,
  ISWORK       INTEGER,
  HZRDH        VARCHAR2(32),
  FIRSTID      INTEGER default 0 not null,
  DEPT_BANK    VARCHAR2(64),
  DEPT_ACCOUNT VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table BM
  add constraint PK_BM primary key (DEPTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_CODE_IDX on BM (DM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_FIRSTID_IDX on BM (FIRSTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_ISDELETE_IDX on BM (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_ISMEMBER_IDX on BM (ISMEMBER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_PARENTID_IDX on BM (PARENTDEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_DMLB
prompt ======================
prompt
create table KC_DMLB
(
  WZLBID   INTEGER not null,
  PARENTID INTEGER not null,
  BM       VARCHAR2(32),
  MC       VARCHAR2(32),
  CS       INTEGER,
  ISDELETE INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_DMLB
  is '物资类别';
comment on column KC_DMLB.PARENTID
  is '父物资类别ID';
comment on column KC_DMLB.BM
  is '编码';
comment on column KC_DMLB.MC
  is '名称';
comment on column KC_DMLB.CS
  is '层数';
alter table KC_DMLB
  add constraint PK_KC_WZLB primary key (WZLBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_WZLB_BM_IDX on KC_DMLB (BM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_WZLB_ISDELETE_IDX on KC_DMLB (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_CK
prompt ====================
prompt
create table KC_CK
(
  STOREID INTEGER not null,
  CKMC    VARCHAR2(32),
  CKQC    VARCHAR2(64),
  CKDZ    VARCHAR2(64),
  CKDH    VARCHAR2(32),
  CKCZ    VARCHAR2(32),
  FGSID   INTEGER,
  BZ      VARCHAR2(64),
  HZR     VARCHAR2(32),
  CKBM    VARCHAR2(32),
  DEPTID  INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_CK
  add constraint PK_KC_CK primary key (STOREID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_CK
  add constraint FK_KC_CK_CK_BM_BM foreign key (DEPTID)
  references BM (DEPTID);
create index CK_BM_FK on KC_CK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CK_FGSID_IDX on KC_CK (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_CHLB
prompt ======================
prompt
create table KC_CHLB
(
  CHLBID INTEGER not null,
  CHMC   VARCHAR2(32),
  PXH    INTEGER,
  DYGS   INTEGER default 1,
  CKDGS  INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_CHLB
  add constraint PK_KC_CHLB primary key (CHLBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_DM
prompt ====================
prompt
create table KC_DM
(
  CPID        INTEGER not null,
  WZLBID      INTEGER not null,
  CPBM        VARCHAR2(32) not null,
  ZJM         VARCHAR2(32),
  PM          VARCHAR2(32),
  GG          VARCHAR2(32),
  TH          VARCHAR2(32),
  ABC         VARCHAR2(1),
  JLDW        VARCHAR2(10),
  HSDW        VARCHAR2(10),
  HSBL        VARCHAR2(128),
  JHDJ        NUMBER(20,9),
  CHXZ        INTEGER,
  TQQ         INTEGER,
  BZ          VARCHAR2(256),
  ISPROPS     INTEGER,
  ISSALE      INTEGER,
  JJFF        INTEGER not null,
  MAXSL       NUMBER(15,6),
  MINSL       NUMBER(15,6),
  ISDELETE    INTEGER,
  XGR         VARCHAR2(32),
  TXM         VARCHAR2(32),
  DEPTID      INTEGER,
  ZTQQ        INTEGER,
  CHLBID      INTEGER,
  STOREID     INTEGER,
  SCYDW       VARCHAR2(10),
  SCDWGS      VARCHAR2(128),
  ISBATCHNO   INTEGER default 0,
  PRODUCTPROP INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_DM.CPBM
  is '=产品树的编码规则';
comment on column KC_DM.ABC
  is '值:a,b,c';
comment on column KC_DM.CHXZ
  is '1=自制件,2=外购件,3=外协件,4=虚拟件';
comment on column KC_DM.ISPROPS
  is '是否有规格属性';
comment on column KC_DM.JJFF
  is '1=加权平均法,2=移动平均法,3=计划单价法';
alter table KC_DM
  add constraint PK_KC_DM primary key (CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_DM
  add constraint FK_KC_DM_CK_KC_DM_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
alter table KC_DM
  add constraint FK_KC_DM_KC_CHLB_D_KC_CHLB foreign key (CHLBID)
  references KC_CHLB (CHLBID);
alter table KC_DM
  add constraint FK_KC_DM_KC_WZLB_D_KC_WZLB foreign key (WZLBID)
  references KC_DMLB (WZLBID);
alter table KC_DM
  add constraint FK_KC_DM_SCCJ_BM foreign key (DEPTID)
  references BM (DEPTID);
create index CK_KC_DM_FK on KC_DM (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_CPDM_IDX on KC_DM (CPBM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_ISDELETE_IDX on KC_DM (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_TH_IDX on KC_DM (TH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_TXM_IDX on KC_DM (TXM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_ZJM_IDX on KC_DM (ZJM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_CHLB_FK on KC_DM (CHLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_WZLB_DM_FK on KC_DM (WZLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCCJ_FK on KC_DM (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_ASSIGN
prompt ========================
prompt
create table CB_ASSIGN
(
  CPID       INTEGER not null,
  TOT_ASSIGN NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_ASSIGN
  add constraint PK_CB_ASSIGN primary key (CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_ASSIGN
  add constraint FK_CB_ASSIG_PROD_ASSI_KC_DM foreign key (CPID)
  references KC_DM (CPID);

prompt
prompt Creating table CB_FEE_TYPE
prompt ==========================
prompt
create table CB_FEE_TYPE
(
  FEE_TYPE_ID   INTEGER not null,
  FEE_TYPE_CODE VARCHAR2(32),
  FEE_TYPE_NAME VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_FEE_TYPE
  add constraint PK_CB_FEE_TYPE primary key (FEE_TYPE_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_ASSIGN_DETAIL
prompt ===============================
prompt
create table CB_ASSIGN_DETAIL
(
  ASSIGN_DETAIL_ID INTEGER not null,
  FEE_TYPE_ID      INTEGER not null,
  CPID             INTEGER not null,
  ASSIGN_RATIO     NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_ASSIGN_DETAIL
  add constraint PK_CB_ASSIGN_DETAIL primary key (ASSIGN_DETAIL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_ASSIGN_DETAIL
  add constraint FK_CB_ASSIG_ASSGIN_DE_CB_ASSIG foreign key (CPID)
  references CB_ASSIGN (CPID);
alter table CB_ASSIGN_DETAIL
  add constraint FK_CB_ASSIG_TYPE_ASSG_CB_FEE_T foreign key (FEE_TYPE_ID)
  references CB_FEE_TYPE (FEE_TYPE_ID);
create index ASSGIN_DETAIL_FK on CB_ASSIGN_DETAIL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_ASSGIN_FK on CB_ASSIGN_DETAIL (FEE_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_FEE_NAME
prompt ==========================
prompt
create table CB_FEE_NAME
(
  FEE_NAME_ID   INTEGER not null,
  FEE_TYPE_ID   INTEGER not null,
  FEE_NAME_CODE VARCHAR2(32),
  FEE_NAME      VARCHAR2(64),
  FEE_KIND      INTEGER not null,
  DATA_FROM     INTEGER,
  GET_KIND      INTEGER not null,
  GET_PARAMS    VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CB_FEE_NAME.FEE_KIND
  is '1=直接费用,2=间接费用';
comment on column CB_FEE_NAME.DATA_FROM
  is '1=直接输入,2=单据提取';
comment on column CB_FEE_NAME.GET_KIND
  is '1=直接材料费,2=直接人工费,3=折旧费,4=待摊费用';
alter table CB_FEE_NAME
  add constraint PK_CB_FEE_NAME primary key (FEE_NAME_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_FEE_NAME
  add constraint FK_CB_FEE_N_FEE_TYPE_CB_FEE_T foreign key (FEE_TYPE_ID)
  references CB_FEE_TYPE (FEE_TYPE_ID);
create index FEE_TYPE_FK on CB_FEE_NAME (FEE_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_MAKING_ABOUT
prompt ==============================
prompt
create table CB_MAKING_ABOUT
(
  CPID      INTEGER not null,
  ABOUT_NUM NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_MAKING_ABOUT
  add constraint PK_CB_MAKING_ABOUT primary key (CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_MAKING_ABOUT
  add constraint FK_CB_MAKIN_PROD_ABOU_CB_ASSIG foreign key (CPID)
  references CB_ASSIGN (CPID);

prompt
prompt Creating table CB_OPTION
prompt ========================
prompt
create table CB_OPTION
(
  OPTION_CODE  VARCHAR2(32) not null,
  OPTION_VALUE INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CB_OPTION.OPTION_CODE
  is 'making_prod:在制品成本分配率';
comment on column CB_OPTION.OPTION_VALUE
  is '1.不计算在产品成本,2.按产品约当产量,3.按定额约当产量';
alter table CB_OPTION
  add constraint PK_CB_OPTION primary key (OPTION_CODE)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_OVERHEAD
prompt ==========================
prompt
create table CB_OVERHEAD
(
  OVERHEAD_ID INTEGER not null,
  YEAR_NUM    INTEGER,
  MONTH_NUM   INTEGER,
  STATE       INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CB_OVERHEAD.STATE
  is '0=初始化,8=表示结帐';
alter table CB_OVERHEAD
  add constraint PK_CB_OVERHEAD primary key (OVERHEAD_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_OVERHEAD_DETAIL
prompt =================================
prompt
create table CB_OVERHEAD_DETAIL
(
  OVERHEAD_D_ID INTEGER not null,
  DEPTID        INTEGER not null,
  OVERHEAD_ID   INTEGER not null,
  FEE_TYPE_ID   INTEGER not null,
  FEE_NAME_ID   INTEGER,
  FEE_DATE      DATE,
  FEE           NUMBER(20,9),
  MEMO          VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_OVERHEAD_DETAIL
  add constraint PK_CB_OVERHEAD_DETAIL primary key (OVERHEAD_D_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_OVERHEAD_DETAIL
  add constraint FK_CB_OVERH_DEPT_OVER_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CB_OVERHEAD_DETAIL
  add constraint FK_CB_OVERH_NAME_OVER_CB_FEE_N foreign key (FEE_NAME_ID)
  references CB_FEE_NAME (FEE_NAME_ID);
alter table CB_OVERHEAD_DETAIL
  add constraint FK_CB_OVERH_OVERHEAD_CB_OVERH foreign key (OVERHEAD_ID)
  references CB_OVERHEAD (OVERHEAD_ID);
alter table CB_OVERHEAD_DETAIL
  add constraint FK_CB_OVERH_TYPE_OVER_CB_FEE_T foreign key (FEE_TYPE_ID)
  references CB_FEE_TYPE (FEE_TYPE_ID);
create index DEPT_OVERHEAD_FK on CB_OVERHEAD_DETAIL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NAME_OVERHEAD_FK on CB_OVERHEAD_DETAIL (FEE_NAME_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index OVERHEAD_FK on CB_OVERHEAD_DETAIL (OVERHEAD_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_OVERHEAD_FK on CB_OVERHEAD_DETAIL (FEE_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_PROD_COST
prompt ===========================
prompt
create table CB_PROD_COST
(
  PROD_COST_ID INTEGER not null,
  CPID         INTEGER not null,
  YEAR_NUM     INTEGER,
  MONTH_NUM    INTEGER,
  TOT_PER_COST NUMBER(20,9),
  TOT_COST     NUMBER(20,9),
  STATE        INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CB_PROD_COST.STATE
  is '0=初始化,8=表示结帐';
alter table CB_PROD_COST
  add constraint PK_CB_PROD_COST primary key (PROD_COST_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_PROD_COST
  add constraint FK_CB_PROD__PROD_COST_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index PROD_COST_FK on CB_PROD_COST (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CB_PROD_COST_D
prompt =============================
prompt
create table CB_PROD_COST_D
(
  PROD_COST_D_ID INTEGER not null,
  PROD_COST_ID   INTEGER not null,
  FEE_TYPE_ID    INTEGER not null,
  PER_COST       NUMBER(20,9),
  COST           NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_PROD_COST_D
  add constraint PK_CB_PROD_COST_D primary key (PROD_COST_D_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CB_PROD_COST_D
  add constraint FK_CB_PROD__COST_DETA_CB_PROD_ foreign key (PROD_COST_ID)
  references CB_PROD_COST (PROD_COST_ID);
alter table CB_PROD_COST_D
  add constraint FK_CB_PROD__TYPE_COST_CB_FEE_T foreign key (FEE_TYPE_ID)
  references CB_FEE_TYPE (FEE_TYPE_ID);
create index COST_DETAIL_FK on CB_PROD_COST_D (PROD_COST_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_COST_FK on CB_PROD_COST_D (FEE_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table EMP
prompt ==================
prompt
create table EMP
(
  PERSONID    INTEGER not null,
  DEPTID      INTEGER not null,
  BM          VARCHAR2(16),
  XM          VARCHAR2(32),
  USERNAME    VARCHAR2(16),
  USERPASS    VARCHAR2(32),
  LASTLOGIN   DATE,
  LB          VARCHAR2(32),
  SEX         INTEGER,
  DATE_BORN   DATE,
  ZW          VARCHAR2(32),
  STUDY       VARCHAR2(32),
  ADDR        VARCHAR2(64),
  PHONE       VARCHAR2(32),
  EMAIL       VARCHAR2(32),
  DATE_IN     DATE,
  SFZHM       VARCHAR2(32),
  BZ          VARCHAR2(64),
  JG          VARCHAR2(32),
  MZ          VARCHAR2(32),
  ZC          VARCHAR2(32),
  ZZMM        VARCHAR2(32),
  ISUSE       INTEGER not null,
  ISDELETE    INTEGER not null,
  MOBILE      VARCHAR2(64),
  ISSHOW      INTEGER,
  ISDEFORMITY INTEGER default 0,
  GH          VARCHAR2(32),
  LOAN        VARCHAR2(32),
  MONTHWAGE   VARCHAR2(32),
  FAITH       VARCHAR2(32),
  LIVING      VARCHAR2(32),
  INTRODUCE   VARCHAR2(32),
  FILEFORMAT  VARCHAR2(32),
  PHOTO       LONG RAW
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column EMP.ISDELETE
  is '0=存在,1=删除,2=离职';
alter table EMP
  add constraint PK_EMP primary key (PERSONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table EMP
  add constraint EMP_DEPTID_FK foreign key (DEPTID)
  references BM (DEPTID);
create index DM_EMP_FK on EMP (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CODE_IDX on EMP (BM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_ISDEL_IDX on EMP (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_ISUSE_IDX on EMP (ISUSE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_USERNAME_IDX on EMP (USERNAME)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_USERPASS_IDX on EMP (USERPASS)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table COUNTRY
prompt ======================
prompt
create table COUNTRY
(
  CDM         VARCHAR2(6) not null,
  COUNTRYCODE VARCHAR2(16),
  MC          VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table COUNTRY
  add constraint PK_COUNTRY primary key (CDM)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DWDQ
prompt ===================
prompt
create table DWDQ
(
  DQH      VARCHAR2(6) not null,
  AREACODE VARCHAR2(16),
  DQMC     VARCHAR2(32),
  SFWS     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table DWDQ
  add constraint PK_DWDQ primary key (DQH)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DWTX
prompt ===================
prompt
create table DWTX
(
  DWTXID   INTEGER not null,
  PERSONID INTEGER,
  CDM      VARCHAR2(6),
  DQH      VARCHAR2(6),
  DEPTID   INTEGER,
  DWDM     VARCHAR2(10),
  ZJM      VARCHAR2(16),
  DWMC     VARCHAR2(64),
  ADDR     VARCHAR2(64),
  ZP       VARCHAR2(10),
  TEL      VARCHAR2(64),
  HTTP     VARCHAR2(64),
  EMAIL    VARCHAR2(32),
  FRDB     VARCHAR2(32),
  KHH      VARCHAR2(64),
  ZH       VARCHAR2(64),
  NSRDJH   VARCHAR2(32),
  CZ       VARCHAR2(32),
  LXR      VARCHAR2(32),
  SYZ      VARCHAR2(32),
  GXSD     INTEGER,
  ZXDJ     INTEGER,
  HY       VARCHAR2(32),
  FGSID    INTEGER,
  ISDELETE INTEGER,
  BZ       VARCHAR2(256),
  YFKJE    NUMBER(20,9),
  YSKJE    NUMBER(20,9),
  YFDJ     NUMBER(20,9),
  GLS      NUMBER(16,6),
  TYPES    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column DWTX.GXSD
  is '1=未知型,2=接触型,3=成交型,4=重要型';
comment on column DWTX.ZXDJ
  is '表示相应的星级';
comment on column DWTX.TYPES
  is '123456';
alter table DWTX
  add constraint PK_DWTX primary key (DWTXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table DWTX
  add constraint FK_DWTX_AREA_DW_DWDQ foreign key (DQH)
  references DWDQ (DQH);
alter table DWTX
  add constraint FK_DWTX_BM_DWTX_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table DWTX
  add constraint FK_DWTX_COUNTRY_D_COUNTRY foreign key (CDM)
  references COUNTRY (CDM);
alter table DWTX
  add constraint FK_DWTX_EMP_DWTX_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index AREA_DW_FK on DWTX (DQH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_DWTX_FK on DWTX (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index COUNTRY_DW_FK on DWTX (CDM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWDM_DELETE_IDX on DWTX (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_DWDM_IDX on DWTX (DWDM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_DWMC_IDX on DWTX (DWMC)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_FGSID_IDX on DWTX (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_ZJM_IDX on DWTX (ZJM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_DWTX_FK on DWTX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_DMSX
prompt ======================
prompt
create table KC_DMSX
(
  DMSXID   INTEGER not null,
  CPID     INTEGER,
  SXZ      VARCHAR2(512),
  ISDELETE INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_DMSX
  is '物资规格属性';
comment on column KC_DMSX.SXZ
  is '属性值';
alter table KC_DMSX
  add constraint PK_KC_DMSX primary key (DMSXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDMSX_ISDELETE_IDX on KC_DMSX (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SXZ_IDX on KC_DMSX (SXZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SX_FK on KC_DMSX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table WB
prompt =================
prompt
create table WB
(
  WBID INTEGER not null,
  DM   VARCHAR2(10),
  MC   VARCHAR2(32),
  HL   NUMBER(10,6),
  FF   INTEGER,
  GD   INTEGER,
  FH   VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column WB.FF
  is '1直接汇率（本未币/外币）
2间接汇率（外币/本未币）
';
alter table WB
  add constraint PK_WB primary key (WBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_BJ
prompt ====================
prompt
create table CG_BJ
(
  CGBJID INTEGER not null,
  CPID   INTEGER,
  DWTXID INTEGER,
  BJ     NUMBER(20,9),
  YHTJ   VARCHAR2(64),
  KSRQ   DATE,
  JSRQ   DATE,
  GYSLH  VARCHAR2(32),
  BZ     VARCHAR2(64),
  CZRQ   DATE,
  CZYID  INTEGER,
  FGSID  INTEGER,
  CZY    VARCHAR2(16),
  SFHSSL INTEGER,
  DMSXID INTEGER,
  HL     NUMBER(20,9),
  WBBJ   NUMBER(20,9),
  WBID   INTEGER,
  SFLSBJ INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CG_BJ
  is '采购报价';
alter table CG_BJ
  add constraint PK_CG_BJ primary key (CGBJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_BJ
  add constraint FK_CG_BJ_DMSX_CGBJ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CG_BJ
  add constraint FK_CG_BJ_DWTX_CGBJ_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CG_BJ
  add constraint FK_CG_BJ_WB_CGBJ_WB foreign key (WBID)
  references WB (WBID);
create index CGBJ_WZDM_FK on CG_BJ (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_BJ_CZYID_IDX on CG_BJ (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_BJ_SFLSBJ_IDX on CG_BJ (SFLSBJ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CGBJ_FK on CG_BJ (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_CGBJ_FK on CG_BJ (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGBJ_FK on CG_BJ (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_ORDERTYPE
prompt ===========================
prompt
create table JC_ORDERTYPE
(
  ORDERTYPEID   INTEGER not null,
  ORDERTYPECODE VARCHAR2(32),
  ORDERTYPE     VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_ORDERTYPE
  add constraint PK_JC_ORDERTYPE primary key (ORDERTYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_HT
prompt ====================
prompt
create table CG_HT
(
  HTID        INTEGER not null,
  WBID        INTEGER,
  PERSONID    INTEGER,
  HTBH        VARCHAR2(32),
  KSRQ        DATE,
  JSRQ        DATE,
  QDDD        VARCHAR2(32),
  HL          NUMBER(20,9),
  ZSL         NUMBER(16,6),
  ZTMS        VARCHAR2(32),
  DEPTID      INTEGER,
  DWTXID      INTEGER,
  CZYID       INTEGER,
  FGSID       INTEGER,
  ISXN        INTEGER,
  HTRQ        DATE,
  ZT          INTEGER,
  CZRQ        DATE,
  CZY         VARCHAR2(16),
  ZJE         NUMBER(20,9),
  SPRID       INTEGER,
  KHLX        VARCHAR2(1),
  ISREFER     INTEGER default 0,
  DJH         VARCHAR2(32),
  ORDERTYPEID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CG_HT.DEPTID
  is '采购部门ID';
comment on column CG_HT.ISXN
  is '1=虚拟合同,0=正常合同';
comment on column CG_HT.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
alter table CG_HT
  add constraint PK_CG_HT primary key (HTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_HT
  add constraint FK_CG_HT_BM_CGHT_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CG_HT
  add constraint FK_CG_HT_CGHT_GFDW_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CG_HT
  add constraint FK_CG_HT_EMP_CGHT2_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CG_HT
  add constraint FK_CG_HT_TYPE_CGHT_JC_ORDER foreign key (ORDERTYPEID)
  references JC_ORDERTYPE (ORDERTYPEID);
alter table CG_HT
  add constraint FK_CG_HT_WB_CGHT_WB foreign key (WBID)
  references WB (WBID);
create index BM_CGHT_FK on CG_HT (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_BH_IDX on CG_HT (HTBH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_CZYID_IDX on CG_HT (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_FGSID_IDX on CG_HT (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_HTRQ_IDX on CG_HT (HTRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_ISREFER_IDX on CG_HT (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_ISXN_IDX on CG_HT (ISXN)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_KHLX_IDX on CG_HT (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGHT_ZT_IDX on CG_HT (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DW_CGHT_FK on CG_HT (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CGHT2_FK on CG_HT (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_CGHT_FK on CG_HT (ORDERTYPEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGHT_FK on CG_HT (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JSFS
prompt ===================
prompt
create table JSFS
(
  JSFSID INTEGER not null,
  DM     VARCHAR2(10),
  JSFS   VARCHAR2(32),
  KMDM   VARCHAR2(16)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JSFS
  add constraint PK_JSFS primary key (JSFSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_SENDMODE
prompt ==========================
prompt
create table JC_SENDMODE
(
  SENDMODEID   INTEGER not null,
  SENDMODECODE VARCHAR2(32),
  SENDMODE     VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_SENDMODE
  add constraint PK_JC_SENDMODE primary key (SENDMODEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_HT
prompt ====================
prompt
create table XS_HT
(
  HTID        INTEGER not null,
  DWTXID      INTEGER,
  PERSONID    INTEGER,
  HTBH        VARCHAR2(32),
  HTRQ        DATE,
  KSRQ        DATE,
  JSRQ        DATE,
  QDDD        VARCHAR2(32),
  QTXX        VARCHAR2(256),
  ZSL         NUMBER(16,6),
  ZJE         NUMBER(20,9),
  CZRQ        DATE,
  CZY         VARCHAR2(32),
  CZYID       INTEGER,
  FGSID       INTEGER,
  ISNET       INTEGER,
  ZT          INTEGER,
  ZTMS        VARCHAR2(32),
  SPRID       INTEGER,
  KHLX        VARCHAR2(1),
  HL          NUMBER(20,9),
  WBID        INTEGER,
  DEPTID      INTEGER,
  JSFSID      INTEGER,
  SENDMODEID  INTEGER,
  ORDERTYPEID INTEGER,
  ISREFER     INTEGER,
  YFDJ        NUMBER(20,9),
  ISPRODUCE   INTEGER default 1,
  KHHLTS      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_HT.PERSONID
  is '默认是需方所属业务员,需要权限才克更改';
comment on column XS_HT.CZRQ
  is '用于市场时表示报价日期';
comment on column XS_HT.ZT
  is '0.初始化,1.已开提单(已经审核),4.作废,9.出库';
alter table XS_HT
  add constraint PK_XS_HT primary key (HTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_HT
  add constraint FK_XS_HT_BM_XSHT_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table XS_HT
  add constraint FK_XS_HT_EMP_XSHT_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table XS_HT
  add constraint FK_XS_HT_JSFS_XSHT_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table XS_HT
  add constraint FK_XS_HT_SENDMODE__JC_SENDM foreign key (SENDMODEID)
  references JC_SENDMODE (SENDMODEID);
alter table XS_HT
  add constraint FK_XS_HT_WB_XSHT_WB foreign key (WBID)
  references WB (WBID);
alter table XS_HT
  add constraint FK_XS_HT_XSHT_DWTX_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table XS_HT
  add constraint FK_XS_HT_XS_ORDERT_JC_ORDER foreign key (ORDERTYPEID)
  references JC_ORDERTYPE (ORDERTYPEID);
create index BM_XSHT_FK on XS_HT (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_XSHT_FK on XS_HT (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_XSHT_FK on XS_HT (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SENDMODE_XSHT_FK on XS_HT (SENDMODEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_XSHT_FK on XS_HT (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_BH_IDX on XS_HT (HTBH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_CZYID_IDX on XS_HT (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_DWTX_FK on XS_HT (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_FGSID_IDX on XS_HT (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_HTRQ_IDX on XS_HT (HTRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_ISNET_IDX on XS_HT (ISNET)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_ISPRODUCE_IDX on XS_HT (ISPRODUCE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_ISREFER_IDX on XS_HT (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_KHLX_IDX on XS_HT (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_ZT_IDX on XS_HT (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_ORDERTYPE_FK on XS_HT (ORDERTYPEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GYLXLX
prompt ========================
prompt
create table SC_GYLXLX
(
  GYLXLXID INTEGER not null,
  GYLXLXBH VARCHAR2(16),
  GYLXLXMC VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GYLXLX
  is '工艺路线类型';
comment on column SC_GYLXLX.GYLXLXID
  is '工艺路线类型ID';
comment on column SC_GYLXLX.GYLXLXBH
  is '工艺路线类型编号';
comment on column SC_GYLXLX.GYLXLXMC
  is '工艺路线类型名称';
alter table SC_GYLXLX
  add constraint PK_SC_GYLXLX primary key (GYLXLXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GYLX
prompt ======================
prompt
create table SC_GYLX
(
  GYLXID   INTEGER not null,
  GYLXLXID INTEGER,
  CPID     INTEGER,
  SXSJ     DATE
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_GYLX.GYLXLXID
  is '工艺路线类型ID';
comment on column SC_GYLX.SXSJ
  is '生效时间';
alter table SC_GYLX
  add constraint PK_SC_GYLX primary key (GYLXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GYLX
  add constraint FK_SC_GYLX_GYLXLX_SC_GYLXL foreign key (GYLXLXID)
  references SC_GYLXLX (GYLXLXID);
create index GYLXLX_FK on SC_GYLX (GYLXLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_QYLX_FK on SC_GYLX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JH
prompt ====================
prompt
create table SC_JH
(
  SCJHID  INTEGER not null,
  DEPTID  INTEGER,
  JHH     VARCHAR2(32),
  JHRQ    DATE,
  JHSM    VARCHAR2(512),
  ZSL     NUMBER(16,6),
  ZT      INTEGER,
  ZTMS    VARCHAR2(32),
  ZDRQ    DATE,
  ZDRID   INTEGER,
  ZDR     VARCHAR2(32),
  FGSID   INTEGER,
  SPRID   INTEGER,
  FDL     NUMBER(16,6),
  YXWC    NUMBER(16,6),
  JHLX    INTEGER,
  ISREFER INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_JH.JHH
  is '计划号';
comment on column SC_JH.JHRQ
  is '计划日期';
comment on column SC_JH.JHSM
  is '计划说明';
comment on column SC_JH.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
alter table SC_JH
  add constraint PK_SC_JH primary key (SCJHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JH
  add constraint FK_SC_JH_BM_SCJH_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_SCJH_FK on SC_JH (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_FGSID_IDX on SC_JH (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_ISREFER_IDX on SC_JH (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_JHH_IDX on SC_JH (JHH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_JHRQ_IDX on SC_JH (JHRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_ZDRID_IDX on SC_JH (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_ZT_IDX on SC_JH (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_WLXQJH
prompt ========================
prompt
create table SC_WLXQJH
(
  WLXQJHID INTEGER not null,
  SCJHID   INTEGER,
  DEPTID   INTEGER,
  WLXQH    VARCHAR2(32),
  ZT       INTEGER,
  ZTMS     VARCHAR2(32),
  ZDRQ     DATE,
  ZDRID    INTEGER,
  ZDR      VARCHAR2(32),
  FGSID    INTEGER,
  RQ       DATE,
  SPRID    INTEGER,
  ZSL      NUMBER(16,6),
  ISREFER  INTEGER,
  JHLX     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_WLXQJH
  is '物料需求计划';
comment on column SC_WLXQJH.WLXQH
  is '物料需求号';
comment on column SC_WLXQJH.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
comment on column SC_WLXQJH.RQ
  is '日期';
alter table SC_WLXQJH
  add constraint PK_SC_WLXQJH primary key (WLXQJHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_WLXQJH
  add constraint FK_SC_WLXQJ_BM_WLXQJH_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_WLXQJH
  add constraint FK_SC_WLXQJ_JH_WLXQJH_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
create index BM_WLXQJH_FK on SC_WLXQJH (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JH_WLXQJH_FK on SC_WLXQJH (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_FGSID_IDX on SC_WLXQJH (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_ISREFER_IDX on SC_WLXQJH (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_JHLX_IDX on SC_WLXQJH (JHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_RQ_IDX on SC_WLXQJH (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_XQH_IDX on SC_WLXQJH (WLXQH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_ZDRID_IDX on SC_WLXQJH (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_ZT_IDX on SC_WLXQJH (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_WLXQJHMX
prompt ==========================
prompt
create table SC_WLXQJHMX
(
  WLXQJHMXID INTEGER not null,
  CPID       INTEGER,
  GYLXID     INTEGER,
  WLXQJHID   INTEGER,
  SCJHMXID   INTEGER,
  HTID       INTEGER,
  XQL        NUMBER(16,6),
  XGL        NUMBER(16,6),
  XQRQ       DATE,
  BZ         VARCHAR2(64),
  CHXZ       INTEGER,
  YPRWL      NUMBER(16,6),
  CC         INTEGER,
  YGL        NUMBER(16,6),
  DMSXID     INTEGER,
  JLXQL      NUMBER(16,6),
  YPRWCSL    NUMBER(16,6),
  ISCOPY     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_WLXQJHMX
  is '物料需求计划明细';
comment on column SC_WLXQJHMX.XQL
  is '需求量';
comment on column SC_WLXQJHMX.XGL
  is '需购量';
comment on column SC_WLXQJHMX.XQRQ
  is '需求日期';
comment on column SC_WLXQJHMX.BZ
  is '备注';
comment on column SC_WLXQJHMX.CHXZ
  is '1=自制件,2=外购件,3=外协件(从kc_dm的chxz导入)';
comment on column SC_WLXQJHMX.YPRWL
  is '任务单回填数据';
alter table SC_WLXQJHMX
  add constraint PK_SC_WLXQJHMX primary key (WLXQJHMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_WLXQJHMX
  add constraint FK_SC_WLXQJ_DMSX_WLXQ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_WLXQJHMX
  add constraint FK_SC_WLXQJ_GYLX_WLXQ_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_WLXQJHMX
  add constraint FK_SC_WLXQJ_HT_WLXQJH_XS_HT foreign key (HTID)
  references XS_HT (HTID);
alter table SC_WLXQJHMX
  add constraint FK_SC_WLXQJ_KCDM_WLXQ_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_WLXQJHMX
  add constraint FK_SC_WLXQJ_SC_WLXQJH_SC_WLXQJ foreign key (WLXQJHID)
  references SC_WLXQJH (WLXQJHID);
create index DMSX_WLXQJHMX_FK on SC_WLXQJHMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_WLXQJH_FK on SC_WLXQJHMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HT_WLXQJHMX_FK on SC_WLXQJHMX (HTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_WLXQJHMX_FK on SC_WLXQJHMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJHMX_WLXQJHMX_FK on SC_WLXQJHMX (SCJHMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_WLXQJH_MX_FK on SC_WLXQJHMX (WLXQJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_SQD
prompt =====================
prompt
create table CG_SQD
(
  CGSQDID INTEGER not null,
  DEPTID  INTEGER,
  SQBH    VARCHAR2(32),
  SQRQ    DATE,
  CGYY    VARCHAR2(64),
  CZRQ    DATE,
  ZSL     NUMBER(16,6),
  ZJE     NUMBER(20,9),
  CZYID   INTEGER,
  CZY     VARCHAR2(16),
  ZT      INTEGER,
  ZTMS    VARCHAR2(32),
  FGSID   INTEGER,
  SPRID   INTEGER,
  HL      NUMBER(20,9),
  WBID    INTEGER,
  ISREFER INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CG_SQD
  is '采购申请单';
comment on column CG_SQD.ZT
  is '0.初始化值 ,2.已入库,9.已完成';
alter table CG_SQD
  add constraint PK_CG_SQD primary key (CGSQDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_SQD
  add constraint FK_CG_SQD_BM_CGSQD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CG_SQD
  add constraint FK_CG_SQD_WB_CGSQD_WB foreign key (WBID)
  references WB (WBID);
create index BM_CGSQD_FK on CG_SQD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_SQD_CZYID_IDX on CG_SQD (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_SQD_ISREFER_IDX on CG_SQD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_SQD_SQBH_IDX on CG_SQD (SQBH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_SQD_SQRQ_IDX on CG_SQD (SQRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGSQD_FK on CG_SQD (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_SQDHW
prompt =======================
prompt
create table CG_SQDHW
(
  CGSQDHWID  INTEGER not null,
  DWTXID     INTEGER,
  CPID       INTEGER,
  CGSQDID    INTEGER,
  HSSL       NUMBER(16,6),
  SL         NUMBER(16,6),
  DJ         NUMBER(20,9),
  JE         NUMBER(20,9),
  XQRQ       DATE,
  BZ         VARCHAR2(64),
  WLXQJHMXID INTEGER,
  SKHTL      NUMBER(16,6),
  DMSXID     INTEGER,
  YBJE       NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CG_SQDHW
  is '采购申请单货物';
alter table CG_SQDHW
  add constraint PK_CG_SQDHW primary key (CGSQDHWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_SQDHW
  add constraint FK_CG_SQDHW_DMSX_CGSQ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CG_SQDHW
  add constraint FK_CG_SQDHW_DWTX_SQDH_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CG_SQDHW
  add constraint FK_CG_SQDHW_SQD_HW_CG_SQD foreign key (CGSQDID)
  references CG_SQD (CGSQDID);
alter table CG_SQDHW
  add constraint FK_CG_SQDHW_WLXQJHMX__SC_WLXQJ foreign key (WLXQJHMXID)
  references SC_WLXQJHMX (WLXQJHMXID);
create index DMSX_CGSQDHW_FK on CG_SQDHW (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_SQDHW_FK on CG_SQDHW (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SQD_HW_FK on CG_SQDHW (CGSQDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJHMX_CGSQDHW_FK on CG_SQDHW (WLXQJHMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_SQDHW_FK on CG_SQDHW (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_HTHW
prompt ======================
prompt
create table CG_HTHW
(
  HTHWID    INTEGER not null,
  HTID      INTEGER not null,
  CPID      INTEGER,
  CGSQDHWID INTEGER,
  GYSZYH    VARCHAR2(32),
  SL        NUMBER(16,6),
  DJ        NUMBER(20,9),
  JE        NUMBER(20,9),
  YBJE      NUMBER(20,9),
  JHRQ      DATE,
  BZ        VARCHAR2(64),
  BJ        INTEGER,
  SJRKL     NUMBER(16,6),
  SJJHL     NUMBER(16,6),
  DMSXID    INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CG_HTHW.BJ
  is '0＝未到货，1＝已到货，2＝执行完成';
alter table CG_HTHW
  add constraint PK_CG_HTHW primary key (HTHWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_HTHW
  add constraint FK_CG_HTHW_CGHT_HTHW_CG_HT foreign key (HTID)
  references CG_HT (HTID);
alter table CG_HTHW
  add constraint FK_CG_HTHW_CG_SQDHW__CG_SQDHW foreign key (CGSQDHWID)
  references CG_SQDHW (CGSQDHWID);
alter table CG_HTHW
  add constraint FK_CG_HTHW_DMSX_CGHT_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CG_HTHW
  add constraint FK_CG_HTHW_WZDM_HTHW_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index CGHT_HTHW_FK on CG_HTHW (HTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTHW_BJ_IDX on CG_HTHW (BJ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_SQDHW_HTHW_FK on CG_HTHW (CGSQDHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CGHTHW_FK on CG_HTHW (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_HTHW_FK on CG_HTHW (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_HTJHD
prompt =======================
prompt
create table CG_HTJHD
(
  JHDID      INTEGER not null,
  STOREID    INTEGER,
  DEPTID     INTEGER,
  DWTXID     INTEGER,
  PERSONID   INTEGER,
  DWT_DWTXID INTEGER,
  JHDBM      VARCHAR2(32),
  JHRQ       DATE,
  ZSL        NUMBER(16,6),
  ZJE        NUMBER(20,9),
  CZRQ       DATE,
  CZYID      INTEGER,
  CZY        VARCHAR2(16),
  FGSID      INTEGER,
  ZT         INTEGER,
  ZTMS       VARCHAR2(32),
  DJLX       INTEGER,
  SPRID      INTEGER,
  KHLX       VARCHAR2(1),
  JSFSID     INTEGER,
  ISREFER    INTEGER default 0,
  ISINIT     INTEGER default 0,
  HL         NUMBER(20,9),
  WBID       INTEGER,
  SHDZ       VARCHAR2(200)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CG_HTJHD.DWTXID
  is '供货单位ID';
comment on column CG_HTJHD.DWT_DWTXID
  is '承运单位ID';
comment on column CG_HTJHD.ZT
  is '0.初始化值,1.审核,2.已入库,9.已完成';
comment on column CG_HTJHD.DJLX
  is '1=进货,-1=退货';
alter table CG_HTJHD
  add constraint PK_CG_HTJHD primary key (JHDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_BM_HTJHD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_CK_JHD_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_CYDW_HTJH_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_EMP_HTJHD_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_GHDW_HTJH_DWTX foreign key (DWT_DWTXID)
  references DWTX (DWTXID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_JSFS_JHD_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table CG_HTJHD
  add constraint FK_CG_HTJHD_WB_CGJHD_WB foreign key (WBID)
  references WB (WBID);
create index BM_HTJHD_FK on CG_HTJHD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_CZYID_IDX on CG_HTJHD (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_FGSID_IDX on CG_HTJHD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_ISINIT_IDX on CG_HTJHD (ISINIT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_ISREFER_IDX on CG_HTJHD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_JHDBM_IDX on CG_HTJHD (JHDBM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_JHRQ_IDX on CG_HTJHD (JHRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_KHLX_IDX on CG_HTJHD (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_ZT_IDX on CG_HTJHD (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CK_JHD_FK on CG_HTJHD (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CYDW_HTJHD_FK on CG_HTJHD (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_HTJHD_FK on CG_HTJHD (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GHDW_HTJHD_FK on CG_HTJHD (DWT_DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_JHD_FK on CG_HTJHD (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGJHD_FK on CG_HTJHD (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_HTJHDHW
prompt =========================
prompt
create table CG_HTJHDHW
(
  JHDHWID       INTEGER not null,
  CPID          INTEGER,
  JHDID         INTEGER not null,
  HTHWID        INTEGER,
  GYSZYH        VARCHAR2(32),
  HSSL          NUMBER(16,6),
  SL            NUMBER(16,6),
  DJ            NUMBER(20,9),
  JE            NUMBER(20,9),
  BZ            VARCHAR2(64),
  SJRKL         NUMBER(16,6),
  SJRKHSL       NUMBER(16,6),
  SKPSL         NUMBER(16,6),
  SKPHSL        NUMBER(16,6),
  DMSXID        INTEGER,
  SFJE          NUMBER(20,9),
  JHRQ          DATE,
  YBJE          NUMBER(20,9),
  CHECK_RESULT  VARCHAR2(32),
  CHECK_NUMBER  NUMBER(16,6),
  CHECK_EXPLAIN VARCHAR2(200),
  CHECK_PERMIT  NUMBER(1)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CG_HTJHDHW.SJRKL
  is '由入库时回填数据';
alter table CG_HTJHDHW
  add constraint PK_CG_HTJHDHW primary key (JHDHWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_HTJHDHW
  add constraint FK_CG_HTJHD_DMSX_CGHT_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CG_HTJHDHW
  add constraint FK_CG_HTJHD_HTHW_HTJH_CG_HTHW foreign key (HTHWID)
  references CG_HTHW (HTHWID);
alter table CG_HTJHDHW
  add constraint FK_CG_HTJHD_WZDM_CGHT_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DMSX_CGHTJHDHW_FK on CG_HTJHDHW (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HTHW_HTJHDHW_FK on CG_HTJHDHW (HTHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HTJHD_HW_FK on CG_HTJHDHW (JHDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_CGHTHW_FK on CG_HTJHDHW (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CG_YFK
prompt =====================
prompt
create table CG_YFK
(
  DWTXID INTEGER not null,
  RQ     DATE,
  YFK    NUMBER(20,9),
  KHLX   VARCHAR2(1),
  FGSID  INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_YFK
  add constraint AK_CG_YFK_AK_CG_YFK unique (FGSID, KHLX, DWTXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CG_YFK
  add constraint FK_CG_YFK_DWTX_YFK_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index DWTX_YFK_FK on CG_YFK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_FPLB
prompt ======================
prompt
create table JC_FPLB
(
  FPLBID INTEGER not null,
  MC     VARCHAR2(32),
  SL     NUMBER(7,3),
  PXH    INTEGER,
  SYLX   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_FPLB
  add constraint PK_JC_FPLB primary key (FPLBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_CGFP
prompt ======================
prompt
create table CW_CGFP
(
  CGFPID   INTEGER not null,
  PERSONID INTEGER,
  DEPTID   INTEGER,
  DWTXID   INTEGER,
  FPHM     VARCHAR2(32),
  KPRQ     DATE,
  FPZL     INTEGER,
  DZ       VARCHAR2(64),
  SH       VARCHAR2(32),
  KHH      VARCHAR2(64),
  ZH       VARCHAR2(64),
  BZ       VARCHAR2(64),
  CZRQ     DATE,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  ZT       INTEGER,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  JSFSID   INTEGER,
  SPRID    INTEGER,
  SJHM     VARCHAR2(32),
  ISREFER  INTEGER default 0,
  ZSL      NUMBER(20,9),
  ZJE      NUMBER(20,9),
  FPLBID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_CGFP.FPZL
  is '1=增值税，2=企业普票';
comment on column CW_CGFP.ZT
  is '0=未审核,1=审核';
alter table CW_CGFP
  add constraint PK_CW_CGFP primary key (CGFPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGFP
  add constraint FK_CW_CGFP_BM_CGFP_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_CGFP
  add constraint FK_CW_CGFP_DWTX_CGFP_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_CGFP
  add constraint FK_CW_CGFP_EMP_CGFP_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_CGFP
  add constraint FK_CW_CGFP_FPLB_CGFP_JC_FPLB foreign key (FPLBID)
  references JC_FPLB (FPLBID);
alter table CW_CGFP
  add constraint FK_CW_CGFP_JSFS_CGFP_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
create index BM_CGFP_FK on CW_CGFP (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_CZYID_IDX on CW_CGFP (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_FGSID_IDX on CW_CGFP (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_FPZL_IDX on CW_CGFP (FPZL)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_ISREFER_IDX on CW_CGFP (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_KPRQ_IDX on CW_CGFP (KPRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CGFP_SJHM_IDX on CW_CGFP (SJHM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_CGFP_FK on CW_CGFP (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CGFP_FK on CW_CGFP (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index FPLB_CGFP_FK on CW_CGFP (FPLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_CGFP_FK on CW_CGFP (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_CGFPMX
prompt ========================
prompt
create table CW_CGFPMX
(
  CGFPMXID INTEGER not null,
  CGFPID   INTEGER,
  SL       NUMBER(15,6),
  HSDJ     NUMBER(20,9),
  WSDJ     NUMBER(20,9),
  JE       NUMBER(20,9),
  ZZSL     NUMBER(20,9),
  SE       NUMBER(20,9),
  JSHJ     NUMBER(20,9),
  CPID     INTEGER,
  JHDHWID  INTEGER,
  DMSXID   INTEGER,
  GSL      NUMBER(10,6),
  GS       NUMBER(20,9),
  HSSL     NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_CGFPMX.ZZSL
  is '税率';
comment on column CW_CGFPMX.SE
  is '税额';
comment on column CW_CGFPMX.JSHJ
  is '价税合计';
alter table CW_CGFPMX
  add constraint PK_CW_CGFPMX primary key (CGFPMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGFPMX
  add constraint FK_CW_CGFPM_CG_HTJHDH_CG_HTJHD foreign key (JHDHWID)
  references CG_HTJHDHW (JHDHWID);
alter table CW_CGFPMX
  add constraint FK_CW_CGFPM_DMSX_CGFP_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
create index CGFP_MX_FK on CW_CGFPMX (CGFPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CG_HTJHD_FPMX_FK on CW_CGFPMX (JHDHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CGFP_FK on CW_CGFPMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_CGFPMX_FK on CW_CGFPMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_CGJS
prompt ======================
prompt
create table CW_CGJS
(
  CGJSID   INTEGER not null,
  PERSONID INTEGER,
  JSFSID   INTEGER,
  DWTXID   INTEGER,
  DEPTID   INTEGER,
  DJXZ     INTEGER,
  DJH      VARCHAR2(32),
  RQ       DATE,
  JSDH     VARCHAR2(32),
  JE       NUMBER(20,9),
  ZH       VARCHAR2(32),
  YH       VARCHAR2(64),
  CZRQ     DATE,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  ZT       INTEGER,
  BZ       VARCHAR2(64),
  SPRID    INTEGER,
  KHLX     VARCHAR2(1),
  HXJE     NUMBER(20,9),
  WHXJE    NUMBER(20,9),
  ISREFER  INTEGER default 0,
  CJYF     NUMBER(20,9),
  ZFKJE    NUMBER(20,9),
  DFYH     VARCHAR2(64),
  DFZH     VARCHAR2(32),
  HL       NUMBER(20,9),
  YBJE     NUMBER(20,9),
  WBID     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_CGJS.DJXZ
  is '1=销售付款,-1=采购退款';
comment on column CW_CGJS.DJH
  is '单据号';
comment on column CW_CGJS.RQ
  is '日期';
comment on column CW_CGJS.JSDH
  is '结算单号';
comment on column CW_CGJS.JE
  is '金额';
comment on column CW_CGJS.ZH
  is '帐号';
comment on column CW_CGJS.YH
  is '银行';
comment on column CW_CGJS.ZT
  is '0=未审核,1=审核';
comment on column CW_CGJS.BZ
  is '备注';
alter table CW_CGJS
  add constraint PK_CW_CGJS primary key (CGJSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGJS
  add constraint FK_CW_CGJS_BM_CGJS_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_CGJS
  add constraint FK_CW_CGJS_DWTX_CGJS_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_CGJS
  add constraint FK_CW_CGJS_EMP_CGJS_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_CGJS
  add constraint FK_CW_CGJS_JSFS_CGJS_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table CW_CGJS
  add constraint FK_CW_CGJS_WB_CGJS_WB foreign key (WBID)
  references WB (WBID);
create index BM_CGJS_FK on CW_CGJS (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_CGJS_CZYID_IDX on CW_CGJS (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_CGJS_ISREFER_IDX on CW_CGJS (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_CGJS_KHLX_IDX on CW_CGJS (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_CGJS_RQ_IDX on CW_CGJS (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_CGJS_FK on CW_CGJS (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CGJS_FK on CW_CGJS (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_CGJS_FK on CW_CGJS (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGJS_FK on CW_CGJS (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_CGJSHX
prompt ========================
prompt
create table CW_CGJSHX
(
  CGJSHXID INTEGER not null,
  CPID     INTEGER,
  JHDHWID  INTEGER,
  CGJSID   INTEGER,
  JSJE     NUMBER(20,9),
  DMSXID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGJSHX
  add constraint PK_CW_CGJSHX primary key (CGJSHXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGJSHX
  add constraint FK_CW_CGJSH_CGJS_HX_CW_CGJS foreign key (CGJSID)
  references CW_CGJS (CGJSID);
alter table CW_CGJSHX
  add constraint FK_CW_CGJSH_DMSX_CGJS_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CW_CGJSHX
  add constraint FK_CW_CGJSH_JHDMX_CGJ_CG_HTJHD foreign key (JHDHWID)
  references CG_HTJHDHW (JHDHWID);
alter table CW_CGJSHX
  add constraint FK_CW_CGJSH_KCDM_CGJS_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index CGJS_HX_FK on CW_CGJSHX (CGJSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CGJS_FK on CW_CGJSHX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JHDMX_CGJSHX_FK on CW_CGJSHX (JHDHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_CGJS_FK on CW_CGJSHX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_CGYFK
prompt =======================
prompt
create table CW_CGYFK
(
  CGYFKID  INTEGER not null,
  WBID     INTEGER,
  DWTXID   INTEGER not null,
  DEPTID   INTEGER,
  JSFSID   INTEGER,
  PERSONID INTEGER,
  YFKBH    VARCHAR2(32),
  YFLX     INTEGER default 0,
  YFRQ     DATE,
  ISREFER  INTEGER,
  HL       NUMBER(20,9),
  JE       NUMBER(20,9),
  YBJE     NUMBER(20,9),
  ZH       VARCHAR2(32),
  YH       VARCHAR2(64),
  YFMS     VARCHAR2(512),
  ZT       INTEGER,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  CZRQ     DATE,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  SPRID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGYFK
  add constraint PK_CW_CGYFK primary key (CGYFKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_CGYFK
  add constraint FK_CW_CGYFK_BM_CGYFK_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_CGYFK
  add constraint FK_CW_CGYFK_DWTX_CGYF_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_CGYFK
  add constraint FK_CW_CGYFK_EMP_CGYFK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_CGYFK
  add constraint FK_CW_CGYFK_JSFS_CGYF_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table CW_CGYFK
  add constraint FK_CW_CGYFK_WB_CGYFK_WB foreign key (WBID)
  references WB (WBID);
create index BM_CGYFK_FK on CW_CGYFK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_CGYFK_FK on CW_CGYFK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CGYFK_FK on CW_CGYFK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_CGYFK_FK on CW_CGYFK (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WB_CGYFK_FK on CW_CGYFK (WBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_WJGJS
prompt =======================
prompt
create table CW_WJGJS
(
  WJGJSID  INTEGER not null,
  PERSONID INTEGER,
  DWTXID   INTEGER,
  JSFSID   INTEGER,
  DEPTID   INTEGER,
  DJH      VARCHAR2(32),
  RQ       DATE,
  JSDH     VARCHAR2(32),
  JE       NUMBER(20,9),
  CJYF     NUMBER(20,9),
  ZFKJE    NUMBER(20,9),
  HXJE     NUMBER(20,9),
  WHXJE    NUMBER(20,9),
  ZH       VARCHAR2(32),
  YH       VARCHAR2(64),
  KHLX     VARCHAR2(1),
  BZ       VARCHAR2(64),
  CZRQ     DATE,
  ISREFER  INTEGER,
  ZT       INTEGER,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  SPRID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_WJGJS
  add constraint PK_CW_WJGJS primary key (WJGJSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_WJGJS
  add constraint FK_CW_WJGJS_BM_WJGJS_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_WJGJS
  add constraint FK_CW_WJGJS_DWTX_WJGJ_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_WJGJS
  add constraint FK_CW_WJGJS_EMP_WJGJS_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_WJGJS
  add constraint FK_CW_WJGJS_JSFS_WJGJ_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
create index BM_WJGJS_FK on CW_WJGJS (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_WJGJS_FK on CW_WJGJS (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_WJGJS_FK on CW_WJGJS (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_WJGJS_FK on CW_WJGJS (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_RWD
prompt =====================
prompt
create table SC_RWD
(
  RWDID     INTEGER not null,
  DEPTID    INTEGER,
  RWDH      VARCHAR2(32),
  RQ        DATE,
  SM        VARCHAR2(512),
  ZT        INTEGER,
  ZTMS      VARCHAR2(32),
  ZDRQ      DATE,
  ZDRID     INTEGER,
  ZDR       VARCHAR2(32),
  FGSID     INTEGER,
  SPRID     INTEGER,
  BM_DEPTID INTEGER,
  ZSL       NUMBER(16,6),
  SCJHID    INTEGER,
  WLXQJHID  INTEGER,
  ISREFER   INTEGER,
  RWLX      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_RWD
  is '生产任务单';
comment on column SC_RWD.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
alter table SC_RWD
  add constraint PK_SC_RWD primary key (RWDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RWD
  add constraint FK_SC_RWD_BM_RWD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_RWD
  add constraint FK_SC_RWD_DEPT_RWD_BM foreign key (BM_DEPTID)
  references BM (DEPTID);
alter table SC_RWD
  add constraint FK_SC_RWD_JH_RWD_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
alter table SC_RWD
  add constraint FK_SC_RWD_WLXQJH_RW_SC_WLXQJ foreign key (WLXQJHID)
  references SC_WLXQJH (WLXQJHID);
create index BM_RWD_FK on SC_RWD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DEPT_RWD_FK on SC_RWD (BM_DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JH_RWD_FK on SC_RWD (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_FGSID_IDX on SC_RWD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_ISREFER_IDX on SC_RWD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_RQ_IDX on SC_RWD (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_RWDH_IDX on SC_RWD (RWDH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_RWLX_IDX on SC_RWD (RWLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_ZDRID_IDX on SC_RWD (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCRWD_ZT_IDX on SC_RWD (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJH_RWD_FK on SC_RWD (WLXQJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JGD
prompt =====================
prompt
create table SC_JGD
(
  JGDID    INTEGER not null,
  DEPTID   INTEGER,
  JGDH     VARCHAR2(32),
  RQ       DATE,
  ZDRQ     DATE,
  ZDRID    INTEGER,
  ZDR      VARCHAR2(32),
  FGSID    INTEGER,
  ZT       INTEGER,
  ZSL      NUMBER(16,6),
  DESCRIBE VARCHAR2(512),
  RWDID    INTEGER,
  SCJHID   INTEGER,
  JGLX     INTEGER,
  SFWJG    INTEGER default 0,
  DWTXID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_JGD
  is '生产加工单';
alter table SC_JGD
  add constraint PK_SC_JGD primary key (JGDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGD
  add constraint FK_SC_JGD_BM_SCRWD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_JGD
  add constraint FK_SC_JGD_DWTX_JGD_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_JGD
  add constraint FK_SC_JGD_JH_JGD_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
alter table SC_JGD
  add constraint FK_SC_JGD_RWD_JGD_SC_RWD foreign key (RWDID)
  references SC_RWD (RWDID);
create index BM_SCRWD_FK on SC_JGD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_JGD_FK on SC_JGD (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JH_JGD_FK on SC_JGD (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RWD_JGD_FK on SC_JGD (RWDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_FGSID_IDX on SC_JGD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_JGDH_IDX on SC_JGD (JGDH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_JGLX_IDX on SC_JGD (JGLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_RQ_IDX on SC_JGD (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_SFWJG_IDX on SC_JGD (SFWJG)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_ZDRID_IDX on SC_JGD (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JGDMX
prompt =======================
prompt
create table SC_JGDMX
(
  JGDMXID INTEGER not null,
  JGDID   INTEGER,
  CPID    INTEGER,
  RWDMXID INTEGER,
  GYLXID  INTEGER,
  SL      NUMBER(16,6),
  CPL     NUMBER(9,6),
  ZT      INTEGER,
  YPGZL   NUMBER(16,6),
  DMSXID  INTEGER,
  JGYQ    VARCHAR2(128),
  SCSL    NUMBER(16,6),
  JGDJ    NUMBER(20,9),
  JGJE    NUMBER(20,9),
  YFJGJE  NUMBER(20,9),
  YRKSL   NUMBER(16,6),
  YRKSCSL NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_JGDMX
  is '生产加工单明细:生成领料单时需要将cpid转化为子件列表';
comment on column SC_JGDMX.SL
  is '数量';
comment on column SC_JGDMX.CPL
  is '出品率';
comment on column SC_JGDMX.ZT
  is '0=初始化,1=已领料,2=已入库';
alter table SC_JGDMX
  add constraint PK_SC_JGDMX primary key (JGDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGDMX
  add constraint FK_SC_JGDMX_DMSX_JGD_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_JGDMX
  add constraint FK_SC_JGDMX_GYLX_JGDM_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID)
  disable;
alter table SC_JGDMX
  add constraint FK_SC_JGDMX_KCDM_JGDM_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
alter table SC_JGDMX
  add constraint FK_SC_JGDMX_SCJGD_MX_SC_JGD foreign key (JGDID)
  references SC_JGD (JGDID);
create index DMSX_JGD_FK on SC_JGDMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_JGDMX_FK on SC_JGDMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_ZT_IDX on SC_JGDMX (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_JGDMX_FK on SC_JGDMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RWDMX_JGDMX_FK on SC_JGDMX (RWDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJGD_MX_FK on SC_JGDMX (JGDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_WJGJSHX
prompt =========================
prompt
create table CW_WJGJSHX
(
  WJGJSHXID INTEGER not null,
  WJGJSID   INTEGER,
  DMSXID    INTEGER,
  CPID      INTEGER not null,
  JGDMXID   INTEGER not null,
  JSJE      NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_WJGJSHX
  add constraint PK_CW_WJGJSHX primary key (WJGJSHXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_WJGJSHX
  add constraint FK_CW_WJGJS_CW_WJGJS__CW_WJGJS foreign key (WJGJSID)
  references CW_WJGJS (WJGJSID);
alter table CW_WJGJSHX
  add constraint FK_CW_WJGJS_DMSX_WJDJ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CW_WJGJSHX
  add constraint FK_CW_WJGJS_JGDMX_WJD_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
alter table CW_WJGJSHX
  add constraint FK_CW_WJGJS_KCDM_WJDJ_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index CW_WJGJS_HX_FK on CW_WJGJSHX (WJGJSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_WJDJSHX_FK on CW_WJGJSHX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_WJDJSHX_FK on CW_WJGJSHX (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_WJDJSHX_FK on CW_WJGJSHX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_XJSZ
prompt ======================
prompt
create table CW_XJSZ
(
  XJSZID   INTEGER not null,
  DEPTID   INTEGER,
  JSFSID   INTEGER,
  PERSONID INTEGER,
  RQ       DATE,
  HM       VARCHAR2(32),
  ZY       VARCHAR2(64),
  SR       NUMBER(14,6),
  ZC       NUMBER(14,6),
  FX       INTEGER,
  ISINIT   INTEGER,
  SHBJ     INTEGER,
  SHR      VARCHAR2(32),
  ZDR      VARCHAR2(32),
  FGSID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_XJSZ.ZY
  is '初始化：初始余额';
comment on column CW_XJSZ.FX
  is '1=收入,2=支出';
comment on column CW_XJSZ.SHBJ
  is '0=未审核,1=审核';
alter table CW_XJSZ
  add constraint PK_CW_XJSZ primary key (XJSZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_XJSZ
  add constraint FK_CW_XJSZ_BM_XJSZ_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_XJSZ
  add constraint FK_CW_XJSZ_EMP_XJSZ_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_XJSZ
  add constraint FK_CW_XJSZ_JSFS_XJSZ_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
create index BM_XJSZ_FK on CW_XJSZ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_XJSZ_FK on CW_XJSZ (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_XJSZ_FK on CW_XJSZ (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XJSZ_FGSID_IDX on CW_XJSZ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XJSZ_FX_IDX on CW_XJSZ (FX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XJSZ_INIT_IDX on CW_XJSZ (ISINIT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_XSFP
prompt ======================
prompt
create table CW_XSFP
(
  XSFPID   INTEGER not null,
  DWTXID   INTEGER,
  JSFSID   INTEGER,
  DEPTID   INTEGER,
  PERSONID INTEGER,
  FPHM     VARCHAR2(32),
  KPRQ     DATE,
  FPZL     INTEGER,
  DZ       VARCHAR2(64),
  SH       VARCHAR2(32),
  KHH      VARCHAR2(64),
  ZH       VARCHAR2(64),
  BZ       VARCHAR2(64),
  CZRQ     DATE,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  ZT       INTEGER,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  HKRQ     DATE,
  SPRID    INTEGER,
  SJHM     VARCHAR2(32),
  ISREFER  INTEGER default 0,
  FPLBID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CW_XSFP
  is '销售发票';
comment on column CW_XSFP.FPZL
  is '1=增值税，2=企业普票';
comment on column CW_XSFP.ZT
  is '0=未审核,1=审核';
alter table CW_XSFP
  add constraint PK_CW_XSFP primary key (XSFPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_XSFP
  add constraint FK_CW_XSFP_BM_XSFP_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_XSFP
  add constraint FK_CW_XSFP_DWTX_XSFP_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_XSFP
  add constraint FK_CW_XSFP_EMP_XSFP_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_XSFP
  add constraint FK_CW_XSFP_FPLB_XSFP_JC_FPLB foreign key (FPLBID)
  references JC_FPLB (FPLBID);
alter table CW_XSFP
  add constraint FK_CW_XSFP_JSFS_XSFP_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
create index BM_XSFP_FK on CW_XSFP (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_XSFP_FK on CW_XSFP (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_XSFP_FK on CW_XSFP (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index FPLB_XSFP_FK on CW_XSFP (FPLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_XSFP_FK on CW_XSFP (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_CZYID_IDX on CW_XSFP (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_FGSID_IDX on CW_XSFP (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_FPZL_IDX on CW_XSFP (FPZL)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_ISREFER_IDX on CW_XSFP (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_KPRQ_IDX on CW_XSFP (KPRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_SJHM_IDX on CW_XSFP (SJHM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_WZDJ
prompt ======================
prompt
create table XS_WZDJ
(
  WZDJID INTEGER not null,
  XSJZJ  NUMBER(20,9),
  XSTCL  NUMBER(10,6),
  HKTS   INTEGER,
  HKTCL  NUMBER(10,6),
  SHYID  INTEGER,
  FGSID  INTEGER not null,
  CPID   INTEGER not null,
  XSJ    NUMBER(20,9),
  XSDJ   NUMBER(20,9),
  CZYID  INTEGER,
  CZY    VARCHAR2(32),
  CZRQ   DATE,
  SHBJ   INTEGER,
  SHY    VARCHAR2(32),
  SHRQ   DATE,
  ISNET  INTEGER default 0,
  JJBL   NUMBER(9,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_WZDJ.CZRQ
  is '用于市场时表示报价日期';
alter table XS_WZDJ
  add constraint PK_XS_WZDJ primary key (WZDJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_WZDJ
  add constraint AK_XS_WZDJ unique (FGSID, CPID, ISNET)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDJ_CZYID_IDX on XS_WZDJ (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDJ_FGSID_IDX on XS_WZDJ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDJ_ISNET_IDX on XS_WZDJ (ISNET)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_DZSZ_FK on XS_WZDJ (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_HTHW
prompt ======================
prompt
create table XS_HTHW
(
  HTHWID     INTEGER not null,
  HTID       INTEGER,
  WZDJID     INTEGER,
  HSSL       NUMBER(16,6),
  SL         NUMBER(16,6),
  XSJ        NUMBER(20,9),
  XSJE       NUMBER(20,9),
  ZK         NUMBER(9,6),
  DJ         NUMBER(20,9),
  JJE        NUMBER(20,9),
  JHRQ       DATE,
  BZ         VARCHAR2(64),
  STSL       NUMBER(16,6),
  ZT         INTEGER,
  DMSXID     INTEGER,
  YJHSL      NUMBER(16,6),
  JZJ        NUMBER(20,9),
  CJTCL      NUMBER(20,9),
  JXTS       NUMBER(10,3),
  HLTS       NUMBER(10,3),
  HLTCL      NUMBER(20,9),
  SKDSL      NUMBER(16,6),
  STHSSL     NUMBER(16,6),
  SKDHSSL    NUMBER(16,6),
  WBJE       NUMBER(20,9),
  ISPRODUCE  INTEGER default 1,
  PACKAGE_ID INTEGER,
  FUNDITEMID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_HTHW.XSJE
  is '不用显示';
comment on column XS_HTHW.JHRQ
  is '数量>库存可供量？合同日期+货物提前期:当前日期';
alter table XS_HTHW
  add constraint PK_XS_HTHW primary key (HTHWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_HTHW
  add constraint FK_XS_HTHW_KCDMSX_XS_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
create index KCDMSX_XSHT_FK on XS_HTHW (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDJ_XSHT_FK on XS_HTHW (WZDJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_HTHW_FK on XS_HTHW (HTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_HTHW_ISPRODUCE_IDX on XS_HTHW (ISPRODUCE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_HTHW_ZT_IDX on XS_HTHW (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_TD
prompt ====================
prompt
create table XS_TD
(
  TDID       INTEGER not null,
  PERSONID   INTEGER,
  DEPTID     INTEGER,
  DWT_DWTXID INTEGER,
  HKRQ       DATE,
  ZSL        NUMBER(16,6),
  DDFY       NUMBER(20,9),
  YF         NUMBER(20,9),
  DJLX       INTEGER,
  ZTMS       VARCHAR2(32),
  DWTXID     INTEGER,
  CZYID      INTEGER,
  HKTS       INTEGER,
  JSFSID     INTEGER,
  TDBH       VARCHAR2(32),
  TDRQ       DATE,
  ZT         INTEGER,
  CZRQ       DATE,
  CZY        VARCHAR2(32),
  ZJE        NUMBER(20,9),
  STOREID    INTEGER,
  FGSID      INTEGER,
  SPRID      INTEGER,
  KHLX       VARCHAR2(1),
  SENDMODEID INTEGER,
  ISREFER    INTEGER,
  YYWYID     INTEGER,
  ISINIT     INTEGER default 0,
  YFDJ       NUMBER(20,9),
  DJH        VARCHAR2(32),
  DZ         VARCHAR2(64),
  LXR        VARCHAR2(32),
  DH         VARCHAR2(32),
  ISNET      INTEGER default 0 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table XS_TD
  is '销售提单';
comment on column XS_TD.DWT_DWTXID
  is '承运单位ID';
comment on column XS_TD.ZSL
  is '总数量';
comment on column XS_TD.DDFY
  is '代垫费用';
comment on column XS_TD.YF
  is '运费';
comment on column XS_TD.DJLX
  is '1=提货,-1=退货';
comment on column XS_TD.ZTMS
  is '状态描述';
comment on column XS_TD.DWTXID
  is '收货单位ID';
comment on column XS_TD.CZYID
  is '操作员ID';
comment on column XS_TD.HKTS
  is '回款天数';
comment on column XS_TD.ZT
  is '0.初始化,1.已开提单(已经审核),4.作废,9.出库';
comment on column XS_TD.CZRQ
  is '操作日期';
comment on column XS_TD.CZY
  is '操作员';
comment on column XS_TD.ZJE
  is '总金额';
alter table XS_TD
  add constraint PK_XS_TD primary key (TDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TD
  add constraint FK_XS_TD_BM_TD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table XS_TD
  add constraint FK_XS_TD_CYDW_XSTD_DWTX foreign key (DWT_DWTXID)
  references DWTX (DWTXID);
alter table XS_TD
  add constraint FK_XS_TD_EMP_TD_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table XS_TD
  add constraint FK_XS_TD_JSFS_XSTD_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table XS_TD
  add constraint FK_XS_TD_KC_XSTD_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
alter table XS_TD
  add constraint FK_XS_TD_SENDMODE__JC_SENDM foreign key (SENDMODEID)
  references JC_SENDMODE (SENDMODEID);
alter table XS_TD
  add constraint FK_XS_TD_SHDW_XSTD_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index BM_TD_FK on XS_TD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_TD_FK on XS_TD (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSDW_XSTD_FK on XS_TD (DWT_DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_XSTD_FK on XS_TD (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_XSTD_FK on XS_TD (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SENDMODE_XSTD_FK on XS_TD (SENDMODEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SHDW_XSTD_FK on XS_TD (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_BH_IDX on XS_TD (TDBH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_CZYID_IDX on XS_TD (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_FGDID_IDX on XS_TD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_ISREFER_IDX on XS_TD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_KHLX_IDX on XS_TD (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_TDRQ_IDX on XS_TD (TDRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TDHT_ZT_IDX on XS_TD (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TD_ISINIT_IDX on XS_TD (ISINIT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TD_YYWYID_IDX on XS_TD (YYWYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_TDHW
prompt ======================
prompt
create table XS_TDHW
(
  TDHWID INTEGER not null,
  TDID   INTEGER,
  CPID   INTEGER not null,
  HTHWID INTEGER,
  WZDJID INTEGER,
  HSSL   NUMBER(16,6),
  SL     NUMBER(16,6),
  XSJ    NUMBER(20,9),
  XSJE   NUMBER(20,9),
  ZK     NUMBER(9,6),
  JJE    NUMBER(20,9),
  BZ     VARCHAR2(64),
  STHSSL NUMBER(16,6),
  STSL   NUMBER(16,6),
  SSJE   NUMBER(20,9),
  DJ     NUMBER(20,9),
  SKPSL  NUMBER(16,6),
  DMSXID NUMBER(20,9),
  CKRQ   DATE,
  HLTCL  NUMBER(20,9),
  CJTCL  NUMBER(20,9),
  JZJ    NUMBER(20,9),
  JXTS   NUMBER(10,3),
  HLTS   NUMBER(10,3),
  SFTH   INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table XS_TDHW
  is '销售提单货物';
comment on column XS_TDHW.XSJE
  is '不用显示';
comment on column XS_TDHW.STHSSL
  is '出库后回填';
comment on column XS_TDHW.STSL
  is '出库后回填';
alter table XS_TDHW
  add constraint PK_XS_TDHW primary key (TDHWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TDHW
  add constraint FK_XS_TDHW_DJSZ_XSTD_XS_WZDJ foreign key (WZDJID)
  references XS_WZDJ (WZDJID);
alter table XS_TDHW
  add constraint FK_XS_TDHW_KCDMSX_XS_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table XS_TDHW
  add constraint FK_XS_TDHW_WZDM_XSTD_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table XS_TDHW
  add constraint FK_XS_TDHW_XSTDHW_XS_TD foreign key (TDID)
  references XS_TD (TDID);
alter table XS_TDHW
  add constraint FK_XS_TDHW_XS_HTHW_T_XS_HTHW foreign key (HTHWID)
  references XS_HTHW (HTHWID);
create index DJSZ_XSTDHW_FK on XS_TDHW (WZDJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDMSX_XSTD_FK on XS_TDHW (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_XSTDHW_FK on XS_TDHW (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSTDHW_FK on XS_TDHW (TDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_HTHW_TD_FK on XS_TDHW (HTHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_XSFPMX
prompt ========================
prompt
create table CW_XSFPMX
(
  XSFPMXID INTEGER not null,
  TDHWID   INTEGER,
  XSFPID   INTEGER,
  CPID     INTEGER,
  SL       NUMBER(14,4),
  HSDJ     NUMBER(20,9),
  WSDJ     NUMBER(20,9),
  JE       NUMBER(20,9),
  ZZSL     NUMBER(20,9),
  SE       NUMBER(20,9),
  JSHJ     NUMBER(20,9),
  DMSXID   NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CW_XSFPMX
  is '销售发票明细';
comment on column CW_XSFPMX.ZZSL
  is '税率';
comment on column CW_XSFPMX.SE
  is '税额';
comment on column CW_XSFPMX.JSHJ
  is '价税合计';
alter table CW_XSFPMX
  add constraint PK_CW_XSFPMX primary key (XSFPMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_XSFPMX
  add constraint FK_CW_XSFPM_DMSX_XSFP_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CW_XSFPMX
  add constraint FK_CW_XSFPM_XSFP_MX_CW_XSFP foreign key (XSFPID)
  references CW_XSFP (XSFPID);
alter table CW_XSFPMX
  add constraint FK_CW_XSFPM_XS_TDHW_X_XS_TDHW foreign key (TDHWID)
  references XS_TDHW (TDHWID);
create index DMSX_XSFP_FK on CW_XSFPMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_XSFPMX_FK on CW_XSFPMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSFP_MX_FK on CW_XSFPMX (XSFPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_TDHW_XSFPMX_FK on CW_XSFPMX (TDHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_XSJS
prompt ======================
prompt
create table CW_XSJS
(
  XSJSID   INTEGER not null,
  DEPTID   INTEGER,
  JSFSID   INTEGER,
  PERSONID INTEGER,
  DWTXID   INTEGER,
  DJXZ     INTEGER,
  DJH      VARCHAR2(32),
  RQ       DATE,
  JSDH     VARCHAR2(32),
  JE       NUMBER(20,9),
  ZH       VARCHAR2(32),
  YH       VARCHAR2(64),
  CZRQ     DATE,
  ZTMS     VARCHAR2(32),
  FGSID    INTEGER,
  CZYID    INTEGER,
  CZY      VARCHAR2(16),
  ZT       INTEGER,
  BZ       VARCHAR2(64),
  SPRID    INTEGER,
  KHLX     VARCHAR2(1),
  HXJE     NUMBER(20,9),
  WHXJE    NUMBER(20,9),
  ISREFER  INTEGER default 0,
  ISNET    INTEGER default 0 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CW_XSJS
  is '销售结算';
comment on column CW_XSJS.DJXZ
  is '1=销售收款,-1=销售退款';
comment on column CW_XSJS.DJH
  is '单据号';
comment on column CW_XSJS.RQ
  is '日期';
comment on column CW_XSJS.JSDH
  is '结算单号';
comment on column CW_XSJS.JE
  is '金额';
comment on column CW_XSJS.ZH
  is '帐号';
comment on column CW_XSJS.YH
  is '银行';
comment on column CW_XSJS.ZT
  is '0=未审核,1=审核';
comment on column CW_XSJS.BZ
  is '备注';
alter table CW_XSJS
  add constraint PK_CW_XSJS primary key (XSJSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_XSJS
  add constraint FK_CW_XSJS_BM_XSJS_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_XSJS
  add constraint FK_CW_XSJS_DWTX_XSJS_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table CW_XSJS
  add constraint FK_CW_XSJS_EMP_XSJS_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_XSJS
  add constraint FK_CW_XSJS_JSFS_XSJS_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
create index BM_XSJS_FK on CW_XSJS (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CS_XSJS_ISREFER_IDX on CW_XSJS (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_XSJS_CZYID_IDX on CW_XSJS (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_XSJS_KHLX_IDX on CW_XSJS (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CW_XSJS_RQ_IDX on CW_XSJS (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_XSJS_FK on CW_XSJS (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_XSJS_FK on CW_XSJS (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_XSJS_FK on CW_XSJS (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_XSJSHX
prompt ========================
prompt
create table CW_XSJSHX
(
  XSJSHXID INTEGER not null,
  TDHWID   INTEGER,
  XSJSID   INTEGER,
  JSJE     NUMBER(20,9),
  TCL      NUMBER(9,6),
  TCJ      NUMBER(20,9),
  YHRQ     DATE,
  CPID     INTEGER,
  DMSXID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table CW_XSJSHX
  is '销售结算核销';
comment on column CW_XSJSHX.JSJE
  is '结算金额';
comment on column CW_XSJSHX.TCL
  is '提成率';
comment on column CW_XSJSHX.TCJ
  is '提成奖';
comment on column CW_XSJSHX.YHRQ
  is '应回日期';
alter table CW_XSJSHX
  add constraint PK_CW_XSJSHX primary key (XSJSHXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_XSJSHX
  add constraint FK_CW_XSJSH_CWXSJS_HX_CW_XSJS foreign key (XSJSID)
  references CW_XSJS (XSJSID);
alter table CW_XSJSHX
  add constraint FK_CW_XSJSH_DMSX_XSJS_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table CW_XSJSHX
  add constraint FK_CW_XSJSH_KCDM_XSJS_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table CW_XSJSHX
  add constraint FK_CW_XSJSH_XSTDHW_CW_XS_TDHW foreign key (TDHWID)
  references XS_TDHW (TDHWID);
create index CWXSJS_HX_FK on CW_XSJSHX (XSJSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_XSJS_FK on CW_XSJSHX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_XSJSHX_FK on CW_XSJSHX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSTDHW_CWHX_FK on CW_XSJSHX (TDHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table YH
prompt =================
prompt
create table YH
(
  YHID INTEGER not null,
  DM   VARCHAR2(10),
  YHMC VARCHAR2(64),
  ADDR VARCHAR2(32),
  TEL  VARCHAR2(32),
  LXR  VARCHAR2(16)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table YH
  add constraint PK_YH primary key (YHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table YHZH
prompt ===================
prompt
create table YHZH
(
  YHZHID INTEGER not null,
  DEPTID INTEGER,
  YHID   INTEGER,
  ZH     VARCHAR2(64),
  ZHMC   VARCHAR2(64),
  ZHLX   INTEGER,
  FGSID  NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column YHZH.ZHLX
  is '1-现金帐户
2-银行帐户';
alter table YHZH
  add constraint PK_YHZH primary key (YHZHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table YHZH
  add constraint FK_YHZH_RELATIONS_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table YHZH
  add constraint FK_YHZH_YH_ZH_YH foreign key (YHID)
  references YH (YHID)
  disable;
create index RELATIONSHIP_21_FK on YHZH (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YHZH_FGSID_IDX on YHZH (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YH_ZH_FK on YHZH (YHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_YHZHSZ
prompt ========================
prompt
create table CW_YHZHSZ
(
  YHZHSZID INTEGER not null,
  JSFSID   INTEGER,
  YHZHID   INTEGER,
  PERSONID INTEGER,
  DEPTID   INTEGER,
  RQ       DATE,
  HM       VARCHAR2(32),
  ZY       VARCHAR2(64),
  SR       NUMBER(14,6),
  ZC       NUMBER(14,6),
  FX       INTEGER,
  ISINIT   INTEGER,
  FGSID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_YHZHSZ.ZY
  is '初始化：初始余额';
comment on column CW_YHZHSZ.FX
  is '1=收入,2=支出';
alter table CW_YHZHSZ
  add constraint PK_CW_YHZHSZ primary key (YHZHSZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_YHZHSZ
  add constraint FK_CW_YHZHS_BM_YHZHSZ_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_YHZHSZ
  add constraint FK_CW_YHZHS_EMP_YHZHS_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_YHZHSZ
  add constraint FK_CW_YHZHS_JSFS_YHZH_JSFS foreign key (JSFSID)
  references JSFS (JSFSID);
alter table CW_YHZHSZ
  add constraint FK_CW_YHZHS_ZH_YHZHSZ_YHZH foreign key (YHZHID)
  references YHZH (YHZHID);
create index BM_YHZHSZ_FK on CW_YHZHSZ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_YHZHSZ_FK on CW_YHZHSZ (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JSFS_YHZHSZ_FK on CW_YHZHSZ (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YHZHSZ_FGSID_IDX on CW_YHZHSZ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YHZHSZ_FX_IDX on CW_YHZHSZ (FX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YHZHSZ_INIT_IDX on CW_YHZHSZ (ISINIT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ZH_YHZHSZ_FK on CW_YHZHSZ (YHZHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CW_ZPLY
prompt ======================
prompt
create table CW_ZPLY
(
  ZPLYID       INTEGER not null,
  PERSONID     INTEGER,
  EMP_PERSONID INTEGER,
  DEPTID       INTEGER,
  YHZHID       INTEGER,
  ZPH          VARCHAR2(32) not null,
  LYSJ         DATE,
  JE           NUMBER(14,6),
  YT           VARCHAR2(64),
  HXRQ         DATE,
  ISHX         INTEGER,
  ISZF         INTEGER,
  CZYID        INTEGER,
  CZY          VARCHAR2(16),
  FGSID        INTEGER,
  SKR          VARCHAR2(64),
  GRRQ         DATE,
  CPRQ         DATE
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column CW_ZPLY.PERSONID
  is '领用人';
comment on column CW_ZPLY.EMP_PERSONID
  is '出纳';
alter table CW_ZPLY
  add constraint PK_CW_ZPLY primary key (ZPLYID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table CW_ZPLY
  add constraint FK_CW_ZPLY_BM_ZPLY_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table CW_ZPLY
  add constraint FK_CW_ZPLY_CN_ZPLY_EMP foreign key (EMP_PERSONID)
  references EMP (PERSONID);
alter table CW_ZPLY
  add constraint FK_CW_ZPLY_LYR_ZPLY_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table CW_ZPLY
  add constraint FK_CW_ZPLY_ZH_ZPLY_YHZH foreign key (YHZHID)
  references YHZH (YHZHID);
create index BM_ZPLY_FK on CW_ZPLY (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CN_ZPLY_FK on CW_ZPLY (EMP_PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index LYR_ZPLY_FK on CW_ZPLY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ZH_ZPLY_FK on CW_ZPLY (YHZHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ZPLY_FGSID_IDX on CW_ZPLY (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DWTX_FILE
prompt ========================
prompt
create table DWTX_FILE
(
  FILE_ID      INTEGER not null,
  DWTXID       INTEGER not null,
  FILE_NAME    VARCHAR2(32) not null,
  MIME_TYPE    VARCHAR2(32),
  FILE_CONTENT LONG RAW
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table DWTX_FILE
  add constraint PK_DWTX_FILE primary key (FILE_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table DWTX_FILE
  add constraint FK_DWTX_FIL_DWTX_FILE_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index DWTX_FILE_FK on DWTX_FILE (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DWTX_LX
prompt ======================
prompt
create table DWTX_LX
(
  DWTXLXID INTEGER not null,
  DWTXID   INTEGER,
  YWLX     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column DWTX_LX.YWLX
  is '1=供货单位,2=经销商,3=最终客户,4=费用单位,5=服务单位,6=内部往来';
alter table DWTX_LX
  add constraint PK_DWTX_LX primary key (DWTXLXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_LX_FK on DWTX_LX (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DWTX_LXR
prompt =======================
prompt
create table DWTX_LXR
(
  LXRID         INTEGER not null,
  DWTXID        INTEGER,
  XM            VARCHAR2(32),
  CH            VARCHAR2(16),
  SEX           INTEGER,
  ZW            VARCHAR2(32),
  BGDH          VARCHAR2(32),
  CZ            VARCHAR2(32),
  YDDH          VARCHAR2(32),
  CHHM          VARCHAR2(32),
  JTJH          VARCHAR2(32),
  ISMARRY       INTEGER,
  SR            DATE,
  SJID          INTEGER,
  XXDZ          VARCHAR2(64),
  DZYJ          VARCHAR2(32),
  YZBM          VARCHAR2(16),
  BZ            VARCHAR2(128),
  LOGINNAME     VARCHAR2(64),
  LOGINPASSWORD VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column DWTX_LXR.SEX
  is '1=男，0=女';
comment on column DWTX_LXR.SJID
  is '同一单位的联系人中的一人';
alter table DWTX_LXR
  add constraint PK_DWTX_LXR primary key (LXRID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_LXR_FK on DWTX_LXR (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table NODEFIELD
prompt ========================
prompt
create table NODEFIELD
(
  NODEFIELDID INTEGER not null,
  TABLENAME   VARCHAR2(32),
  NODEID      INTEGER,
  FIELDNAME   VARCHAR2(32),
  LINKTABLE   VARCHAR2(32),
  ENUMVALUES  VARCHAR2(128),
  ORDERNUM    INTEGER,
  ISSHOW      INTEGER,
  ISBAK       INTEGER,
  INPUTTYPE   INTEGER,
  DATALEN     VARCHAR2(16),
  DESCRIBE    VARCHAR2(64),
  TABLECODE   VARCHAR2(32) not null,
  FIELDCODE   VARCHAR2(32) not null,
  SHOWFIELDS  VARCHAR2(64),
  URL         VARCHAR2(256),
  URLPARAMS   VARCHAR2(64),
  ISCHANGE    INTEGER,
  ISNULL      INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column NODEFIELD.ENUMVALUES
  is '枚字段的值（1=未审核,2=审核,3=未完成）';
comment on column NODEFIELD.INPUTTYPE
  is '1=字符型,2=文本型,3=枚举型';
alter table NODEFIELD
  add constraint PK_NODEFIELD primary key (NODEFIELDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table NODEFIELD
  add constraint AK_NODEFIELD_AK_NODEFIEL unique (TABLECODE, FIELDCODE)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEFIELD_ISCHANGE_IDX on NODEFIELD (ISCHANGE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEFIELD_ISSHOW_IDX on NODEFIELD (ISSHOW)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODE_FIELD_FK on NODEFIELD (NODEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table EMPFIELD
prompt =======================
prompt
create table EMPFIELD
(
  PERSONID    INTEGER not null,
  NODEFIELDID INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table EMPFIELD
  add constraint PK_EMPFIELD primary key (PERSONID, NODEFIELDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table EMPFIELD
  add constraint FK_EMPFIELD_EMPFIELD2_NODEFIEL foreign key (NODEFIELDID)
  references NODEFIELD (NODEFIELDID);
alter table EMPFIELD
  add constraint FK_EMPFIELD_EMPFIELD_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMPFIELD_FK on EMPFIELD (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_BASIC_TECHNICS
prompt ================================
prompt
create table JC_BASIC_TECHNICS
(
  ID                    NUMBER(6) not null,
  CODE                  VARCHAR2(80),
  NAME                  VARCHAR2(80),
  SEQUENCE              NUMBER(4),
  DEPTID                NUMBER(6),
  PRE_PROCEDURE         NUMBER(1),
  PRE_ACCOMPLISH        NUMBER(1),
  SULFURATION_PRECEDURE NUMBER(1),
  TIMES_PERSON          NUMBER(6),
  OUT_PROCEDURE         NUMBER(1),
  PACK_PROCEDURE        NUMBER(1),
  PRICE_TIME            NUMBER(6,2),
  PASS_PERCENT          NUMBER(6,2),
  BY_JOB                NUMBER(1),
  JOIN_PROCEDURE        NUMBER(1),
  DESCRIPTION           VARCHAR2(200)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table JC_BASIC_TECHNICS
  add constraint PK_JC_BASIC_TECHNICS primary key (ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table JC_BASIC_TECHNICS
  add constraint FK_JC_BASIC_REFERENCE_BM foreign key (DEPTID)
  references BM (DEPTID);

prompt
prompt Creating table JC_BMQX
prompt ======================
prompt
create table JC_BMQX
(
  PERSONID INTEGER not null,
  DEPTID   INTEGER not null,
  QXLX     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_BMQX
  add constraint PK_JC_BMQX primary key (PERSONID, DEPTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_BMQX
  add constraint FK_JC_BMQX_JC_BMQX2_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table JC_BMQX
  add constraint FK_JC_BMQX_JC_BMQX_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index JC_BMQX2_FK on JC_BMQX (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JC_BMQX_FK on JC_BMQX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_BMQZ
prompt ======================
prompt
create table JC_BMQZ
(
  PERSONID INTEGER not null,
  DEPTID   INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_BMQZ
  add constraint PK_JC_BMQZ primary key (PERSONID, DEPTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JC_BMQZ2_FK on JC_BMQZ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JC_BMQZ_FK on JC_BMQZ (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_CHECKOUT
prompt ==========================
prompt
create table JC_CHECKOUT
(
  JSRQ    DATE,
  ZT      INTEGER,
  CHECKID INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column JC_CHECKOUT.ZT
  is '0.未审核,1.审核,2.记帐,8.完成,9.审批中';
alter table JC_CHECKOUT
  add constraint PK_JC_CHECKOUT primary key (CHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_CHECKDETAIL
prompt =============================
prompt
create table JC_CHECKDETAIL
(
  SFDJID    INTEGER,
  SFDJLBID  INTEGER,
  YTID      INTEGER,
  STOREID   INTEGER,
  DEPTID    INTEGER,
  DWTXID    INTEGER,
  SFDJDH    VARCHAR2(32),
  SFRQ      DATE,
  DJXZ      INTEGER,
  ISREFFER  INTEGER,
  ZT        INTEGER,
  FGSID     INTEGER,
  DJMC      VARCHAR2(32),
  RKDMXID   INTEGER,
  KWID      INTEGER,
  DMSXID    INTEGER,
  CPID      INTEGER,
  PH        VARCHAR2(32),
  WZMXID    INTEGER,
  SRSL      NUMBER(16,6),
  SRHSSL    NUMBER(16,6),
  SRDJ      NUMBER(16,6),
  SRJE      NUMBER(16,6),
  FCSL      NUMBER(16,6),
  FCHSSL    NUMBER(16,6),
  FCDJ      NUMBER(16,6),
  FCJE      NUMBER(16,6),
  BC        VARCHAR2(32),
  KHLX      VARCHAR2(1),
  CHECKMXID INTEGER not null,
  CHECKID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column JC_CHECKDETAIL.DJXZ
  is '1=合同入库单,2=销售出库单,7=损溢单,8=移库单,9=其他入库单,10=其他出库单,11=同价调拨单';
comment on column JC_CHECKDETAIL.ZT
  is '0.未审核,1.审核,2.记帐,8.完成,9.审批中';
comment on column JC_CHECKDETAIL.KHLX
  is 'A=A,C=C';
alter table JC_CHECKDETAIL
  add constraint PK_JC_CHECKDETAIL primary key (CHECKMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table JC_CHECKDETAIL
  add constraint FK_JC_CHECK_KC_CHECK__JC_CHECK foreign key (CHECKID)
  references JC_CHECKOUT (CHECKID);
create index KC_CHECK_DETAIL_FK on JC_CHECKDETAIL (CHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_CKQX
prompt ======================
prompt
create table JC_CKQX
(
  STOREID  INTEGER not null,
  PERSONID INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_CKQX
  add constraint PK_JC_CKQX primary key (STOREID, PERSONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_CKQX
  add constraint FK_JC_CKQX_JC_CKQX2_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table JC_CKQX
  add constraint FK_JC_CKQX_JC_CKQX_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
create index JC_CKQX2_FK on JC_CKQX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JC_CKQX_FK on JC_CKQX (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_CODERULE
prompt ==========================
prompt
create table JC_CODERULE
(
  CODERULE  VARCHAR2(32) not null,
  MAXLEN    INTEGER,
  RULENAME  VARCHAR2(32),
  ISTREE    INTEGER default 0,
  TABLECODE VARCHAR2(32),
  FIELDCODE VARCHAR2(32),
  WHERECOND VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_CODERULE
  add constraint PK_JC_CODERULE primary key (CODERULE)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_CODERULE_CONT
prompt ===============================
prompt
create table JC_CODERULE_CONT
(
  CODERULE   VARCHAR2(32) not null,
  CODEPREFIX VARCHAR2(16),
  DATEFORMAT VARCHAR2(16),
  AUTOLEN    INTEGER,
  SEGMENTNUM INTEGER,
  SEGFORMAT  VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_CODERULE_CONT
  add constraint PK_JC_CODERULE_CONT primary key (CODERULE)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_CODERULE_CONT
  add constraint FK_JC_CODER_CODERULE_JC_CODER foreign key (CODERULE)
  references JC_CODERULE (CODERULE);

prompt
prompt Creating table JC_COMMON_UNIT
prompt =============================
prompt
create table JC_COMMON_UNIT
(
  ID   INTEGER not null,
  CODE VARCHAR2(32),
  NAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table JC_COMMON_UNIT
  add constraint PK_JC_COMMON_UNIT primary key (ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZXWH
prompt ===================
prompt
create table ZXWH
(
  LXID INTEGER not null,
  MC   VARCHAR2(64),
  LX   INTEGER,
  PXH  INTEGER,
  DM   VARCHAR2(16)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZXWH.LX
  is '物资相关:(11:品名,12:材质 13:规格 14:产地)
/*1.销售合同类型 2.提单业务类型 3.提单发货方式
4.采购合同类型 5.销售机会来源类型 6.市场活动类型 7.购买方式*/';
alter table ZXWH
  add constraint PK_ZXWH primary key (LXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_FYFL
prompt ======================
prompt
create table JC_FYFL
(
  FYFLID  INTEGER not null,
  STOREID INTEGER,
  LXID    INTEGER,
  DWTXID  INTEGER,
  FYDL    INTEGER,
  FL      NUMBER(7,3),
  DJSM    VARCHAR2(32),
  PZ      VARCHAR2(16),
  JGLX    VARCHAR2(16),
  QYDD    VARCHAR2(32),
  MDDD    VARCHAR2(32),
  FGSID   NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column JC_FYFL.LXID
  is '杂项维护的lx=41的数据';
comment on column JC_FYFL.FYDL
  is '值 1:加工费 2:运输费 3:仓储费';
alter table JC_FYFL
  add constraint PK_JC_FYFL primary key (FYFLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_FYFL
  add constraint FK_JC_FYFL_FY_FYFL_ZXWH foreign key (LXID)
  references ZXWH (LXID);
alter table JC_FYFL
  add constraint FK_JC_FYFL_KC_FYFL_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
create index DWTX_FYFL_FK on JC_FYFL (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index FYFL_FGSID_IDX on JC_FYFL (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index FY_FYFL_FK on JC_FYFL (LXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_FYFL_FK on JC_FYFL (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_RZ
prompt ====================
prompt
create table JC_RZ
(
  RZID     INTEGER not null,
  PERSONID INTEGER,
  CZRQ     DATE,
  IP       VARCHAR2(32),
  URL      VARCHAR2(64),
  CZMS     VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_RZ
  add constraint PK_JC_RZ primary key (RZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_RZ
  add constraint FK_JC_RZ_EMP_RZ_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_CZRQ_IDX on JC_RZ (CZRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_IP_IDX on JC_RZ (IP)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_RZ_FK on JC_RZ (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table JC_YJRQ
prompt ======================
prompt
create table JC_YJRQ
(
  YF INTEGER not null,
  RQ INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table JC_YJRQ
  add constraint PK_JC_YJRQ primary key (YF)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_CB_TMP
prompt ========================
prompt
create global temporary table KC_CB_TMP
(
  JGCPID INTEGER,
  CLCPID INTEGER,
  CLSL   NUMBER(16,6)
)
on commit delete rows;
create index KCCBTMP_JGCPID_IDX on KC_CB_TMP (JGCPID);

prompt
prompt Creating table KC_CSDJYT
prompt ========================
prompt
create table KC_CSDJYT
(
  YTID INTEGER not null,
  YTBH VARCHAR2(32),
  YTMC VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_CSDJYT
  is '生产单据用途';
comment on column KC_CSDJYT.YTBH
  is '用途编号';
comment on column KC_CSDJYT.YTMC
  is '用途名称';
alter table KC_CSDJYT
  add constraint PK_KC_CSDJYT primary key (YTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_DMLBSX
prompt ========================
prompt
create table KC_DMLBSX
(
  DLSXID INTEGER not null,
  WZLBID INTEGER,
  SXMC   VARCHAR2(32),
  SXLX   VARCHAR2(16)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_DMLBSX
  add constraint PK_KC_DMLBSX primary key (DLSXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_DMLBSX
  add constraint FK_KC_DMLBS_KC_DMLB_S_KC_DMLB foreign key (WZLBID)
  references KC_DMLB (WZLBID);
create index KC_DMLB_SX_FK on KC_DMLBSX (WZLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_DM_LS
prompt =======================
prompt
create table KC_DM_LS
(
  CPLSID  INTEGER not null,
  CPID    INTEGER,
  WZLB    VARCHAR2(32),
  CPBM    VARCHAR2(32),
  ZJM     VARCHAR2(32),
  PM      VARCHAR2(32),
  GG      VARCHAR2(32),
  TXM     VARCHAR2(32),
  TH      VARCHAR2(32),
  ABC     VARCHAR2(1),
  JJFF    INTEGER,
  JLDW    VARCHAR2(10),
  HSDW    VARCHAR2(10),
  HSBL    NUMBER(14,4),
  MAXSL   NUMBER(16,6),
  MINSL   NUMBER(16,6),
  JHDJ    NUMBER(20,9),
  CHXZ    INTEGER,
  TQQ     INTEGER,
  BZ      VARCHAR2(256),
  ISPROPS INTEGER,
  ISSALE  INTEGER,
  CSCJ    VARCHAR2(32),
  XGR     VARCHAR2(32),
  GXSJ    DATE,
  CKMC    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_DM_LS.CPBM
  is '=产品树的编码规则';
comment on column KC_DM_LS.ABC
  is '值:a,b,c';
comment on column KC_DM_LS.JJFF
  is '1=加权平均法,2=移动平均法,3=计划单价法';
comment on column KC_DM_LS.CHXZ
  is '1=自制件,2=外购件,3=外协件,4=虚拟件';
comment on column KC_DM_LS.ISPROPS
  is '是否有规格属性';
alter table KC_DM_LS
  add constraint PK_KC_DM_LS primary key (CPLSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_KCNJC
prompt =======================
prompt
create table KC_KCNJC
(
  CPID    INTEGER not null,
  NF      INTEGER not null,
  YF      INTEGER not null,
  FGSID   INTEGER not null,
  SYSL    NUMBER(16,6),
  SSL     NUMBER(16,6),
  FSL     NUMBER(16,6),
  JCSL    NUMBER(16,6),
  SYDJ    NUMBER(20,9),
  JCDJ    NUMBER(20,9),
  SYJE    NUMBER(20,9),
  SJE     NUMBER(20,9),
  FJE     NUMBER(20,9),
  JCJE    NUMBER(20,9),
  DMSXID  INTEGER,
  STOREID INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_KCNJC
  add constraint AK_KC_KCNJC_AK_KC_KCNJC unique (NF, YF, FGSID, CPID, DMSXID, STOREID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_KCNJC
  add constraint FK_KC_KCNJC_DMSX_NJC_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table KC_KCNJC
  add constraint FK_KC_KCNJC_KCDM_KCNJ_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table KC_KCNJC
  add constraint FK_KC_KCNJC_KC_NJC_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
create index DMSX_NJC_FK on KC_KCNJC (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_KCNJC_FK on KC_KCNJC (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_KCNJC_FGSID_IDX on KC_KCNJC (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_KCNJC_NF_IDX on KC_KCNJC (NF)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_KCNJC_YF_IDX on KC_KCNJC (YF)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_NJC_FK on KC_KCNJC (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_KCNJC_TMP
prompt ===========================
prompt
create global temporary table KC_KCNJC_TMP
(
  CPID INTEGER not null,
  SYSL NUMBER(16,6),
  SSL  NUMBER(16,6),
  FSL  NUMBER(16,6),
  JCSL NUMBER(16,6),
  SYDJ NUMBER(20,9),
  JCDJ NUMBER(20,9),
  SYJE NUMBER(20,9),
  SJE  NUMBER(20,9),
  FJE  NUMBER(20,9),
  JCJE NUMBER(20,9)
)
on commit delete rows;
alter table KC_KCNJC_TMP
  add constraint PK_KC_KCNJC_TMP primary key (CPID);

prompt
prompt Creating table KC_KW
prompt ====================
prompt
create table KC_KW
(
  KWID    INTEGER not null,
  STOREID INTEGER,
  DM      VARCHAR2(10),
  MC      VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_KW
  add constraint PK_KC_KW primary key (KWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CK_KW_FK on KC_KW (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_KWTZ
prompt ======================
prompt
create table KC_KWTZ
(
  KWTZID   INTEGER not null,
  CPID     INTEGER,
  WZMXID   INTEGER,
  KC__CPID INTEGER,
  KWTZBH   VARCHAR2(32),
  JJLDW    VARCHAR2(10),
  JJLFS    INTEGER,
  JCCH     VARCHAR2(32),
  JKBH     VARCHAR2(32),
  JCPH     VARCHAR2(32),
  JZL      NUMBER(14,4),
  JJS      NUMBER(14,4),
  JLDW     VARCHAR2(10),
  JLFS     INTEGER,
  CCH      VARCHAR2(32),
  KBH      VARCHAR2(32),
  CPH      VARCHAR2(32),
  ZL       NUMBER(14,4),
  JS       NUMBER(14,4),
  CZY      VARCHAR2(16),
  FGSID    INTEGER,
  CZYID    INTEGER,
  CZRQ     DATE,
  BZ       VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_KWTZ.KC__CPID
  is '旧产品ID';
comment on column KC_KWTZ.JJLFS
  is '1=磅计,2=理计,3=抄码';
comment on column KC_KWTZ.JLFS
  is '1=磅计,2=理计,3=抄码';
alter table KC_KWTZ
  add constraint PK_KC_KWTZ primary key (KWTZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JCP_KWTZ_FK on KC_KWTZ (KC__CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZMX_KWTZ_FK on KC_KWTZ (WZMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XCP_KWTZ_FK on KC_KWTZ (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_OTHER_SFDJ
prompt ============================
prompt
create table KC_OTHER_SFDJ
(
  SFDJID     INTEGER not null,
  SFDJLBID   INTEGER,
  YTID       INTEGER,
  STOREID    INTEGER,
  DEPTID     INTEGER,
  JSFSID     INTEGER,
  KC_STOREID INTEGER,
  DWTXID     INTEGER,
  SFDJDH     VARCHAR2(32),
  YKDRDH     VARCHAR2(32),
  SFRQ       DATE,
  DJXZ       INTEGER not null,
  JFKM       VARCHAR2(32),
  BZ         VARCHAR2(64),
  JSR        VARCHAR2(32),
  ZSL        NUMBER(15,6),
  ZJE        NUMBER(20,9),
  ZT         INTEGER,
  ZTMS       VARCHAR2(32),
  ZDRQ       DATE,
  ZDRID      INTEGER,
  ZDR        VARCHAR2(32),
  FGSID      INTEGER,
  SPRID      INTEGER,
  KHLX       VARCHAR2(1),
  PDID       INTEGER,
  ISREFER    INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_OTHER_SFDJ
  is '收发单据';
comment on column KC_OTHER_SFDJ.KC_STOREID
  is '调入仓库';
comment on column KC_OTHER_SFDJ.DJXZ
  is '1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单';
comment on column KC_OTHER_SFDJ.JFKM
  is '用于报损单';
comment on column KC_OTHER_SFDJ.JSR
  is '经手人';
comment on column KC_OTHER_SFDJ.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
alter table KC_OTHER_SFDJ
  add constraint PK_KC_OTHER_SFDJ primary key (SFDJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_OTHER_SFDJ
  add constraint FK_KC_OTHER_SFDJ_BM_RKD_BM foreign key (DEPTID)
  references BM (DEPTID)
  disable;
alter table KC_OTHER_SFDJ
  add constraint FK_KC_OTHER_SFDJ_DWTX_RKD_DWTX foreign key (DWTXID)
  references DWTX (DWTXID)
  disable;
alter table KC_OTHER_SFDJ
  add constraint FK_KC_OTHER_SFDJ_RSFS_RKD_JSFS foreign key (JSFSID)
  references JSFS (JSFSID)
  disable;
create index DWTX_OTHER_RKD_FK on KC_OTHER_SFDJ (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_DJXZ_IDX on KC_OTHER_SFDJ (DJXZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_FGSID_IDX on KC_OTHER_SFDJ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_FK on KC_OTHER_SFDJ (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_ISREFER_IDX on KC_OTHER_SFDJ (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_KHLX_IDX on KC_OTHER_SFDJ (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_SFRQ_IDX on KC_OTHER_SFDJ (SFRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_ZDRID_IDX on KC_OTHER_SFDJ (ZDR)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJ_ZT_IDX on KC_OTHER_SFDJ (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_OTHER_SFDJMX
prompt ==============================
prompt
create table KC_OTHER_SFDJMX
(
  RKDMXID  INTEGER not null,
  KWID     INTEGER,
  DMSXID   INTEGER,
  SFDJID   INTEGER not null,
  CPID     INTEGER,
  DJXZ     INTEGER not null,
  WJID     INTEGER,
  PH       VARCHAR2(32),
  HSSL     NUMBER(14,4),
  SL       NUMBER(14,4),
  DJ       NUMBER(20,9),
  JE       NUMBER(20,9),
  BZ       VARCHAR2(64),
  XHSL     NUMBER(16,6),
  WZMXID   INTEGER,
  KC__KWID INTEGER,
  FGSID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_OTHER_SFDJMX.DJXZ
  is '1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单';
comment on column KC_OTHER_SFDJMX.WJID
  is '根据单据性质与相应的表关联';
comment on column KC_OTHER_SFDJMX.KC__KWID
  is '调出库位id';
alter table KC_OTHER_SFDJMX
  add constraint PK_KC_OTHER_SFDJMX primary key (RKDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_OTHER_SFDJMX
  add constraint FK_KC_OTHER_SFDJMX_CPID foreign key (CPID)
  references KC_DM (CPID)
  disable;
alter table KC_OTHER_SFDJMX
  add constraint FK_KC_OTHER_SFDJM_MX_SFDJID foreign key (SFDJID)
  references KC_OTHER_SFDJ (SFDJID)
  disable;
create index KC_OTHER_SFDJMX_DJXZ_IDX on KC_OTHER_SFDJMX (DJXZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_OTHER_SFDJMX_PH_IDX on KC_OTHER_SFDJMX (PH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index OTHER_KCRKD_MX_FK on KC_OTHER_SFDJMX (SFDJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index OTHER_WZMX_SFDJMX_FK on KC_OTHER_SFDJMX (WZMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index OTHER_WZ_FSDJ_FK on KC_OTHER_SFDJMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_PACKAGE
prompt =========================
prompt
create table KC_PACKAGE
(
  PACKAGE_ID   INTEGER not null,
  PACKAGE_CODE VARCHAR2(32),
  PACKAGE_NAME VARCHAR2(64),
  ISDELETE     INTEGER default 0,
  FUNDITEMID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PACKAGE
  add constraint PK_KC_PACKAGE primary key (PACKAGE_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_PACKAGE_DETAIL
prompt ================================
prompt
create table KC_PACKAGE_DETAIL
(
  PACKAGEDETAILID INTEGER not null,
  PACKAGE_ID      INTEGER,
  CPID            INTEGER not null,
  DMSXID          NUMBER(20,9),
  SL              NUMBER(16,6),
  BZ              VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PACKAGE_DETAIL
  add constraint PK_KC_PACKAGE_DETAIL primary key (PACKAGEDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PACKAGE_DETAIL
  add constraint FK_PACKAGE_DETAIL_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table KC_PACKAGE_DETAIL
  add constraint FK_PACKAGE_DETAIL_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table KC_PACKAGE_DETAIL
  add constraint FK_PACKAGE_DETAIL_PACKAGE foreign key (PACKAGE_ID)
  references KC_PACKAGE (PACKAGE_ID);
create index KCDMSX_PACKAGE_DETAIL_FK on KC_PACKAGE_DETAIL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PACKAGE_DETAIL_FK on KC_PACKAGE_DETAIL (PACKAGE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_PACKAGE_DETAIL_FK on KC_PACKAGE_DETAIL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_PD
prompt ====================
prompt
create table KC_PD
(
  PDID    INTEGER not null,
  DEPTID  INTEGER,
  STOREID INTEGER,
  PDHM    VARCHAR2(32),
  RQ      DATE,
  PDR     VARCHAR2(32),
  ZT      INTEGER,
  ZTMS    VARCHAR2(32),
  ZDRQ    DATE,
  ZDRID   INTEGER,
  ZDR     VARCHAR2(32),
  FGSID   INTEGER,
  SPRID   INTEGER,
  ISREFER INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_PD.ZT
  is '0.未审核,1.审核,2.已入库,9.已完成';
alter table KC_PD
  add constraint PK_KC_PD primary key (PDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PD
  add constraint FK_KC_PD_BM_PD_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table KC_PD
  add constraint FK_KC_PD_CK_PD_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
create index BM_PD_FK on KC_PD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CK_PD_FK on KC_PD (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_FGSID_IDX on KC_PD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_ISREFER_IDX on KC_PD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_PDHM_IDX on KC_PD (PDHM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_ZDRID_IDX on KC_PD (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_ZT_IDX on KC_PD (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_PDMX
prompt ======================
prompt
create table KC_PDMX
(
  PDMXID INTEGER not null,
  CPID   INTEGER,
  PDID   INTEGER,
  ZCSL   NUMBER(16,6),
  SCSL   NUMBER(16,6),
  PH     VARCHAR2(32),
  BZ     INTEGER,
  DMSXID INTEGER,
  HSSL   NUMBER(16,6),
  KWID   INTEGER,
  ZCHSSL NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PDMX
  add constraint PK_KC_PDMX primary key (PDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_PDMX
  add constraint FK_KC_PDMX_DMSX_PDMX_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table KC_PDMX
  add constraint FK_KC_PDMX_KCDM_PDMX_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table KC_PDMX
  add constraint FK_KC_PDMX_KCKW_PDMX_KC_KW foreign key (KWID)
  references KC_KW (KWID);
alter table KC_PDMX
  add constraint FK_KC_PDMX_KC_PD_MX_KC_PD foreign key (PDID)
  references KC_PD (PDID);
create index DMSX_PDMX_FK on KC_PDMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_PDMX_FK on KC_PDMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCKW_PDMX_FK on KC_PDMX (KWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_MX_FK on KC_PDMX (PDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_SFDJLB
prompt ========================
prompt
create table KC_SFDJLB
(
  SFDJLBID INTEGER not null,
  DJXZ     INTEGER not null,
  LBMC     VARCHAR2(32),
  LBBM     VARCHAR2(32),
  SRLX     INTEGER default 1
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_SFDJLB
  is '收发单据类别';
comment on column KC_SFDJLB.DJXZ
  is '1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单';
alter table KC_SFDJLB
  add constraint PK_KC_SFDJLB primary key (SFDJLBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_SFDJ
prompt ======================
prompt
create table KC_SFDJ
(
  SFDJID      INTEGER not null,
  SFDJLBID    INTEGER,
  YTID        INTEGER,
  STOREID     INTEGER not null,
  DEPTID      INTEGER,
  JSFSID      INTEGER,
  KC__STOREID INTEGER,
  DWTXID      INTEGER,
  SFDJDH      VARCHAR2(32),
  YKDRDH      VARCHAR2(32),
  SFRQ        DATE,
  DJXZ        INTEGER not null,
  JFKM        VARCHAR2(32),
  BZ          VARCHAR2(64),
  JSR         VARCHAR2(32),
  ZSL         NUMBER(15,6),
  ZJE         NUMBER(20,9),
  ZT          INTEGER,
  ZTMS        VARCHAR2(32),
  ZDRQ        DATE,
  ZDRID       INTEGER,
  ZDR         VARCHAR2(32),
  FGSID       INTEGER,
  SPRID       INTEGER,
  KHLX        VARCHAR2(1),
  PDID        INTEGER,
  ISREFER     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_SFDJ
  is '收发单据';
comment on column KC_SFDJ.KC__STOREID
  is '调入仓库';
comment on column KC_SFDJ.DJXZ
  is '1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单';
comment on column KC_SFDJ.JFKM
  is '用于报损单';
comment on column KC_SFDJ.JSR
  is '经手人';
comment on column KC_SFDJ.ZT
  is '0或NULL.未审核,1.审核,2.已入库,9.已完成';
alter table KC_SFDJ
  add constraint PK_KC_SFDJ primary key (SFDJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_BM_RKD_BM foreign key (DEPTID)
  references BM (DEPTID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_CSDJYT_SF_KC_CSDJY foreign key (YTID)
  references KC_CSDJYT (YTID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_DWTX_RKD_DWTX foreign key (DWTXID)
  references DWTX (DWTXID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_KC2_SFDJ_KC_CK foreign key (KC__STOREID)
  references KC_CK (STOREID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_KC_PD_SFD_KC_PD foreign key (PDID)
  references KC_PD (PDID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_KC_SFDJ_KC_CK foreign key (STOREID)
  references KC_CK (STOREID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_RSFS_RKD_JSFS foreign key (JSFSID)
  references JSFS (JSFSID)
  disable;
alter table KC_SFDJ
  add constraint FK_KC_SFDJ_SFDJLB_KC_SFDJL foreign key (SFDJLBID)
  references KC_SFDJLB (SFDJLBID)
  disable;
create index BM_RKD_FK on KC_SFDJ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CSDJYT_SFDJ_FK on KC_SFDJ (YTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_RKD_FK on KC_SFDJ (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC2_SFDJ_FK on KC_SFDJ (KC__STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_PD_SFDJ_FK on KC_SFDJ (PDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_DJXZ_IDX on KC_SFDJ (DJXZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_FGSID_IDX on KC_SFDJ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_FK on KC_SFDJ (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_ISREFER_IDX on KC_SFDJ (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_KHLX_IDX on KC_SFDJ (KHLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_SFRQ_IDX on KC_SFDJ (SFRQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_ZDRID_IDX on KC_SFDJ (ZDR)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJ_ZT_IDX on KC_SFDJ (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RSFS_RKD_FK on KC_SFDJ (JSFSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SFDJLB_FK on KC_SFDJ (SFDJLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_SFDJMX
prompt ========================
prompt
create table KC_SFDJMX
(
  RKDMXID  INTEGER not null,
  KWID     INTEGER,
  DMSXID   INTEGER,
  SFDJID   INTEGER not null,
  CPID     INTEGER,
  DJXZ     INTEGER not null,
  WJID     INTEGER,
  PH       VARCHAR2(32),
  HSSL     NUMBER(14,4),
  SL       NUMBER(14,4),
  DJ       NUMBER(20,9),
  JE       NUMBER(20,9),
  BZ       VARCHAR2(64),
  XHSL     NUMBER(16,6),
  WZMXID   INTEGER,
  KC__KWID INTEGER,
  FGSID    NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column KC_SFDJMX.DJXZ
  is '1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单';
comment on column KC_SFDJMX.WJID
  is '根据单据性质与相应的表关联';
comment on column KC_SFDJMX.KC__KWID
  is '调出库位id';
alter table KC_SFDJMX
  add constraint PK_KC_SFDJMX primary key (RKDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table KC_SFDJMX
  add constraint FK_KC_SFDJM_DCKW_SFDJ_KC_KW foreign key (KC__KWID)
  references KC_KW (KWID)
  disable;
alter table KC_SFDJMX
  add constraint FK_KC_SFDJM_KCRKD_MX_KC_SFDJ foreign key (SFDJID)
  references KC_SFDJ (SFDJID)
  disable;
alter table KC_SFDJMX
  add constraint FK_KC_SFDJM_KC_DMSX_F_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID)
  disable;
alter table KC_SFDJMX
  add constraint FK_KC_SFDJM_KW_FSDJ_KC_KW foreign key (KWID)
  references KC_KW (KWID)
  disable;
alter table KC_SFDJMX
  add constraint FK_KC_SFDJM_WZ_FSDJ_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
create index DCKW_SFDJ_FK on KC_SFDJMX (KC__KWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCRKD_MX_FK on KC_SFDJMX (SFDJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_DMSX_FSDJ_FK on KC_SFDJMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJMX_DJXZ_IDX on KC_SFDJMX (DJXZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KC_SFDJMX_PH_IDX on KC_SFDJMX (PH)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KW_FSDJ_FK on KC_SFDJMX (KWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZMX_SFDJMX_FK on KC_SFDJMX (WZMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZ_FSDJ_FK on KC_SFDJMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table KC_YJ
prompt ====================
prompt
create table KC_YJ
(
  NF    INTEGER not null,
  YF    INTEGER not null,
  FGSID INTEGER not null,
  SFYJ  INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table KC_YJ
  is '1.得到月结的日期区间（与月结日期jc_yjrq有关）
2.检查是否有未审核的单据
3.计算平均价并插入数据到库存年结存表 (kc_kcnjc)中
4.更新单据的单价和金额';
comment on column KC_YJ.SFYJ
  is '0=初始化,1=月结';
alter table KC_YJ
  add constraint PK_KC_YJ primary key (NF, YF, FGSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table NODEINFO
prompt =======================
prompt
create table NODEINFO
(
  NODEID       INTEGER not null,
  PARENTNODEID INTEGER,
  NODECODE     VARCHAR2(32) not null,
  NODENAME     VARCHAR2(32) not null,
  URL          VARCHAR2(64),
  ISDELETE     INTEGER not null,
  ISEXECUTE    INTEGER not null,
  NODETYPE     INTEGER not null,
  INTERCODE    VARCHAR2(32),
  ISJIT        INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column NODEINFO.URL
  is '界面相对路径的url。';
comment on column NODEINFO.NODETYPE
  is '0：表示公用的 1：erp菜单';
alter table NODEINFO
  add constraint PK_NODEINFO primary key (NODEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEINFO_CODE_IDX on NODEINFO (NODECODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEINFO_ISDEL_IDX on NODEINFO (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEINFO_ISEXE_IDX on NODEINFO (ISEXECUTE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEINFO_PARENTID_IDX on NODEINFO (PARENTNODEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index NODEINFO_TYPE_IDX on NODEINFO (NODETYPE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table NODEPRIVILIGE
prompt ============================
prompt
create table NODEPRIVILIGE
(
  PRIVILIGEID   INTEGER not null,
  PRIVILIGECODE VARCHAR2(16) not null,
  PRIVILIGENAME VARCHAR2(32) not null,
  PRIVILIGEMEMO VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table NODEPRIVILIGE
  is '描述界面上的某一权限信息。';
alter table NODEPRIVILIGE
  add constraint PK_NODEPRIVILIGE primary key (PRIVILIGEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table LIMITLIST
prompt ========================
prompt
create table LIMITLIST
(
  LIMITID     INTEGER not null,
  NODEID      INTEGER,
  PRIVILIGEID INTEGER,
  ISDELETE    INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table LIMITLIST
  add constraint PK_LIMITLIST primary key (LIMITID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table LIMITLIST
  add constraint FK_LIMITLIS_RELATIONS_NODEINFO foreign key (NODEID)
  references NODEINFO (NODEID) on delete cascade;
alter table LIMITLIST
  add constraint FK_LIMITLIS_RELATIONS_NODEPRIV foreign key (PRIVILIGEID)
  references NODEPRIVILIGE (PRIVILIGEID) on delete cascade
  disable;
create index LIMITISDELTE on LIMITLIST (ISDELETE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RELATIONSHIP_2_FK on LIMITLIST (NODEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RELATIONSHIP_3_FK on LIMITLIST (PRIVILIGEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ROLEINFO
prompt =======================
prompt
create table ROLEINFO
(
  ROLEID   INTEGER not null,
  ROLECODE VARCHAR2(16),
  ROLENAME VARCHAR2(32) not null,
  MEMO     VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ROLEINFO
  add constraint PK_ROLEINFO primary key (ROLEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PERSONLIMITS
prompt ===========================
prompt
create table PERSONLIMITS
(
  PERSONLIMITID INTEGER not null,
  ROLEID        INTEGER,
  LIMITID       INTEGER,
  PERSONID      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table PERSONLIMITS
  is '纪录操作员的用户名和所具有的权限以及角色信息。';
alter table PERSONLIMITS
  add constraint PK_PERSONLIMITS primary key (PERSONLIMITID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table PERSONLIMITS
  add constraint FK_PERSONLI_PERSON_LI_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table PERSONLIMITS
  add constraint FK_PERSONLI_ROLE_PERS_ROLEINFO foreign key (ROLEID)
  references ROLEINFO (ROLEID)
  disable;
create index LIMIT_ALL_FK on PERSONLIMITS (LIMITID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PERSON_LIMITS_FK on PERSONLIMITS (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ROLE_PERSON_FK on PERSONLIMITS (ROLEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PLAN_TABLE
prompt =========================
prompt
create table PLAN_TABLE
(
  STATEMENT_ID    VARCHAR2(30),
  TIMESTAMP       DATE,
  REMARKS         VARCHAR2(80),
  OPERATION       VARCHAR2(30),
  OPTIONS         VARCHAR2(30),
  OBJECT_NODE     VARCHAR2(128),
  OBJECT_OWNER    VARCHAR2(30),
  OBJECT_NAME     VARCHAR2(30),
  OBJECT_INSTANCE INTEGER,
  OBJECT_TYPE     VARCHAR2(30),
  OPTIMIZER       VARCHAR2(255),
  SEARCH_COLUMNS  INTEGER,
  ID              INTEGER,
  PARENT_ID       INTEGER,
  POSITION        INTEGER,
  COST            INTEGER,
  CARDINALITY     INTEGER,
  BYTES           INTEGER,
  OTHER_TAG       VARCHAR2(255),
  PARTITION_START VARCHAR2(255),
  PARTITION_STOP  VARCHAR2(255),
  PARTITION_ID    INTEGER,
  OTHER           LONG,
  DISTRIBUTION    VARCHAR2(30),
  CPU_COST        INTEGER,
  IO_COST         INTEGER,
  TEMP_SPACE      NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_EMP_CERT
prompt ==========================
prompt
create table RL_EMP_CERT
(
  PERSONID       INTEGER not null,
  LIGATE_CERT    VARCHAR2(32),
  UNMARRIED_CERT VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EMP_CERT
  add constraint PK_RL_EMP_CERT primary key (PERSONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EMP_CERT
  add constraint FK_RL_EMP_C_EMP_CERT_EMP foreign key (PERSONID)
  references EMP (PERSONID);

prompt
prompt Creating table RL_EMP_CHANGE
prompt ============================
prompt
create table RL_EMP_CHANGE
(
  CHANG_ID   INTEGER not null,
  PERSONID   INTEGER not null,
  CHG_DATE   DATE,
  CHG_TYPE   INTEGER not null,
  CHG_REASON VARCHAR2(64),
  CHG_BEFORE VARCHAR2(32),
  CHG_AFTER  VARCHAR2(32),
  STATE      INTEGER,
  STATEDESC  VARCHAR2(32),
  ISREFER    INTEGER default 0,
  CREATEDATE DATE,
  CREATORID  INTEGER,
  CREATOR    VARCHAR2(32),
  FILIALEID  INTEGER,
  APPROVEID  INTEGER,
  DEPTID     INTEGER not null,
  MEMO       VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column RL_EMP_CHANGE.CHG_TYPE
  is '1=职工离职,2=部门调动,3=类别变动,4=职务变迁,5=职员复职';
comment on column RL_EMP_CHANGE.CHG_BEFORE
  is '保存ID或属性';
comment on column RL_EMP_CHANGE.CHG_AFTER
  is '保存ID或属性';
comment on column RL_EMP_CHANGE.MEMO
  is '备注';
alter table RL_EMP_CHANGE
  add constraint PK_RL_EMP_CHANGE primary key (CHANG_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EMP_CHANGE
  add constraint FK_RL_EMP_C_DEPT_EMPC_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_EMP_CHANGE
  add constraint FK_RL_EMP_C_EMP_CHANG_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DEPT_EMPCHG_FK on RL_EMP_CHANGE (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CHANGE_FK on RL_EMP_CHANGE (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EMP_CHG_CREATORID_IDX on RL_EMP_CHANGE (CREATORID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EMP_CHG_FILIALEID_IDX on RL_EMP_CHANGE (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EMP_CHG_ISRFER_IDX on RL_EMP_CHANGE (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EMP_CHG_STATE_IDX on RL_EMP_CHANGE (STATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_EMP_CHANGE_DETAIL
prompt ===================================
prompt
create table RL_EMP_CHANGE_DETAIL
(
  CHG_DETAIL_ID INTEGER not null,
  CHANG_ID      INTEGER,
  REMOVE_GOODS  VARCHAR2(32),
  REMOVE_THING  VARCHAR2(32),
  ACCEPTER      VARCHAR2(32),
  MEMO          VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EMP_CHANGE_DETAIL
  add constraint PK_RL_EMP_CHANGE_DETAIL primary key (CHG_DETAIL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EMP_CHANGE_DETAIL
  add constraint FK_RL_EMP_C_EMPCHG_DE_RL_EMP_C foreign key (CHANG_ID)
  references RL_EMP_CHANGE (CHANG_ID);
create index EMPCHG_DETAIL_FK on RL_EMP_CHANGE_DETAIL (CHANG_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_EVECTION_APPLY
prompt ================================
prompt
create table RL_EVECTION_APPLY
(
  EVECTION_ID     INTEGER not null,
  DEPTID          INTEGER,
  PERSONID        INTEGER,
  EVECTION_CODE   VARCHAR2(32),
  DUTY            VARCHAR2(32),
  DEPUTY          VARCHAR2(32),
  EVECTION_ADDR   VARCHAR2(64),
  FEE_BUDGET      VARCHAR2(32),
  FEE_PREPAY      VARCHAR2(32),
  EVECTION_START  DATE,
  EVECTION_END    DATE,
  EVECTION_REASON VARCHAR2(256),
  STATE           INTEGER,
  STATEDESC       VARCHAR2(32),
  ISREFER         INTEGER default 0,
  CREATEDATE      DATE,
  CREATORID       INTEGER,
  CREATOR         VARCHAR2(32),
  FILIALEID       INTEGER,
  APPROVEID       NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EVECTION_APPLY
  add constraint PK_RL_EVECTION_APPLY primary key (EVECTION_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EVECTION_APPLY
  add constraint FK_RL_EVECT_DEPT_EVEC_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_EVECTION_APPLY
  add constraint FK_RL_EVECT_EMP_EVECT_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DEPT_EVECTION_FK on RL_EVECTION_APPLY (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_EVECTION_FK on RL_EVECTION_APPLY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EVEC_APP_CODE_IDX on RL_EVECTION_APPLY (EVECTION_CODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EVEC_APP_CREATORID_IDX on RL_EVECTION_APPLY (CREATORID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EVEC_APP_FILIALEID_IDX on RL_EVECTION_APPLY (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EVEC_APP_ISREFER_IDX on RL_EVECTION_APPLY (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_EVEC_PLAN_STATE_IDX on RL_EVECTION_APPLY (STATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_EVECTION_ROUT
prompt ===============================
prompt
create table RL_EVECTION_ROUT
(
  ROUT_ID     VARCHAR2(32) not null,
  EVECTION_ID INTEGER not null,
  ROUTING     VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EVECTION_ROUT
  add constraint PK_RL_EVECTION_ROUT primary key (ROUT_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_EVECTION_ROUT
  add constraint FK_RL_EVECT_EVEC_ROUT_RL_EVECT foreign key (EVECTION_ID)
  references RL_EVECTION_APPLY (EVECTION_ID);
create index EVEC_ROUT_FK on RL_EVECTION_ROUT (EVECTION_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_GZKXZB
prompt ========================
prompt
create table RL_GZKXZB
(
  GZKXZBID INTEGER not null,
  NF       INTEGER not null,
  YF       INTEGER not null,
  SFJZ     INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_GZKXZB
  is '工资款项主表';
comment on column RL_GZKXZB.SFJZ
  is '1=已结,0=未结';
alter table RL_GZKXZB
  add constraint PK_RL_GZKXZB primary key (GZKXZBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_GZKXZB
  add constraint AK_RL_GZKXZB_AK_RL_GZKXZ unique (NF, YF)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_GZKXZB_NF_IDX on RL_GZKXZB (NF)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_GZKXZB_SFJZ_IDX on RL_GZKXZB (SFJZ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_GZKXZB_YF_IDX on RL_GZKXZB (YF)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_GZKX
prompt ======================
prompt
create table RL_GZKX
(
  GZKXID   INTEGER not null,
  PERSONID INTEGER,
  DEPTID   INTEGER,
  GZKXZBID INTEGER not null,
  GZ000401 NUMBER(10,2),
  GZ000408 NUMBER(10,2),
  GZ000409 NUMBER(10,2),
  GZ000410 NUMBER(10,2),
  GZ000411 NUMBER(10,2),
  GZ000412 NUMBER(12,2),
  GZ000413 NUMBER(10,2),
  GZ000414 NUMBER(10,2),
  GZ000415 NUMBER(10,2),
  GZ000416 NUMBER(10,2),
  GZ000417 NUMBER(10,2),
  GZ000418 NUMBER(10,2),
  GZ000419 NUMBER(10,2),
  GZ000420 NUMBER(10,2),
  GZ000421 NUMBER(10,2),
  GZ000422 NUMBER(10,2),
  GZ000423 NUMBER(10,2),
  GZ000441 NUMBER(10,2),
  GZ000442 NUMBER(10,2),
  GZ000461 NUMBER(10,2),
  GZ000481 VARCHAR2(10),
  GZ000482 VARCHAR2(10),
  GZ000501 NUMBER(10,2)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_GZKX
  add constraint PK_RL_GZKX primary key (GZKXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_GZKX
  add constraint FK_RL_GZKX_BM_GZKX_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_GZKX
  add constraint FK_RL_GZKX_EMP_GZKX_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table RL_GZKX
  add constraint FK_RL_GZKX_RL_GZKX_RL_GZKXZ foreign key (GZKXZBID)
  references RL_GZKXZB (GZKXZBID);
create index BM_GZKX_FK on RL_GZKX (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_GZKX_FK on RL_GZKX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_GZKX_FK on RL_GZKX (GZKXZBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_GZKXSZ
prompt ========================
prompt
create table RL_GZKXSZ
(
  GZKXSZID INTEGER not null,
  MC       VARCHAR2(32) not null,
  LX       INTEGER not null,
  CD       INTEGER not null,
  JD       INTEGER,
  LY       INTEGER,
  JSGS     VARCHAR2(128),
  PXH      INTEGER,
  JSQGS    VARCHAR2(256),
  DYZDM    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column RL_GZKXSZ.LX
  is '1=字符型,2=文本型,4=数值型';
comment on column RL_GZKXSZ.JD
  is '类型为数值型的有效';
comment on column RL_GZKXSZ.LY
  is '1=直接输入,2=公式计算';
alter table RL_GZKXSZ
  add constraint PK_RL_GZKXSZ primary key (GZKXSZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_INVITE_APPLY
prompt ==============================
prompt
create table RL_INVITE_APPLY
(
  APPLY_ID    INTEGER not null,
  DEPTID      INTEGER not null,
  PERSONID    INTEGER,
  APPLY_CODE  VARCHAR2(32),
  NEED_DATE   DATE,
  JOB_KIND    VARCHAR2(32),
  AGE         INTEGER,
  EDU_LEVEL   VARCHAR2(32),
  SEX         INTEGER,
  RECRUIT_NUM INTEGER,
  GOOD_THING  VARCHAR2(256),
  MEMO        VARCHAR2(256),
  ISPLAN      INTEGER default 0,
  STATE       INTEGER,
  STATEDESC   VARCHAR2(32),
  ISREFER     INTEGER default 0,
  CREATEDATE  DATE,
  CREATORID   INTEGER,
  CREATOR     VARCHAR2(32),
  FILIALEID   INTEGER,
  APPROVEID   NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_APPLY
  add constraint PK_RL_INVITE_APPLY primary key (APPLY_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_APPLY
  add constraint FK_RL_INVIT_DEPT_APPL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_INVITE_APPLY
  add constraint FK_RL_INVIT_EMP_APPLY_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DEPT_APPLY_FK on RL_INVITE_APPLY (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_APPLY_FK on RL_INVITE_APPLY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_APP_CODE_IDX on RL_INVITE_APPLY (APPLY_CODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_APP_CREATORID_IDX on RL_INVITE_APPLY (CREATORID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_APP_FILIALEID_IDX on RL_INVITE_APPLY (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_APP_ISREFER_IDX on RL_INVITE_APPLY (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_APP_STATE_IDX on RL_INVITE_APPLY (STATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_INVITE_PLAN
prompt =============================
prompt
create table RL_INVITE_PLAN
(
  PLAN_ID    INTEGER not null,
  PERSONID   INTEGER,
  DEPTID     INTEGER not null,
  PLAN_CODE  VARCHAR2(32),
  PLAN_YEAR  INTEGER,
  PLAN_MONTH INTEGER,
  NEED_DATE  DATE,
  TOT_NUM    INTEGER,
  STATE      INTEGER,
  STATEDESC  VARCHAR2(32),
  ISREFER    INTEGER default 0,
  CREATEDATE DATE,
  CREATORID  INTEGER,
  CREATOR    VARCHAR2(32),
  FILIALEID  INTEGER,
  APPROVEID  NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_PLAN
  add constraint PK_RL_INVITE_PLAN primary key (PLAN_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_PLAN
  add constraint FK_RL_INVIT_DEPT_INPL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_INVITE_PLAN
  add constraint FK_RL_INVIT_EMP_INPLA_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DEPT_INPLAN_FK on RL_INVITE_PLAN (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_INPLAN_FK on RL_INVITE_PLAN (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_PLAN_CODE_IDX on RL_INVITE_PLAN (PLAN_CODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_PLAN_CREATORID_IDX on RL_INVITE_PLAN (CREATORID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_PLAN_FILIALEID_IDX on RL_INVITE_PLAN (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_PLAN_ISREFER_IDX on RL_INVITE_PLAN (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_INV_PLAN_STATE_IDX on RL_INVITE_PLAN (STATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_INVITE_PLAN_DETAIL
prompt ====================================
prompt
create table RL_INVITE_PLAN_DETAIL
(
  PLAN_DETAIL_ID INTEGER not null,
  PLAN_ID        INTEGER not null,
  APPLY_ID       INTEGER,
  JOB_KIND       VARCHAR2(32),
  AGE            INTEGER,
  EDU_LEVEL      VARCHAR2(32),
  SEX            INTEGER,
  RECRUIT_NUM    INTEGER,
  MEMO           VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_PLAN_DETAIL
  add constraint PK_RL_INVITE_PLAN_DETAIL primary key (PLAN_DETAIL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_INVITE_PLAN_DETAIL
  add constraint FK_RL_INVIT_APPLY_PLA_RL_INVIT foreign key (APPLY_ID)
  references RL_INVITE_APPLY (APPLY_ID);
alter table RL_INVITE_PLAN_DETAIL
  add constraint FK_RL_INVIT_INVITE_PL_RL_INVIT foreign key (PLAN_ID)
  references RL_INVITE_PLAN (PLAN_ID);
create index APPLY_PLAN_FK on RL_INVITE_PLAN_DETAIL (APPLY_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index INVITE_PLAN_FK on RL_INVITE_PLAN_DETAIL (PLAN_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YPXX
prompt ======================
prompt
create table RL_YPXX
(
  YPXXID    INTEGER not null,
  XM        VARCHAR2(32),
  YPZW      VARCHAR2(32),
  SEX       INTEGER,
  DATE_BORN DATE,
  STUDY     VARCHAR2(32),
  ADDR      VARCHAR2(64),
  PHONE     VARCHAR2(32),
  MOBILE    VARCHAR2(64),
  EMAIL     VARCHAR2(32),
  SFZHM     VARCHAR2(32),
  BZ        VARCHAR2(128),
  JG        VARCHAR2(32),
  MZ        VARCHAR2(32),
  ZC        VARCHAR2(32),
  ZZMM      VARCHAR2(32),
  SFMS      INTEGER,
  SFLY      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YPXX
  add constraint PK_RL_YPXX primary key (YPXXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_YPXX_SFLY_IDX on RL_YPXX (SFLY)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_MSXX
prompt ======================
prompt
create table RL_MSXX
(
  MSXXID INTEGER not null,
  YPXXID INTEGER,
  MSSJ   DATE,
  MSFS   VARCHAR2(32),
  MSRY   VARCHAR2(32),
  MSYJ   VARCHAR2(128),
  ZWPPXX VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_MSXX
  add constraint PK_RL_MSXX primary key (MSXXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_MSXX
  add constraint FK_RL_MSXX_YPXX_MSXX_RL_YPXX foreign key (YPXXID)
  references RL_YPXX (YPXXID);
create index YPXX_MSXX_FK on RL_MSXX (YPXXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_PXJH
prompt ======================
prompt
create table RL_PXJH
(
  PXJHID INTEGER not null,
  PXBH   VARCHAR2(16),
  JHMC   VARCHAR2(64),
  FZDW   VARCHAR2(64),
  FZBM   VARCHAR2(32),
  FZR    VARCHAR2(32),
  PXLX   VARCHAR2(32),
  PXXS   VARCHAR2(64),
  PXMB   VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_PXJH
  add constraint PK_RL_PXJH primary key (PXJHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_PXKC
prompt ======================
prompt
create table RL_PXKC
(
  PXKCID INTEGER not null,
  PXJHID INTEGER,
  KCMC   VARCHAR2(32),
  PXJS   VARCHAR2(32),
  PXJC   VARCHAR2(64),
  PXSJ   DATE,
  PXDJ   VARCHAR2(128),
  KCFY   NUMBER(20,9),
  ZXFY   NUMBER(20,9),
  QTFY   NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_PXKC
  add constraint PK_RL_PXKC primary key (PXKCID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_PXKC
  add constraint FK_RL_PXKC_PXJH_PXKC_RL_PXJH foreign key (PXJHID)
  references RL_PXJH (PXJHID);
create index PXJH_PXKC_FK on RL_PXKC (PXJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_TRAIN_BACK
prompt ============================
prompt
create table RL_TRAIN_BACK
(
  BACK_ID          INTEGER not null,
  DEPTID           INTEGER,
  PERSONID         INTEGER,
  TRAIN_PROJ       VARCHAR2(32),
  TRAIN_START      DATE,
  TRAIN_END        DATE,
  TECH_MATERIAL_OK VARCHAR2(16),
  TECHCHER_OK      VARCHAR2(16),
  ISIMPL           INTEGER,
  SUM_UP           VARCHAR2(256),
  MEMO             VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_TRAIN_BACK
  add constraint PK_RL_TRAIN_BACK primary key (BACK_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_TRAIN_BACK
  add constraint FK_RL_TRAIN_DEPT_BACK_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table RL_TRAIN_BACK
  add constraint FK_RL_TRAIN_EMP_BACK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DEPT_BACK_FK on RL_TRAIN_BACK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_BACK_FK on RL_TRAIN_BACK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YGFZXX
prompt ========================
prompt
create table RL_YGFZXX
(
  YGFZXXID INTEGER not null,
  DM       VARCHAR2(10),
  LX       INTEGER,
  MC       VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column RL_YGFZXX.LX
  is '1职务 2人员类别 3学历 4民族 5籍贯 6职称 7政治面貌';
alter table RL_YGFZXX
  add constraint PK_RL_YGFZXX primary key (YGFZXXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_YGFZX_LX_IDX on RL_YGFZXX (LX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YHXYK
prompt =======================
prompt
create table RL_YHXYK
(
  XYKID  INTEGER not null,
  XYKBH  VARCHAR2(16),
  XYKMC  VARCHAR2(32),
  XYKHCD INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_YHXYK
  is '银行信用卡';
alter table RL_YHXYK
  add constraint PK_RL_YHXYK primary key (XYKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YGXYKH
prompt ========================
prompt
create table RL_YGXYKH
(
  YGXYKHID INTEGER not null,
  PERSONID INTEGER not null,
  XYKID    INTEGER,
  YGXYKH   VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_YGXYKH
  is '员工信用卡号';
comment on column RL_YGXYKH.YGXYKH
  is '员工信用卡号';
alter table RL_YGXYKH
  add constraint PK_RL_YGXYKH primary key (YGXYKHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YGXYKH
  add constraint FK_RL_YGXYK_EMP_YGXYK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table RL_YGXYKH
  add constraint FK_RL_YGXYK_YGXYK_YGX_RL_YHXYK foreign key (XYKID)
  references RL_YHXYK (XYKID);
create index EMP_YGXYKH_FK on RL_YGXYKH (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index YGXYK_YGXYKH_FK on RL_YGXYKH (XYKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YPGZJL
prompt ========================
prompt
create table RL_YPGZJL
(
  GZJLID INTEGER not null,
  YPXXID INTEGER,
  KSSJ   DATE,
  JSSJ   DATE,
  GZDW   VARCHAR2(64),
  ZW     VARCHAR2(32),
  BZ     VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YPGZJL
  add constraint PK_RL_YPGZJL primary key (GZJLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YPGZJL
  add constraint FK_RL_YPGZJ_YPXX_GZJL_RL_YPXX foreign key (YPXXID)
  references RL_YPXX (YPXXID);
create index YPXX_GZJL_FK on RL_YPGZJL (YPXXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_YPJYQK
prompt ========================
prompt
create table RL_YPJYQK
(
  JYQKID INTEGER not null,
  YPXXID INTEGER,
  KSSJ   DATE,
  JSSJ   DATE,
  BYXX   VARCHAR2(32),
  SXZY   VARCHAR2(32),
  BZ     VARCHAR2(128),
  ZMR    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YPJYQK
  add constraint PK_RL_YPJYQK primary key (JYQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_YPJYQK
  add constraint FK_RL_YPJYQ_YPXX_JYQK_RL_YPXX foreign key (YPXXID)
  references RL_YPXX (YPXXID);
create index YPXX_JYQK_FK on RL_YPJYQK (YPXXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGBXQK
prompt ========================
prompt
create table RL_ZGBXQK
(
  BXQKID   INTEGER not null,
  PERSONID INTEGER,
  XZ       VARCHAR2(32),
  BXRQ     DATE,
  BXGS     VARCHAR2(64),
  BXE      NUMBER(20,9),
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGBXQK
  is '职工保险情况';
comment on column RL_ZGBXQK.XZ
  is '险种';
comment on column RL_ZGBXQK.BXRQ
  is '保险日期';
comment on column RL_ZGBXQK.BXGS
  is '保险公司';
comment on column RL_ZGBXQK.BXE
  is '保险额';
comment on column RL_ZGBXQK.BZ
  is '备注';
alter table RL_ZGBXQK
  add constraint PK_RL_ZGBXQK primary key (BXQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGBXQK
  add constraint FK_RL_ZGBXQ_EMP_BXQK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_BXQK_FK on RL_ZGBXQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGCJQK
prompt ========================
prompt
create table RL_ZGCJQK
(
  ZGCJQKID INTEGER not null,
  PERSONID INTEGER,
  CJRZH    VARCHAR2(32),
  AZSJ     DATE,
  GZGW     VARCHAR2(32),
  CJLB     VARCHAR2(32),
  BDR      DATE,
  BZ       VARCHAR2(128),
  FZJG     VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGCJQK
  add constraint PK_RL_ZGCJQK primary key (ZGCJQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGCJQK
  add constraint FK_RL_ZGCJQ_EMP_ZGCJQ_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_ZGCJQK_FK on RL_ZGCJQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGGZJL
prompt ========================
prompt
create table RL_ZGGZJL
(
  GZJLID   INTEGER not null,
  PERSONID INTEGER,
  KSSJ     DATE,
  JSSJ     DATE,
  GZDW     VARCHAR2(64),
  ZW       VARCHAR2(32),
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGGZJL
  is '职工工作经历';
comment on column RL_ZGGZJL.KSSJ
  is '开始时间';
comment on column RL_ZGGZJL.JSSJ
  is '结束时间';
comment on column RL_ZGGZJL.BZ
  is '备注';
alter table RL_ZGGZJL
  add constraint PK_RL_ZGGZJL primary key (GZJLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGGZJL
  add constraint FK_RL_ZGGZJ_EMP_GZJL_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_GZJL_FK on RL_ZGGZJL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGJCQK
prompt ========================
prompt
create table RL_ZGJCQK
(
  JCQKID   INTEGER not null,
  PERSONID INTEGER,
  JCJG     VARCHAR2(32),
  YY       VARCHAR2(64),
  RQ       DATE,
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGJCQK
  is '职工奖惩情况';
comment on column RL_ZGJCQK.JCJG
  is '奖惩结果';
comment on column RL_ZGJCQK.YY
  is '原因';
comment on column RL_ZGJCQK.RQ
  is '日期';
comment on column RL_ZGJCQK.BZ
  is '备注';
alter table RL_ZGJCQK
  add constraint PK_RL_ZGJCQK primary key (JCQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGJCQK
  add constraint FK_RL_ZGJCQ_EMP_JCQK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_JCQK_FK on RL_ZGJCQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGJTQK
prompt ========================
prompt
create table RL_ZGJTQK
(
  JTQKID   INTEGER not null,
  PERSONID INTEGER,
  ZY       VARCHAR2(32),
  CF       VARCHAR2(16),
  XM       VARCHAR2(32),
  CSRQ     DATE,
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGJTQK
  is '职工家庭情况';
comment on column RL_ZGJTQK.CF
  is '称呼';
comment on column RL_ZGJTQK.XM
  is '姓名';
comment on column RL_ZGJTQK.CSRQ
  is '出生日期';
comment on column RL_ZGJTQK.BZ
  is '备注';
alter table RL_ZGJTQK
  add constraint PK_RL_ZGJTQK primary key (JTQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGJTQK
  add constraint FK_RL_ZGJTQ_EMP_JTQK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_JTQK_FK on RL_ZGJTQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGJYQK
prompt ========================
prompt
create table RL_ZGJYQK
(
  JYQKID   INTEGER not null,
  PERSONID INTEGER,
  KSSJ     DATE,
  JSSJ     DATE,
  BYXX     VARCHAR2(32),
  SXZY     VARCHAR2(32),
  BZ       VARCHAR2(64),
  ZMR      VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGJYQK
  is '职工教育情况';
comment on column RL_ZGJYQK.KSSJ
  is '开始时间';
comment on column RL_ZGJYQK.JSSJ
  is '结束时间';
comment on column RL_ZGJYQK.BYXX
  is '毕业学校';
comment on column RL_ZGJYQK.SXZY
  is '所学专业';
comment on column RL_ZGJYQK.BZ
  is '备注';
comment on column RL_ZGJYQK.ZMR
  is '证明人';
alter table RL_ZGJYQK
  add constraint PK_RL_ZGJYQK primary key (JYQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGJYQK
  add constraint FK_RL_ZGJYQ_EMP_JYQK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_JYQK_FK on RL_ZGJYQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGPXQK
prompt ========================
prompt
create table RL_ZGPXQK
(
  PXQKID   INTEGER not null,
  PERSONID INTEGER,
  KSSJ     DATE,
  JSSJ     DATE,
  BZ       VARCHAR2(64),
  PXXM     VARCHAR2(32),
  ZZJG     VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGPXQK
  is '职工培训情况';
comment on column RL_ZGPXQK.KSSJ
  is '开始时间';
comment on column RL_ZGPXQK.JSSJ
  is '结束时间';
comment on column RL_ZGPXQK.BZ
  is '备注';
comment on column RL_ZGPXQK.PXXM
  is '培训项目';
comment on column RL_ZGPXQK.ZZJG
  is '组织机构';
alter table RL_ZGPXQK
  add constraint PK_RL_ZGPXQK primary key (PXQKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGPXQK
  add constraint FK_RL_ZGPXQ_EMP_PXQK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_PXQK_FK on RL_ZGPXQK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGQTXX
prompt ========================
prompt
create table RL_ZGQTXX
(
  QTXXID   INTEGER not null,
  PERSONID INTEGER,
  HTH      VARCHAR2(32),
  QDRQ     DATE,
  SYRQ     DATE,
  HTQX     DATE,
  FJH      VARCHAR2(32),
  RZRQ     DATE,
  GH       VARCHAR2(32),
  HK       VARCHAR2(32),
  ZZZ      VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGQTXX
  is '职工其他信息';
comment on column RL_ZGQTXX.HTH
  is '合同号';
comment on column RL_ZGQTXX.QDRQ
  is '签定日期';
comment on column RL_ZGQTXX.SYRQ
  is '试用日期';
comment on column RL_ZGQTXX.HTQX
  is '合同期限';
comment on column RL_ZGQTXX.FJH
  is '房间号';
comment on column RL_ZGQTXX.RZRQ
  is '入住日期';
comment on column RL_ZGQTXX.GH
  is '工会';
comment on column RL_ZGQTXX.HK
  is '户口';
comment on column RL_ZGQTXX.ZZZ
  is '暂住证';
alter table RL_ZGQTXX
  add constraint PK_RL_ZGQTXX primary key (QTXXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGQTXX
  add constraint FK_RL_ZGQTX_EMP_QTXX_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_QTXX_FK on RL_ZGQTXX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGTCAH
prompt ========================
prompt
create table RL_ZGTCAH
(
  TCAHID   INTEGER not null,
  PERSONID INTEGER,
  TCAH     VARCHAR2(32),
  DJZS     VARCHAR2(32),
  FZJG     VARCHAR2(64),
  FZRQ     DATE,
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table RL_ZGTCAH
  is '职工特长爱好';
comment on column RL_ZGTCAH.TCAH
  is '特长(爱好)';
comment on column RL_ZGTCAH.DJZS
  is '等级(证书)';
comment on column RL_ZGTCAH.FZJG
  is '发证机构';
comment on column RL_ZGTCAH.FZRQ
  is '发证日期';
comment on column RL_ZGTCAH.BZ
  is '备注';
alter table RL_ZGTCAH
  add constraint PK_RL_ZGTCAH primary key (TCAHID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGTCAH
  add constraint FK_RL_ZGTCA_EMP_TCAH_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index EMP_TCAH_FK on RL_ZGTCAH (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGXXBD
prompt ========================
prompt
create table RL_ZGXXBD
(
  ZGXXID  INTEGER not null,
  BDRQ    DATE,
  CZRQ    DATE,
  BDLX    INTEGER,
  CZYID   INTEGER,
  FGSID   INTEGER,
  CZY     VARCHAR2(16),
  BDYY    VARCHAR2(64),
  SPRID   INTEGER,
  ZT      INTEGER,
  ZTMS    VARCHAR2(32),
  ISREFER INTEGER,
  DEPTID  INTEGER,
  LSH     VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column RL_ZGXXBD.BDLX
  is '1=职工离职,2=部门调动,3=类别变动,4=职务变迁';
alter table RL_ZGXXBD
  add constraint PK_RL_ZGXXBD primary key (ZGXXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGXXBD
  add constraint FK_RL_ZGXXB_BM_RL_ZGX_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_RL_ZGXXBD_FK on RL_ZGXXBD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_ZGXXBD_CYZID_IDX on RL_ZGXXBD (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_ZGXXBD_FGSID_IDX on RL_ZGXXBD (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_ZGXXBD_ISREFER_IDX on RL_ZGXXBD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RL_ZGXXBD_ZT_IDX on RL_ZGXXBD (ZT)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZGXXBDMX
prompt ==========================
prompt
create table RL_ZGXXBDMX
(
  XXBDMXID INTEGER not null,
  ZGXXID   INTEGER,
  PERSONID INTEGER,
  BDQID    VARCHAR2(32),
  BDHID    VARCHAR2(32),
  BZ       VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGXXBDMX
  add constraint PK_RL_ZGXXBDMX primary key (XXBDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZGXXBDMX
  add constraint FK_RL_ZGXXB_EMP_ZGXXB_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table RL_ZGXXBDMX
  add constraint FK_RL_ZGXXB_GZXXBD_MX_RL_ZGXXB foreign key (ZGXXID)
  references RL_ZGXXBD (ZGXXID);
create index EMP_ZGXXBDMX_FK on RL_ZGXXBDMX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZXXBD_MX_FK on RL_ZGXXBDMX (ZGXXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RL_ZPJH
prompt ======================
prompt
create table RL_ZPJH
(
  DEPTID INTEGER not null,
  ZPNF   INTEGER not null,
  JAN    INTEGER,
  FEB    INTEGER,
  MAR    INTEGER,
  APR    INTEGER,
  MAY    INTEGER,
  JUN    INTEGER,
  JUL    INTEGER,
  AUG    INTEGER,
  SEP    INTEGER,
  OCT    INTEGER,
  NOV    INTEGER,
  DEC    INTEGER,
  BWZP   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZPJH
  add constraint PK_RL_ZPJH primary key (DEPTID, ZPNF)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table RL_ZPJH
  add constraint FK_RL_ZPJH_BM_ZPJH_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_ZPJH_FK on RL_ZPJH (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ROLELIMIT
prompt ========================
prompt
create table ROLELIMIT
(
  ROLELIMITID INTEGER not null,
  LIMITID     INTEGER,
  ROLEID      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table ROLELIMIT
  is '该表保存某一角色相对应的权限的记录信息。';
alter table ROLELIMIT
  add constraint PK_ROLELIMIT primary key (ROLELIMITID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ROLELIMIT
  add constraint FK_ROLELIMI_RELATIONS_ROLEINFO foreign key (ROLEID)
  references ROLEINFO (ROLEID);
create index RELATIONSHIP_6_FK on ROLELIMIT (ROLEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ROLE_ALL_FK on ROLELIMIT (LIMITID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SB_EQUIPSTATE
prompt ============================
prompt
create table SB_EQUIPSTATE
(
  STATEID   INTEGER not null,
  STATECODE VARCHAR2(32),
  STATENAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SB_EQUIPSTATE
  add constraint PK_SB_EQUIPSTATE primary key (STATEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SB_EQUIPTYPE
prompt ===========================
prompt
create table SB_EQUIPTYPE
(
  TYPEID   INTEGER not null,
  TYPECODE VARCHAR2(32),
  TYPENAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SB_EQUIPTYPE
  add constraint PK_SB_EQUIPTYPE primary key (TYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SB_EXCEPTIONREASON
prompt =================================
prompt
create table SB_EXCEPTIONREASON
(
  EXCEPREASONID   INTEGER not null,
  EXCEPREASONCODE VARCHAR2(32),
  EXCEPREASONNAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SB_EXCEPTIONREASON
  add constraint PK_SB_EXCEPTIONREASON primary key (EXCEPREASONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SB_EXCEPTIONTYPE
prompt ===============================
prompt
create table SB_EXCEPTIONTYPE
(
  EXCEPTYPEID   INTEGER not null,
  EXCEPTYPECODE VARCHAR2(32),
  EXCEPTYPENAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SB_EXCEPTIONTYPE
  add constraint PK_SB_EXCEPTIONTYPE primary key (EXCEPTYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SB_MACHINE_TOOL_RECORD
prompt =====================================
prompt
create table SB_MACHINE_TOOL_RECORD
(
  MID            NUMBER(9) not null,
  CODE           VARCHAR2(32),
  DEPTID         NUMBER(6),
  DWTXID         NUMBER(6),
  PERSONID       NUMBER(6),
  TOOL_TYPE      VARCHAR2(64),
  SDATE          DATE,
  PRODUCE_NUMBER VARCHAR2(64),
  BUY_DATE       DATE,
  PLATE_SPEC     VARCHAR2(64),
  MODE_LOCKING   VARCHAR2(64),
  SULFURATION    NUMBER(1),
  MACHINE_NO     VARCHAR2(64),
  KEY_MACHINE    NUMBER(1),
  REMARK         VARCHAR2(200)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on table SB_MACHINE_TOOL_RECORD
  is '机床';
comment on column SB_MACHINE_TOOL_RECORD.CODE
  is '机床编号';
alter table SB_MACHINE_TOOL_RECORD
  add constraint PK_SB_MACHINE_TOOL_RECORD primary key (MID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table SB_MACHINE_TOOL_RECORD
  add constraint FK_SB_MACHI_REFERENCE_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SB_MACHINE_TOOL_RECORD
  add constraint FK_SB_MACHI_REFERENCE_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SB_MACHINE_TOOL_RECORD
  add constraint FK_SB_MACHI_REFERENCE_EMP foreign key (PERSONID)
  references EMP (PERSONID);

prompt
prompt Creating table SB_MAINTAINTYPE
prompt ==============================
prompt
create table SB_MAINTAINTYPE
(
  MAINTYPEID   INTEGER not null,
  MAINTYPECODE VARCHAR2(32),
  MAINTYPENAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SB_MAINTAINTYPE
  add constraint PK_SB_MAINTAINTYPE primary key (MAINTYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_BMGZL
prompt =======================
prompt
create table SC_BMGZL
(
  BMGZLID INTEGER not null,
  DEPTID  INTEGER,
  DJH     VARCHAR2(32),
  RQ      DATE,
  ZDRQ    DATE,
  ZDRID   INTEGER,
  ZDR     VARCHAR2(32),
  FGSID   INTEGER,
  ZT      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BMGZL
  add constraint PK_SC_BMGZL primary key (BMGZLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BMGZL
  add constraint FK_SC_BMGZL_BM_BMGZL_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_BMGZL_FK on SC_BMGZL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_BMGZL_RQ_IDX on SC_BMGZL (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_BMGZL_ZDR_IDX on SC_BMGZL (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_BMGZLMX
prompt =========================
prompt
create table SC_BMGZLMX
(
  BMGZLMXID INTEGER not null,
  GYLXID    INTEGER,
  PERSONID  INTEGER,
  CPID      INTEGER,
  BMGZLID   INTEGER,
  JGDMXID   INTEGER,
  GX        VARCHAR2(32),
  SL        NUMBER(16,6),
  DESL      NUMBER(16,6),
  JJDJ      NUMBER(20,9),
  JJGS      NUMBER(16,6),
  JJGZ      NUMBER(20,9),
  DMSXID    INTEGER,
  HSSL      NUMBER(16,6),
  SCSL      NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_BMGZLMX.GX
  is 'sc_gylxmx.工序(选择框).根据sc_gzzry.工序id来指定默认的工序';
comment on column SC_BMGZLMX.SL
  is '数量';
comment on column SC_BMGZLMX.DESL
  is '定额数量';
comment on column SC_BMGZLMX.JJDJ
  is 'sc_gylxmx.定额金额(只读)';
comment on column SC_BMGZLMX.JJGS
  is '计件工时';
comment on column SC_BMGZLMX.JJGZ
  is '显示未金额';
alter table SC_BMGZLMX
  add constraint PK_SC_BMGZLMX primary key (BMGZLMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_DMSX_BMGZ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_EMP_BMGZL_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_GYLX_BMGZ_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID)
  disable;
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_JGDMX_BMG_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_KCDM_BMGZ_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
alter table SC_BMGZLMX
  add constraint FK_SC_BMGZL_SC_BMGZL__SC_BMGZL foreign key (BMGZLID)
  references SC_BMGZL (BMGZLID);
create index DMSX_BMGZLMX_FK on SC_BMGZLMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_BMGZLMX_FK on SC_BMGZLMX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_BMGZLMX_FK on SC_BMGZLMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_BMGZLMX_FK on SC_BMGZLMX (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_BMGZLMX_FK on SC_BMGZLMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_BMGZL_MX_FK on SC_BMGZLMX (BMGZLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_BOM
prompt =====================
prompt
create table SC_BOM
(
  BOMID  INTEGER not null,
  CPID   INTEGER not null,
  SJCPID INTEGER not null,
  SL     NUMBER(15,6),
  SHL    NUMBER(10,6),
  ZJLX   INTEGER not null,
  XGR    VARCHAR2(32),
  WGCL   INTEGER default 1 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_BOM
  is 'BOM表';
comment on column SC_BOM.SJCPID
  is '上级物资ID';
comment on column SC_BOM.SL
  is '数量';
comment on column SC_BOM.SHL
  is '损耗率';
comment on column SC_BOM.ZJLX
  is '子件类型:1=普通件,2=可选件,3=通用件';
alter table SC_BOM
  add constraint PK_SC_BOM primary key (BOMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOM
  add constraint AK_SC_BOM_AK_SC_BOM unique (SJCPID, CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOM
  add constraint FK_SC_BOM_SJWZID_KC_DM foreign key (SJCPID)
  references KC_DM (CPID)
  disable;
alter table SC_BOM
  add constraint FK_SC_BOM_WZDM_BOM_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
create index SC_BOM_ZJLX_IDX on SC_BOM (ZJLX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SJWZID_BOM_FK on SC_BOM (SJCPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_BOM_FK on SC_BOM (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GXFD
prompt ======================
prompt
create table SC_GXFD
(
  GXFDID INTEGER not null,
  GDBH   VARCHAR2(16),
  GDMC   VARCHAR2(32),
  GDMS   VARCHAR2(64),
  DEPTID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GXFD
  is '工序分段';
comment on column SC_GXFD.GDBH
  is '工段编号,排序';
comment on column SC_GXFD.GDMC
  is '工段名称';
comment on column SC_GXFD.GDMS
  is '工段描述';
alter table SC_GXFD
  add constraint PK_SC_GXFD primary key (GXFDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GXFD
  add constraint FK_SC_GXFD_DEPT_GXFD_BM foreign key (DEPTID)
  references BM (DEPTID);
create index DEPT_GXFD_FK on SC_GXFD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_BOMSECTION
prompt ============================
prompt
create table SC_BOMSECTION
(
  GXFDID INTEGER not null,
  BOMID  INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOMSECTION
  add constraint PK_SC_BOMSECTION primary key (GXFDID, BOMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOMSECTION
  add constraint FK_SC_BOMSE_SC_BOMSEC_SC_BOM foreign key (BOMID)
  references SC_BOM (BOMID);
alter table SC_BOMSECTION
  add constraint FK_SC_BOMSE_SC_BOMSEC_SC_GXFD foreign key (GXFDID)
  references SC_GXFD (GXFDID);
create index SC_BOMSECTION2_FK on SC_BOMSECTION (BOMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_BOMSECTION_FK on SC_BOMSECTION (GXFDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_BOMTHJ
prompt ========================
prompt
create table SC_BOMTHJ
(
  CPID     INTEGER not null,
  KC__CPID INTEGER not null,
  SL       NUMBER(16,6),
  SHL      NUMBER(10,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOMTHJ
  add constraint PK_SC_BOMTHJ primary key (CPID, KC__CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_BOMTHJ
  add constraint FK_SC_BOMTH_SRCWZDM_B_KC_DM foreign key (KC__CPID)
  references KC_DM (CPID);
alter table SC_BOMTHJ
  add constraint FK_SC_BOMTH_WZDM_BOMT_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index SRCWZDM_BOMTHJ_FK on SC_BOMTHJ (KC__CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_BOMTHJ_FK on SC_BOMTHJ (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZ
prompt =====================
prompt
create table SC_GZZ
(
  GZZID  INTEGER not null,
  DEPTID INTEGER,
  GZZBH  VARCHAR2(32),
  GZZMC  VARCHAR2(32),
  GZZMS  VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_GZZ.GZZBH
  is '工作组编号';
comment on column SC_GZZ.GZZMC
  is '工作组名称';
comment on column SC_GZZ.GZZMS
  is '工作组描述';
alter table SC_GZZ
  add constraint PK_SC_GZZ primary key (GZZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZ
  add constraint FK_SC_GZZ_BM_GZZ_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_GZZ_FK on SC_GZZ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_DRAWMATERIAL
prompt ==============================
prompt
create table SC_DRAWMATERIAL
(
  DRAWID       INTEGER not null,
  STOREID      INTEGER not null,
  DEPTID       INTEGER,
  YTID         INTEGER,
  SFDJLBID     INTEGER,
  DRAWCODE     VARCHAR2(32),
  DRAWDATE     DATE,
  DRAWTYPE     INTEGER not null,
  MEMO         VARCHAR2(128),
  HANDLEPERSON VARCHAR2(32),
  TOTALNUM     NUMBER(16,6),
  TOTALSUM     NUMBER(20,9),
  STATE        INTEGER,
  STATEDESC    VARCHAR2(32),
  CREATEDATE   DATE,
  CREATORID    INTEGER,
  CREATOR      VARCHAR2(32),
  FILIALEID    INTEGER,
  APPROVEID    INTEGER,
  NETNUM       NUMBER(16,6),
  DYNESIDE     VARCHAR2(32),
  HOTSIDE      VARCHAR2(32),
  CHECKOR      VARCHAR2(32),
  CHECKRESULT  VARCHAR2(64),
  ISREFER      INTEGER,
  DWTXID       INTEGER,
  ISOUT        INTEGER default 0,
  ZGF          NUMBER(20,9),
  GZZID        INTEGER,
  BC           VARCHAR2(32),
  SC__GZZID    INTEGER,
  ZGF2         NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_DRAWMATERIAL
  add constraint PK_SC_DRAWMATERIAL primary key (DRAWID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_DRAWMATERIAL
  add constraint FK_SC_DRAWM_DWTX_DRAW_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_DRAWMATERIAL
  add constraint FK_SC_DRAWM_GZZ2_DRAW_SC_GZZ foreign key (SC__GZZID)
  references SC_GZZ (GZZID);
alter table SC_DRAWMATERIAL
  add constraint FK_SC_DRAWM_GZZ_DRAW_SC_GZZ foreign key (GZZID)
  references SC_GZZ (GZZID);
create index CSDJYT_DRAW_FK on SC_DRAWMATERIAL (YTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DEPT_DRAWMATERIAL_FK on SC_DRAWMATERIAL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_DRAW_FK on SC_DRAWMATERIAL (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ2_DRAW_FK on SC_DRAWMATERIAL (SC__GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ_DRAW_FK on SC_DRAWMATERIAL (GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALCODE_IDX on SC_DRAWMATERIAL (DRAWCODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALCREATOR_IDX on SC_DRAWMATERIAL (CREATOR)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALDATE_IDX on SC_DRAWMATERIAL (DRAWDATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALFILIALEID_IDX on SC_DRAWMATERIAL (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALISREFER_IDX on SC_DRAWMATERIAL (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_DRAWMATERIALTYPE_IDX on SC_DRAWMATERIAL (DRAWTYPE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index STORE_DRAW_FK on SC_DRAWMATERIAL (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_DRAW_FK on SC_DRAWMATERIAL (SFDJLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JGDWL
prompt =======================
prompt
create table SC_JGDWL
(
  JGDWLID INTEGER not null,
  JGDMXID INTEGER,
  DMSXID  INTEGER,
  CPID    INTEGER,
  JGDID   INTEGER not null,
  SL      NUMBER(16,6),
  SCSL    NUMBER(16,6),
  YLSL    NUMBER(16,6),
  YLSCSL  NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGDWL
  add constraint PK_SC_JGDWL primary key (JGDWLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGDWL
  add constraint FK_SC_JGDWL_DMSX_JGDW_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_JGDWL
  add constraint FK_SC_JGDWL_JGDMX_WL_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
alter table SC_JGDWL
  add constraint FK_SC_JGDWL_JGD_WL_SC_JGD foreign key (JGDID)
  references SC_JGD (JGDID);
alter table SC_JGDWL
  add constraint FK_SC_JGDWL_WZDM_JGDW_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DMSX_JGDWL_FK on SC_JGDWL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_WL_FK on SC_JGDWL (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGD_WL_FK on SC_JGDWL (JGDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_JGDWL_FK on SC_JGDWL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_DRAWMATERIALDETAIL
prompt ====================================
prompt
create table SC_DRAWMATERIALDETAIL
(
  DRAWDETAILID INTEGER not null,
  CPID         INTEGER not null,
  DMSXID       INTEGER,
  DRAWID       INTEGER not null,
  WZMXID       INTEGER,
  KWID         INTEGER,
  DRAWTYPE     INTEGER not null,
  BACKDRAWID   INTEGER,
  BATCHNO      VARCHAR2(32),
  DRAWBIGNUM   NUMBER(16,6),
  DRAWNUM      NUMBER(16,6),
  PRODUCENUM   NUMBER(16,6),
  DRAWPRICE    NUMBER(20,9),
  DRAWSUM      NUMBER(20,9),
  MEMO         VARCHAR2(64),
  JGDMXID      INTEGER,
  JGDWLID      INTEGER,
  GX           VARCHAR2(32),
  JJFF         INTEGER,
  JJDJ         NUMBER(20,9),
  JJGZ         NUMBER(20,9),
  GYLXID       INTEGER,
  GX2          VARCHAR2(32),
  JJFF2        INTEGER,
  JJGZ2        NUMBER(20,9),
  JJDJ2        NUMBER(20,9)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_DRAWMATERIALDETAIL
  add constraint PK_SC_DRAWMATERIALDETAIL primary key (DRAWDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_DRAWMATERIALDETAIL
  add constraint FK_SC_DRAWM_DRAWDETAI_SC_DRAWM foreign key (BACKDRAWID)
  references SC_DRAWMATERIALDETAIL (DRAWDETAILID);
alter table SC_DRAWMATERIALDETAIL
  add constraint FK_SC_DRAWM_GYLX_DRAW_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_DRAWMATERIALDETAIL
  add constraint FK_SC_DRAWM_JGDWL_DRA_SC_JGDWL foreign key (JGDWLID)
  references SC_JGDWL (JGDWLID);
alter table SC_DRAWMATERIALDETAIL
  add constraint FK_SC_DRAWM_PROCESS_D_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
create index DMSX_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DRAWDETAIL_BACK_FK on SC_DRAWMATERIALDETAIL (BACKDRAWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DRAWMATERIAL_DETAIL_FK on SC_DRAWMATERIALDETAIL (DRAWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDWL_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (JGDWLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KW_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (KWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PROCESS_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZMX_DRAWDETAIL_FK on SC_DRAWMATERIALDETAIL (WZMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_FQJHMX
prompt ========================
prompt
create table SC_FQJHMX
(
  SCFQJHMXID INTEGER not null,
  CPID       INTEGER not null,
  SCJHID     INTEGER not null,
  DMSXID     INTEGER,
  GYLXID     INTEGER,
  HTHWID     INTEGER,
  SL         NUMBER(16,6),
  SCSL       NUMBER(16,6),
  FDXS       INTEGER,
  JGYQ       VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_FQJHMX
  add constraint PK_SC_FQJHMX primary key (SCFQJHMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_FQJHMX
  add constraint FK_SC_FQJHM_DMSX_FQJH_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_FQJHMX
  add constraint FK_SC_FQJHM_GYLX_FQJH_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_FQJHMX
  add constraint FK_SC_FQJHM_HTHW_FQJH_XS_HTHW foreign key (HTHWID)
  references XS_HTHW (HTHWID);
alter table SC_FQJHMX
  add constraint FK_SC_FQJHM_KCDM_FQJH_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_FQJHMX
  add constraint FK_SC_FQJHM_SCJH_FQJH_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
create index DMSX_FQJHMX_FK on SC_FQJHMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_FQJHMX_FK on SC_FQJHMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HTHW_FQJHMX_FK on SC_FQJHMX (HTHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_FQJHMX_FK on SC_FQJHMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_FQJHMX_FK on SC_FQJHMX (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_FQJHWL
prompt ========================
prompt
create table SC_FQJHWL
(
  SCFQJHWLID INTEGER not null,
  CPID       INTEGER not null,
  SCJHID     INTEGER not null,
  DMSXID     INTEGER,
  SL         NUMBER(16,6),
  SCSL       NUMBER(16,6),
  FDXH       INTEGER,
  SFJS       INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_FQJHWL
  add constraint PK_SC_FQJHWL primary key (SCFQJHWLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_FQJHWL
  add constraint FK_SC_FQJHW_DMSX_FQWL_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_FQJHWL
  add constraint FK_SC_FQJHW_KCDM_FQWL_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_FQJHWL
  add constraint FK_SC_FQJHW_SCJH_FQWL_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
create index DMSX_FQWL_FK on SC_FQJHWL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_FQWL_FK on SC_FQJHWL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_FQWL_FK on SC_FQJHWL (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_FQJHWLBOM
prompt ===========================
prompt
create table SC_FQJHWLBOM
(
  SCJHID INTEGER not null,
  CPID   INTEGER,
  DMSXID INTEGER,
  SL     NUMBER(16,6),
  SCSL   NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_FQJHWLBOM
  add constraint FK_SC_FQJHW_SCJH_WLBO_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID);
create index SCJH_WLBOM_FK on SC_FQJHWLBOM (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_RECEIVEPROD
prompt =============================
prompt
create table SC_RECEIVEPROD
(
  RECEIVEID    INTEGER not null,
  STOREID      INTEGER not null,
  SFDJLBID     INTEGER,
  DEPTID       INTEGER,
  RECEIVECODE  VARCHAR2(32),
  RECEIVEDATE  DATE,
  MEMO         VARCHAR2(128),
  HANDLEPERSON VARCHAR2(32),
  TOTALNUM     NUMBER(16,6),
  TOTALSUM     NUMBER(20,9),
  STATE        INTEGER,
  STATEDESC    VARCHAR2(32),
  CREATEDATE   DATE,
  CREATORID    INTEGER,
  CREATOR      VARCHAR2(32),
  FILIALEID    INTEGER,
  APPROVEID    INTEGER,
  YTID         INTEGER,
  ISREFER      INTEGER,
  DWTXID       INTEGER,
  ISOUT        INTEGER default 0,
  ZLYZ         VARCHAR2(64),
  ZGF          NUMBER(20,9),
  YDZS         VARCHAR2(64),
  DZCS         VARCHAR2(64),
  JHSH         NUMBER(16,6),
  SJSH         NUMBER(16,6),
  JF           NUMBER(16,6),
  SHYY         VARCHAR2(64),
  JT           VARCHAR2(32),
  BC           VARCHAR2(32),
  GZZID        INTEGER,
  ZGF3         NUMBER(20,9),
  SC__GZZID    INTEGER,
  SC__GZZID2   INTEGER,
  ZGF2         NUMBER(20,9),
  TOTALBIGNUM  NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RECEIVEPROD
  add constraint PK_SC_RECEIVEPROD primary key (RECEIVEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RECEIVEPROD
  add constraint FK_SC_RECEI_DWTX_RECE_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_RECEIVEPROD
  add constraint FK_SC_RECEI_GZZ2_RECE_SC_GZZ foreign key (SC__GZZID)
  references SC_GZZ (GZZID);
alter table SC_RECEIVEPROD
  add constraint FK_SC_RECEI_GZZ3_RECE_SC_GZZ foreign key (SC__GZZID2)
  references SC_GZZ (GZZID);
alter table SC_RECEIVEPROD
  add constraint FK_SC_RECEI_GZZ_RECEI_SC_GZZ foreign key (GZZID)
  references SC_GZZ (GZZID);
alter table SC_RECEIVEPROD
  add constraint FK_SC_RECEI_SCYT_ZZSH_KC_CSDJY foreign key (YTID)
  references KC_CSDJYT (YTID);
create index DEPT_RECEIVEPROD_FK on SC_RECEIVEPROD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_RECEIVE_FK on SC_RECEIVEPROD (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ2_RECEIVEPROD_FK on SC_RECEIVEPROD (SC__GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ3_RECEIVEPROD_FK on SC_RECEIVEPROD (SC__GZZID2)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ_RECEIVEPROD_FK on SC_RECEIVEPROD (GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCYT_ZZSH_FK on SC_RECEIVEPROD (YTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_RECEIVEPRODCODE_IDX on SC_RECEIVEPROD (RECEIVECODE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_RECEIVEPRODCREATOR_IDX on SC_RECEIVEPROD (CREATOR)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_RECEIVEPRODDATE_IDX on SC_RECEIVEPROD (RECEIVEDATE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_RECEIVEPRODFILIALE_IDX on SC_RECEIVEPROD (FILIALEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_RECEIVEPROD_ISREFER_IDX on SC_RECEIVEPROD (ISREFER)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index STORE_RECEIVE_FK on SC_RECEIVEPROD (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TYPE_RECEIVE_FK on SC_RECEIVEPROD (SFDJLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GRGZ
prompt ======================
prompt
create table SC_GRGZ
(
  GRGZID    INTEGER not null,
  GZZID     INTEGER,
  RECEIVEID INTEGER,
  DRAWID    INTEGER,
  DEPTID    INTEGER,
  ZGF       NUMBER(20,9),
  DJRQ      DATE,
  DJH       VARCHAR2(32),
  BC        VARCHAR2(32),
  JSR       VARCHAR2(32),
  ZTBJ      INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZ
  add constraint PK_SC_GRGZ primary key (GRGZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZ
  add constraint FK_SC_GRGZ_BM_GRGZ_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_GRGZ
  add constraint FK_SC_GRGZ_DRAW_GRGZ_SC_DRAWM foreign key (DRAWID)
  references SC_DRAWMATERIAL (DRAWID)
  disable;
alter table SC_GRGZ
  add constraint FK_SC_GRGZ_GZZ_GRGZ_SC_GZZ foreign key (GZZID)
  references SC_GZZ (GZZID);
alter table SC_GRGZ
  add constraint FK_SC_GRGZ_RECEIVE_G_SC_RECEI foreign key (RECEIVEID)
  references SC_RECEIVEPROD (RECEIVEID)
  disable;
create index BM_GRGZ_FK on SC_GRGZ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DRAW_GRGZ_FK on SC_GRGZ (DRAWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ_GRGZ_FK on SC_GRGZ (GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RECEIVE_GRGZ_FK on SC_GRGZ (RECEIVEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GRGZ_ZTBJ_IDX on SC_GRGZ (ZTBJ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GRGZGS
prompt ========================
prompt
create table SC_GRGZGS
(
  GSBM VARCHAR2(16) not null,
  GSZ  VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZGS
  add constraint PK_SC_GRGZGS primary key (GSBM)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GRGZL
prompt =======================
prompt
create table SC_GRGZL
(
  GZLID    INTEGER not null,
  DEPTID   INTEGER,
  PERSONID INTEGER,
  RQ       DATE,
  CQ       NUMBER(10,6),
  RB       NUMBER(10,6),
  YB       NUMBER(10,6),
  QJ       NUMBER(10,6),
  JE       NUMBER(20,9),
  FGSID    INTEGER,
  ZJJGZ    NUMBER(20,9),
  ZDRQ     DATE,
  ZDRID    INTEGER,
  ZDR      VARCHAR2(32),
  LX       INTEGER,
  ZT       INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GRGZL
  is '工人工作量';
alter table SC_GRGZL
  add constraint PK_SC_GRGZL primary key (GZLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZL
  add constraint FK_SC_GRGZL_BM_GRGZL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_GRGZL
  add constraint FK_SC_GRGZL_EMP_GRGZL_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index BM_GRGZL_FK on SC_GRGZL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_GRGZL_FK on SC_GRGZL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GRGZL_FGSID_IDX on SC_GRGZL (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GRGZL_LX_IDX on SC_GRGZL (LX)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GRGZL_ZDRID_IDX on SC_GRGZL (ZDRID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_REGZL_RQ_IDX on SC_GRGZL (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GRGZLMX
prompt =========================
prompt
create table SC_GRGZLMX
(
  GZLMXID INTEGER not null,
  GZLID   INTEGER,
  JGDMXID INTEGER,
  GYLXID  INTEGER,
  CPID    INTEGER,
  GX      VARCHAR2(32),
  SL      NUMBER(16,6),
  DE      NUMBER(20,9),
  JJGS    NUMBER(16,6),
  JJGZ    NUMBER(20,9),
  DESL    NUMBER(16,6),
  DMSXID  INTEGER,
  HSSL    NUMBER(16,6),
  SCSL    NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GRGZLMX
  is '工人工作量明细';
comment on column SC_GRGZLMX.GX
  is '引用工艺路线明细的工序';
alter table SC_GRGZLMX
  add constraint PK_SC_GRGZLMX primary key (GZLMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZLMX
  add constraint FK_SC_GRGZL_DMSX_GRGZ_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_GRGZLMX
  add constraint FK_SC_GRGZL_GRGZL_MX_SC_GRGZL foreign key (GZLID)
  references SC_GRGZL (GZLID);
alter table SC_GRGZLMX
  add constraint FK_SC_GRGZL_GYLX_GRGZ_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_GRGZLMX
  add constraint FK_SC_GRGZL_JGDMX_GRG_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
alter table SC_GRGZLMX
  add constraint FK_SC_GRGZL_KCDM_GRGZ_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
create index DMSX_GRGZLMX_FK on SC_GRGZLMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GRGZL_MX_FK on SC_GRGZLMX (GZLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_GRGZLMX_FK on SC_GRGZLMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_GRGZLMX_FK on SC_GRGZLMX (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_GRGZLMX_FK on SC_GRGZLMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GRGZRY
prompt ========================
prompt
create table SC_GRGZRY
(
  GRGZRYID INTEGER not null,
  PERSONID INTEGER,
  GRGZID   INTEGER not null,
  JJGZ     NUMBER(20,9),
  BL       NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZRY
  add constraint PK_SC_GRGZRY primary key (GRGZRYID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GRGZRY
  add constraint FK_SC_GRGZR_EMP_GRGZR_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SC_GRGZRY
  add constraint FK_SC_GRGZR_GRGZ_RY_SC_GRGZ foreign key (GRGZID)
  references SC_GRGZ (GRGZID);
create index EMP_GRGZRY_FK on SC_GRGZRY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GRGZ_RY_FK on SC_GRGZRY (GRGZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GYMC
prompt ======================
prompt
create table SC_GYMC
(
  GYMCID INTEGER not null,
  GYBH   VARCHAR2(16),
  GYMC   VARCHAR2(32),
  GYMS   VARCHAR2(64),
  GXFDID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_GYMC.GYBH
  is '工艺编号';
comment on column SC_GYMC.GYMC
  is '工艺名称';
comment on column SC_GYMC.GYMS
  is '工艺描述';
alter table SC_GYMC
  add constraint PK_SC_GYMC primary key (GYMCID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GYMC
  add constraint FK_SC_GYMC_GXFD_GXMC_SC_GXFD foreign key (GXFDID)
  references SC_GXFD (GXFDID);
create index GXFD_GXMC_FK on SC_GYMC (GXFDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZX
prompt ======================
prompt
create table SC_GZZX
(
  GZZXID   INTEGER not null,
  DEPTID   INTEGER,
  GZZXBH   VARCHAR2(16),
  GZZXMC   VARCHAR2(32),
  SBS      INTEGER,
  RGS      INTEGER,
  LYL      NUMBER(9,6),
  SFGJGZZX INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_GZZX.GZZXBH
  is '工作中心编号,排序';
comment on column SC_GZZX.GZZXMC
  is '工作中心名称';
comment on column SC_GZZX.SBS
  is '设备数';
comment on column SC_GZZX.RGS
  is '人工数';
comment on column SC_GZZX.LYL
  is '利用率';
comment on column SC_GZZX.SFGJGZZX
  is '是否关键工作中心';
alter table SC_GZZX
  add constraint PK_SC_GZZX primary key (GZZXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZX
  add constraint FK_SC_GZZX_BM_GZZX_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_GZZX_FK on SC_GZZX (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GYLXMX
prompt ========================
prompt
create table SC_GYLXMX
(
  GYLXMXID INTEGER not null,
  GXFDID   INTEGER,
  GZZXID   INTEGER,
  GYLXID   INTEGER,
  DESL     NUMBER(15,6),
  DEJE     NUMBER(20,9),
  LBJJ     NUMBER(20,9),
  HSJ      NUMBER(20,9),
  GDJG     NUMBER(20,9),
  SCGS     NUMBER(15,6),
  DDGS     NUMBER(15,6),
  SFWX     INTEGER,
  WXJG     NUMBER(20,9),
  BZ       VARCHAR2(64),
  GYMCID   INTEGER,
  JJFF     INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GYLXMX
  is '工艺路线明细';
comment on column SC_GYLXMX.DESL
  is '定额数量';
comment on column SC_GYLXMX.DEJE
  is '定额金额';
comment on column SC_GYLXMX.LBJJ
  is '零部件价';
comment on column SC_GYLXMX.HSJ
  is '回收价';
comment on column SC_GYLXMX.GDJG
  is '工段价格';
comment on column SC_GYLXMX.SCGS
  is '生产工时';
comment on column SC_GYLXMX.DDGS
  is '等待工时';
comment on column SC_GYLXMX.SFWX
  is '是否外协';
comment on column SC_GYLXMX.WXJG
  is '外协价格';
comment on column SC_GYLXMX.BZ
  is '备注';
alter table SC_GYLXMX
  add constraint PK_SC_GYLXMX primary key (GYLXMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GYLXMX
  add constraint FK_SC_GYLXM_GXFD_GYLX_SC_GXFD foreign key (GXFDID)
  references SC_GXFD (GXFDID)
  disable;
alter table SC_GYLXMX
  add constraint FK_SC_GYLXM_GYLX_MX_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID)
  disable;
alter table SC_GYLXMX
  add constraint FK_SC_GYLXM_GYMC_GYLX_SC_GYMC foreign key (GYMCID)
  references SC_GYMC (GYMCID);
alter table SC_GYLXMX
  add constraint FK_SC_GYLXM_GZZX_GYLX_SC_GZZX foreign key (GZZXID)
  references SC_GZZX (GZZXID);
create index GXFD_GYLXMX_FK on SC_GYLXMX (GXFDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_MX_FK on SC_GYLXMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYMC_GYLX_FK on SC_GYLXMX (GYMCID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZX_GYLXMX_FK on SC_GYLXMX (GZZXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZGZL
prompt ========================
prompt
create table SC_GZZGZL
(
  GZZGZLID INTEGER not null,
  DEPTID   INTEGER,
  GZZID    INTEGER not null,
  JGDID    INTEGER,
  DJH      VARCHAR2(32),
  RQ       DATE,
  JDR      VARCHAR2(32),
  SL       NUMBER(16,6),
  ZGF      NUMBER(20,9),
  ZT       INTEGER,
  ZDRQ     DATE,
  ZDRID    INTEGER,
  ZDR      VARCHAR2(32),
  FGSID    INTEGER,
  ZLYZ     VARCHAR2(64),
  YDZS     VARCHAR2(16),
  DZCS     VARCHAR2(16),
  JHSH     NUMBER(16,6),
  SJSH     NUMBER(16,6),
  JF       NUMBER(16,6),
  SHYY     VARCHAR2(64),
  JT       VARCHAR2(32),
  BC       VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZL
  add constraint PK_SC_GZZGZL primary key (GZZGZLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZL
  add constraint FK_SC_GZZGZ_BM_GZZGZL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SC_GZZGZL
  add constraint FK_SC_GZZGZ_GZZ_GZZGZ_SC_GZZ foreign key (GZZID)
  references SC_GZZ (GZZID);
alter table SC_GZZGZL
  add constraint FK_SC_GZZGZ_JGD_GZZGZ_SC_JGD foreign key (JGDID)
  references SC_JGD (JGDID);
create index BM_GZZGZL_FK on SC_GZZGZL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ_GZZGZL_FK on SC_GZZGZL (GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGD_GZZGZL_FK on SC_GZZGZL (JGDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GZZGZL_FGSID_IDX on SC_GZZGZL (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GZZGZL_RQ_IDX on SC_GZZGZL (RQ)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZGZLMX
prompt ==========================
prompt
create table SC_GZZGZLMX
(
  GZZGZLMXID INTEGER not null,
  GZZGZLID   INTEGER not null,
  JGDMXID    INTEGER,
  CPID       INTEGER not null,
  DMSXID     INTEGER,
  GX         VARCHAR2(32),
  SL         NUMBER(16,6),
  SCSL       NUMBER(16,6),
  HSSL       NUMBER(16,6),
  JJDJ       NUMBER(20,9),
  JJGZ       NUMBER(20,9),
  GYLXID     INTEGER,
  JJFF       INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLMX
  add constraint PK_SC_GZZGZLMX primary key (GZZGZLMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLMX
  add constraint FK_SC_GZZGZ_DMSX_GZZG_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_GZZGZLMX
  add constraint FK_SC_GZZGZ_GYLX_MXGZ_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_GZZGZLMX
  add constraint FK_SC_GZZGZ_JGDMX_GZZ_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
alter table SC_GZZGZLMX
  add constraint FK_SC_GZZGZ_KCDM_GZZG_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_GZZGZLMX
  add constraint FK_SC_GZZGZ_SC_GZZGZL_SC_GZZGZ foreign key (GZZGZLID)
  references SC_GZZGZL (GZZGZLID);
create index DMSX_GZZGZLMX_FK on SC_GZZGZLMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_MXGZZGZL_FK on SC_GZZGZLMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index JGDMX_GZZGZLMX_FK on SC_GZZGZLMX (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_GZZGZLMX_FK on SC_GZZGZLMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GZZGZL_MX_FK on SC_GZZGZLMX (GZZGZLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZGZLRY
prompt ==========================
prompt
create table SC_GZZGZLRY
(
  GZZGZLRYID INTEGER not null,
  PERSONID   INTEGER not null,
  GZZGZLID   INTEGER not null,
  JJGZ       NUMBER(20,9),
  BL         NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLRY
  add constraint PK_SC_GZZGZLRY primary key (GZZGZLRYID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLRY
  add constraint FK_SC_GZZGZ_EMP_GZZGZ_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SC_GZZGZLRY
  add constraint FK_SC_GZZGZ_GZZGZL_RY_SC_GZZGZ foreign key (GZZGZLID)
  references SC_GZZGZL (GZZGZLID);
create index EMP_GZZGZLRY_FK on SC_GZZGZLRY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SC_GZZGZL_RY_FK on SC_GZZGZLRY (GZZGZLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZGZLWL
prompt ==========================
prompt
create table SC_GZZGZLWL
(
  GZZGZLWLID INTEGER not null,
  CPID       INTEGER,
  DMSXID     INTEGER,
  GZZGZLID   INTEGER,
  SL         NUMBER(16,6),
  SCSL       NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLWL
  add constraint PK_SC_GZZGZLWL primary key (GZZGZLWLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZGZLWL
  add constraint FK_SC_GZZGZ_DMSX_GZZW_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_GZZGZLWL
  add constraint FK_SC_GZZGZ_GZZGZL_WL_SC_GZZGZ foreign key (GZZGZLID)
  references SC_GZZGZL (GZZGZLID);
alter table SC_GZZGZLWL
  add constraint FK_SC_GZZGZ_PROD_GZZW_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DMSX_GZZWL_FK on SC_GZZGZLWL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZGZL_WL_FK on SC_GZZGZLWL (GZZGZLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_GZZGZL_FK on SC_GZZGZLWL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_GZZRY
prompt =======================
prompt
create table SC_GZZRY
(
  GZZID    INTEGER not null,
  PERSONID INTEGER not null,
  RYJS     NUMBER(14,4),
  GYMCID   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_GZZRY
  is '工作组人员';
alter table SC_GZZRY
  add constraint PK_SC_GZZRY primary key (GZZID, PERSONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_GZZRY
  add constraint FK_SC_GZZRY_EMP_GZZRY_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SC_GZZRY
  add constraint FK_SC_GZZRY_GYMC_GZZR_SC_GYMC foreign key (GYMCID)
  references SC_GYMC (GYMCID);
alter table SC_GZZRY
  add constraint FK_SC_GZZRY_GZZ_GZZRY_SC_GZZ foreign key (GZZID)
  references SC_GZZ (GZZID);
create index EMP_GZZRY_FK on SC_GZZRY (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYMC_GZZRY_FK on SC_GZZRY (GYMCID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZZ_GZZRY_FK on SC_GZZRY (GZZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JGDMXGZL
prompt ==========================
prompt
create table SC_JGDMXGZL
(
  JGDMXID INTEGER not null,
  GX      VARCHAR2(32) not null,
  YPGZL   NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGDMXGZL
  add constraint PK_SC_JGDMXGZL primary key (JGDMXID, GX)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JGDMXGZL
  add constraint FK_SC_JGDMX_JGDMX_GZL_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
create index JGDMX_GZL_FK on SC_JGDMXGZL (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_JHMX
prompt ======================
prompt
create table SC_JHMX
(
  SCJHMXID INTEGER not null,
  CPID     INTEGER,
  SCJHID   INTEGER,
  HTHWID   INTEGER,
  GYLXID   INTEGER,
  SL       NUMBER(16,6),
  CSL      NUMBER(20,9),
  KSRQ     DATE,
  WCRQ     DATE,
  JGYQ     VARCHAR2(64),
  DMSXID   INTEGER,
  YWCL     NUMBER(16,6),
  SFSC     INTEGER,
  SCSL     NUMBER(16,6),
  FDXS     INTEGER,
  FDXH     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_JHMX
  is '生产计划明细';
comment on column SC_JHMX.SL
  is '数量';
alter table SC_JHMX
  add constraint PK_SC_JHMX primary key (SCJHMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_JHMX
  add constraint FK_SC_JHMX_GYLX_SCJH_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID)
  disable;
alter table SC_JHMX
  add constraint FK_SC_JHMX_HTHW_SCJH_XS_HTHW foreign key (HTHWID)
  references XS_HTHW (HTHWID)
  disable;
alter table SC_JHMX
  add constraint FK_SC_JHMX_KCDMSX_JH_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_JHMX
  add constraint FK_SC_JHMX_KCDM_SCJH_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
alter table SC_JHMX
  add constraint FK_SC_JHMX_SCJH_MX_SC_JH foreign key (SCJHID)
  references SC_JH (SCJHID)
  disable;
create index GYLX_SCJH_FK on SC_JHMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HTHW_SCJHMX_FK on SC_JHMX (HTHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDMSX_JHMX_FK on SC_JHMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SCJHMX_FK on SC_JHMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_MX_FK on SC_JHMX (SCJHID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_KHBOM
prompt =======================
prompt
create table SC_KHBOM
(
  KHBOMID INTEGER not null,
  HTHWID  INTEGER not null,
  CPID    INTEGER not null,
  DWTXID  INTEGER not null,
  SL      NUMBER(16,6),
  SHL     NUMBER(10,6),
  ZJLX    INTEGER not null,
  SJCPID  INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_KHBOM
  is '客户BOM表';
comment on column SC_KHBOM.SL
  is '数量';
comment on column SC_KHBOM.SHL
  is '损耗率';
comment on column SC_KHBOM.ZJLX
  is '子件类型:1=普通件,2=可选件,3=通用件';
comment on column SC_KHBOM.SJCPID
  is '上级物资ID';
alter table SC_KHBOM
  add constraint PK_SC_KHBOM primary key (KHBOMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_KHBOM
  add constraint FK_SC_KHBOM_DWTX_KHBO_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_KHBOM
  add constraint FK_SC_KHBOM_HTHW_KHBO_XS_HTHW foreign key (HTHWID)
  references XS_HTHW (HTHWID);
alter table SC_KHBOM
  add constraint FK_SC_KHBOM_KHSJWZID_KC_DM foreign key (SJCPID)
  references KC_DM (CPID);
alter table SC_KHBOM
  add constraint FK_SC_KHBOM_WZDM_KHBO_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DWTX_KHBOM_FK on SC_KHBOM (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index HTHW_KHBOM_FK on SC_KHBOM (HTHWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SJWZID_KHBOM_FK on SC_KHBOM (SJCPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_KHBOM_FK on SC_KHBOM (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_KHBOMLSB
prompt ==========================
prompt
create global temporary table SC_KHBOMLSB
(
  SJCPID INTEGER,
  CPID   INTEGER,
  SL     NUMBER(16,6),
  SHL    NUMBER(10,6),
  ZJLX   INTEGER
)
on commit preserve rows;

prompt
prompt Creating table SC_PROD_RATIO
prompt ============================
prompt
create table SC_PROD_RATIO
(
  CPID       INTEGER not null,
  KC__CPID   INTEGER not null,
  RATIO_CODE VARCHAR2(16) not null,
  RATIO_NAME VARCHAR2(32) not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_PROD_RATIO.CPID
  is '入库物资';
comment on column SC_PROD_RATIO.KC__CPID
  is '出库物资';
alter table SC_PROD_RATIO
  add constraint PK_SC_PROD_RATIO primary key (CPID, KC__CPID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_PROD_RATIO
  add constraint FK_SC_PROD__IN_PROD_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_PROD_RATIO
  add constraint FK_SC_PROD__OUT_PROD_KC_DM foreign key (KC__CPID)
  references KC_DM (CPID);
create index IN_PROD_FK on SC_PROD_RATIO (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index OUT_PROD_FK on SC_PROD_RATIO (KC__CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_RECEIVEPRODDETAIL
prompt ===================================
prompt
create table SC_RECEIVEPRODDETAIL
(
  RECEIVEDETAILID INTEGER not null,
  CPID            INTEGER not null,
  RECEIVEID       INTEGER not null,
  KWID            INTEGER,
  WZMXID          INTEGER,
  DMSXID          INTEGER,
  BATCHNO         VARCHAR2(32),
  DRAWBIGNUM      NUMBER(16,6),
  DRAWNUM         NUMBER(16,6),
  PRODUCENUM      NUMBER(16,6),
  DRAWPRICE       NUMBER(20,9),
  DRAWSUM         NUMBER(20,9),
  MEMO            VARCHAR2(64),
  JGDMXID         INTEGER,
  GX              VARCHAR2(32),
  JJFF            INTEGER,
  JJDJ            NUMBER(20,9),
  JJGZ            NUMBER(20,9),
  GYLXID          INTEGER,
  GX2             VARCHAR2(32),
  GX3             VARCHAR2(32),
  JJFF2           INTEGER,
  JJFF3           INTEGER,
  JJGZ2           NUMBER(20,9),
  JJGZ3           NUMBER(20,9),
  JJDJ2           NUMBER(20,9),
  JJDJ3           NUMBER(20,9),
  PACKAGE_ID      INTEGER,
  FUNDITEMID      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RECEIVEPRODDETAIL
  add constraint PK_SC_RECEIVEPRODDETAIL primary key (RECEIVEDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RECEIVEPRODDETAIL
  add constraint FK_SC_RECEI_GYLX_RECE_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID);
alter table SC_RECEIVEPRODDETAIL
  add constraint FK_SC_RECEI_PROCESS_R_SC_JGDMX foreign key (JGDMXID)
  references SC_JGDMX (JGDMXID);
create index DMSX_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KW_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (KWID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PROCESS_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (JGDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RECEIVEPROD_DETAIL_FK on SC_RECEIVEPRODDETAIL (RECEIVEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZMX_RECEIVEDETAIL_FK on SC_RECEIVEPRODDETAIL (WZMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_RWDMX
prompt =======================
prompt
create table SC_RWDMX
(
  RWDMXID    INTEGER not null,
  WLXQJHMXID INTEGER,
  RWDID      INTEGER,
  CPID       INTEGER,
  GYLXID     INTEGER,
  SL         NUMBER(16,6),
  CSL        NUMBER(20,9),
  KSRQ       DATE,
  WCRQ       DATE,
  JGYQ       VARCHAR2(128),
  YJGL       NUMBER(16,6),
  DMSXID     INTEGER,
  SCSL       NUMBER(16,6),
  YJGSCL     NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_RWDMX
  is '生产任务单明细';
comment on column SC_RWDMX.SL
  is '数量';
comment on column SC_RWDMX.YJGL
  is '加工单回填';
alter table SC_RWDMX
  add constraint PK_SC_RWDMX primary key (RWDMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_RWDMX
  add constraint FK_SC_RWDMX_DMSX_RWD_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_RWDMX
  add constraint FK_SC_RWDMX_GYLX_RWD_SC_GYLX foreign key (GYLXID)
  references SC_GYLX (GYLXID)
  disable;
alter table SC_RWDMX
  add constraint FK_SC_RWDMX_KCDM_SCRW_KC_DM foreign key (CPID)
  references KC_DM (CPID)
  disable;
alter table SC_RWDMX
  add constraint FK_SC_RWDMX_RWD_MX_SC_RWD foreign key (RWDID)
  references SC_RWD (RWDID);
alter table SC_RWDMX
  add constraint FK_SC_RWDMX_WLXQJHMX_SC_WLXQJ foreign key (WLXQJHMXID)
  references SC_WLXQJHMX (WLXQJHMXID)
  disable;
create index DMSX_RWD_FK on SC_RWDMX (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GYLX_RWDMX_FK on SC_RWDMX (GYLXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SCRWDMX_FK on SC_RWDMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index RWD_MX_FK on SC_RWDMX (RWDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WLXQJHMX_FK on SC_RWDMX (WLXQJHMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_SCNL
prompt ======================
prompt
create table SC_SCNL
(
  SCNLID INTEGER not null,
  CPID   INTEGER,
  WZLBID INTEGER,
  GZZXID INTEGER,
  TQQ    INTEGER,
  SBS    INTEGER,
  RGS    INTEGER,
  RS     INTEGER,
  CL     NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_SCNL
  add constraint PK_SC_SCNL primary key (SCNLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_SCNL
  add constraint FK_SC_SCNL_GZZX_SCNL_SC_GZZX foreign key (GZZXID)
  references SC_GZZX (GZZXID);
alter table SC_SCNL
  add constraint FK_SC_SCNL_KCDM_SCNL_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_SCNL
  add constraint FK_SC_SCNL_WZLB_SCNL_KC_DMLB foreign key (WZLBID)
  references KC_DMLB (WZLBID)
  disable;
create index GZZX_SCNL_FK on SC_SCNL (GZZXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SCNL_FK on SC_SCNL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZLB_SCNL_FK on SC_SCNL (WZLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_SJBOM
prompt =======================
prompt
create table SC_SJBOM
(
  SJBOMID   INTEGER not null,
  SCJHMXID  INTEGER,
  DMSXID    INTEGER,
  CPID      INTEGER,
  HTID      INTEGER,
  XQL       NUMBER(16,6),
  XQRQ      DATE,
  CHXZ      INTEGER,
  CC        INTEGER,
  ZJLX      INTEGER not null,
  SL        NUMBER(16,6),
  SCZJSL    NUMBER(16,6),
  SCXQL     NUMBER(16,6),
  SJCPID    INTEGER,
  SJSJBOMID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_SJBOM
  add constraint PK_SC_SJBOM primary key (SJBOMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_CJCPID_SJ_KC_DM foreign key (SJCPID)
  references KC_DM (CPID);
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_DMSX_SJBO_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_KCDM_SJBO_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_SCJH_WLXQ_SC_JHMX foreign key (SCJHMXID)
  references SC_JHMX (SCJHMXID);
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_SJSJBOM_SC_SJBOM foreign key (SJSJBOMID)
  references SC_SJBOM (SJBOMID);
alter table SC_SJBOM
  add constraint FK_SC_SJBOM_XSHT_SJBO_XS_HT foreign key (HTID)
  references XS_HT (HTID);
create index CJCPID_SJBOM_FK on SC_SJBOM (SJCPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_SJBOM_FK on SC_SJBOM (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_SJBOM_FK on SC_SJBOM (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SCJH_WLXQ_FK on SC_SJBOM (SCJHMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SJSJBOM_FK on SC_SJBOM (SJSJBOMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSHT_SJBOM_FK on SC_SJBOM (HTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_TRACK_TYPE
prompt ============================
prompt
create table SC_TRACK_TYPE
(
  TRACK_TYPE_ID INTEGER not null,
  TYPE_CODE     VARCHAR2(32),
  TYPE_NAME     VARCHAR2(32),
  TYPE_PROP     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_TYPE
  add constraint PK_SC_TRACK_TYPE primary key (TRACK_TYPE_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_TRACK_BILL
prompt ============================
prompt
create table SC_TRACK_BILL
(
  TRACK_BILL_ID INTEGER not null,
  DWTXID        INTEGER,
  TRACK_TYPE_ID INTEGER not null,
  DMSXID        INTEGER,
  STOREID       INTEGER not null,
  CPID          INTEGER not null,
  TRACK_BILL_NO VARCHAR2(32),
  MATERIAL_NO   VARCHAR2(32),
  CHECKER       VARCHAR2(32),
  GROSS_WEIGHT  NUMBER(16,6),
  NET_WEIGHT    NUMBER(16,6),
  CHECK_RESULT  VARCHAR2(128),
  HANDLER       VARCHAR2(32),
  CREATOR       VARCHAR2(32),
  APPROVER      VARCHAR2(32),
  DYNE_SIDE     VARCHAR2(16),
  HOT_SIDE      VARCHAR2(16),
  GRADE         VARCHAR2(16),
  TOT_ULL       NUMBER(16,6),
  TOT_RATIO     NUMBER(16,6),
  DRAWID        INTEGER,
  TYPE_PROP     INTEGER,
  HYPO_RATIO    NUMBER(16,6),
  WASTER_RATIO  NUMBER(16,6),
  GOOD_RATIO    NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_TRACK_BILL.GOOD_RATIO
  is '正品率';
alter table SC_TRACK_BILL
  add constraint PK_SC_TRACK_BILL primary key (TRACK_BILL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_BILL
  add constraint FK_SC_TRACK_CK_GZK_KC_CK foreign key (STOREID)
  references KC_CK (STOREID);
alter table SC_TRACK_BILL
  add constraint FK_SC_TRACK_DMSX_GZK_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_TRACK_BILL
  add constraint FK_SC_TRACK_DWTX_GZK_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_TRACK_BILL
  add constraint FK_SC_TRACK_GZK_LX_SC_TRACK foreign key (TRACK_TYPE_ID)
  references SC_TRACK_TYPE (TRACK_TYPE_ID);
alter table SC_TRACK_BILL
  add constraint FK_SC_TRACK_KCDM_GZK_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index CK_GZK_FK on SC_TRACK_BILL (STOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_GZK_FK on SC_TRACK_BILL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_GZK_FK on SC_TRACK_BILL (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZK_LX_FK on SC_TRACK_BILL (TRACK_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_GZK_FK on SC_TRACK_BILL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_TRACK_DETAIL
prompt ==============================
prompt
create table SC_TRACK_DETAIL
(
  TRACK_DETAIL_ID INTEGER not null,
  DMSXID          INTEGER,
  CPID            INTEGER,
  GYMCID          INTEGER not null,
  TRACK_BILL_ID   INTEGER not null,
  TRACK_TYPE      INTEGER,
  PROD_DATE       DATE,
  QUAL_VALIDATE   VARCHAR2(64),
  DOPE_ONE        VARCHAR2(32),
  DOPE_TWO        VARCHAR2(32),
  WEIGHT          NUMBER(16,6),
  LENGTH          NUMBER(16,6),
  WEIGHT2         NUMBER(16,6),
  LENGTH2         NUMBER(16,6),
  RETURN_NUM      NUMBER(16,6),
  OLD_BREAK       NUMBER(10,2),
  NEW_BREAK       NUMBER(10,2),
  PLAN_LENGTH     NUMBER(16,6),
  PLAN_WEIGTH     NUMBER(16,6),
  FACT_LENGTH     NUMBER(16,6),
  FACT_WEIGHT     NUMBER(16,6),
  AWARD           NUMBER(16,6),
  ULL_REASON      VARCHAR2(64),
  QUAL_DESC       VARCHAR2(64),
  END_SIDE        VARCHAR2(32),
  MACHINE_NO      VARCHAR2(32),
  TEAM_NO         VARCHAR2(32),
  HANDLER         VARCHAR2(32),
  CREATOR         VARCHAR2(32),
  APPROVER        VARCHAR2(32),
  DRAWID          INTEGER,
  OK_SHEET1       NUMBER(12,2),
  OK_SHEET2       NUMBER(12,2),
  OK_SHEET3       NUMBER(12,2),
  OK_WEIGHT1      NUMBER(16,6),
  OK_WEIGHT2      NUMBER(16,6),
  OK_WEIGHT3      NUMBER(16,6),
  HYPO_SHEET1     NUMBER(12,2),
  HYPO_SHEET2     NUMBER(12,2),
  HYPO_SHEET3     NUMBER(12,2),
  HYPO_WEIGHT1    NUMBER(16,6),
  HYPO_WEIGHT2    NUMBER(16,6),
  HYPO_WEIGHT3    NUMBER(16,6),
  WAST_SHEET1     NUMBER(12,2),
  WAST_SHEET2     NUMBER(12,2),
  WAST_SHEET3     NUMBER(12,2),
  WAST_WEIGHT1    NUMBER(16,6),
  WAST_WEIGHT2    NUMBER(16,6),
  WAST_WEIGHT3    NUMBER(16,6),
  DISP_WIDTH1     NUMBER(16,6),
  DISP_WIDTH2     NUMBER(16,6),
  DISP_WIDTH3     NUMBER(16,6),
  DISP_WIDTH4     NUMBER(16,6),
  DISP_WIDTH5     NUMBER(16,6),
  DISP_WIDTH6     NUMBER(16,6),
  DISP_WIDTH7     NUMBER(16,6),
  DISP_WIDTH8     NUMBER(16,6),
  DISP_WIDTH9     NUMBER(16,6),
  PROD_BATNO      VARCHAR2(32),
  PROD_RATIO      NUMBER(16,6),
  DISP_NO         VARCHAR2(32),
  HYPO_REASON     VARCHAR2(64),
  HYPO_DEPTID     INTEGER,
  WAST_REASON     VARCHAR2(64),
  WAST_DEPTID     NUMBER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_TRACK_DETAIL.TRACK_TYPE
  is '0=普通,1=底涂,2=分切,3=横切';
alter table SC_TRACK_DETAIL
  add constraint PK_SC_TRACK_DETAIL primary key (TRACK_DETAIL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_DETAIL
  add constraint FK_SC_TRACK_DMSX_TRAC_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table SC_TRACK_DETAIL
  add constraint FK_SC_TRACK_GY_GZDMX_SC_GYMC foreign key (GYMCID)
  references SC_GYMC (GYMCID);
alter table SC_TRACK_DETAIL
  add constraint FK_SC_TRACK_GZK_MX_SC_TRACK foreign key (TRACK_BILL_ID)
  references SC_TRACK_BILL (TRACK_BILL_ID);
alter table SC_TRACK_DETAIL
  add constraint FK_SC_TRACK_KCDM_TRAC_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DMSX_TRACK_FK on SC_TRACK_DETAIL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GY_GZDMX_FK on SC_TRACK_DETAIL (GYMCID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZK_MX_FK on SC_TRACK_DETAIL (TRACK_BILL_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_TRACK_FK on SC_TRACK_DETAIL (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_TRACK_DISPART
prompt ===============================
prompt
create table SC_TRACK_DISPART
(
  DISPART_ID      INTEGER not null,
  TRACK_BILL_ID   INTEGER not null,
  TRACK_DETAIL_ID INTEGER not null,
  DISP_WEIGHT1    NUMBER(16,6),
  DISP_WEIGHT2    NUMBER(16,6),
  DISP_WEIGHT3    NUMBER(16,6),
  DISP_WEIGHT4    NUMBER(16,6),
  DISP_WEIGHT5    NUMBER(16,6),
  DISP_WEIGHT6    NUMBER(16,6),
  DISP_WEIGHT7    NUMBER(16,6),
  DISP_WEIGHT8    NUMBER(16,6),
  DISP_WEIGHT9    NUMBER(16,6),
  DISP_LENTH1     NUMBER(16,6),
  DISP_LENTH2     NUMBER(16,6),
  DISP_LENTH3     NUMBER(16,6),
  DISP_LENTH4     NUMBER(16,6),
  DISP_LENTH5     NUMBER(16,6),
  DISP_LENTH6     NUMBER(16,6),
  DISP_LENTH7     NUMBER(16,6),
  DISP_LENTH8     NUMBER(16,6),
  DISP_LENTH9     NUMBER(16,6),
  CUST_CODE1      VARCHAR2(32),
  CUST_CODE2      VARCHAR2(32),
  CUST_CODE4      VARCHAR2(32),
  CUST_CODE5      VARCHAR2(32),
  CUST_CODE3      VARCHAR2(32),
  CUST_CODE6      VARCHAR2(32),
  CUST_CODE7      VARCHAR2(32),
  CUST_CODE8      VARCHAR2(32),
  CUST_CODE9      VARCHAR2(32),
  BATCH_NO1       VARCHAR2(32),
  BATCH_NO2       VARCHAR2(32),
  BATCH_NO3       VARCHAR2(32),
  BATCH_NO4       VARCHAR2(32),
  BATCH_NO5       VARCHAR2(32),
  BATCH_NO6       VARCHAR2(32),
  BATCH_NO7       VARCHAR2(32),
  BATCH_NO8       VARCHAR2(32),
  BATCH_NO9       VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_DISPART
  add constraint PK_SC_TRACK_DISPART primary key (DISPART_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_DISPART
  add constraint FK_SC_TRACK_DETAIL_DI_SC_TRACK foreign key (TRACK_DETAIL_ID)
  references SC_TRACK_DETAIL (TRACK_DETAIL_ID);
alter table SC_TRACK_DISPART
  add constraint FK_SC_TRACK_TRACK_DIS_SC_TRACK foreign key (TRACK_BILL_ID)
  references SC_TRACK_BILL (TRACK_BILL_ID);
create index DETAIL_DISPART_FK on SC_TRACK_DISPART (TRACK_DETAIL_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TRACK_DISPART_FK on SC_TRACK_DISPART (TRACK_BILL_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_TRACK_PROC
prompt ============================
prompt
create table SC_TRACK_PROC
(
  TRACK_PROC_ID INTEGER not null,
  GYMCID        INTEGER not null,
  TRACK_TYPE_ID INTEGER not null,
  TRACK_TYPE    INTEGER,
  ORDER_NO      INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_TRACK_PROC.TRACK_TYPE
  is '0=普通,1=底涂,2=分切,3=横切';
alter table SC_TRACK_PROC
  add constraint PK_SC_TRACK_PROC primary key (TRACK_PROC_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_TRACK_PROC
  add constraint FK_SC_TRACK_GY_GZDGX_SC_GYMC foreign key (GYMCID)
  references SC_GYMC (GYMCID);
alter table SC_TRACK_PROC
  add constraint FK_SC_TRACK_GZD_GX_SC_TRACK foreign key (TRACK_TYPE_ID)
  references SC_TRACK_TYPE (TRACK_TYPE_ID);
create index GY_GZDGX_FK on SC_TRACK_PROC (GYMCID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index GZD_GX_FK on SC_TRACK_PROC (TRACK_TYPE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_WAGE_CALC
prompt ===========================
prompt
create table SC_WAGE_CALC
(
  DEPTID         INTEGER not null,
  PERSONID       INTEGER not null,
  HOURWAGE_CALC  INTEGER,
  PIECEWAGE_CALC INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SC_WAGE_CALC.HOURWAGE_CALC
  is '1=固定计时工资,2=变动计时工资';
comment on column SC_WAGE_CALC.PIECEWAGE_CALC
  is '3=计件工资,4=日总产量工时平均工资(剔除计时),5=日总产量人数平均工资(剔除计时)';
alter table SC_WAGE_CALC
  add constraint PK_SC_WAGE_CALC primary key (DEPTID, PERSONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_WAGE_CALC
  add constraint FK_SC_WAGE__DEPT_WAGE_BM foreign key (DEPTID)
  references BM (DEPTID);

prompt
prompt Creating table SC_WJGJG
prompt =======================
prompt
create table SC_WJGJG
(
  WJGJGID INTEGER not null,
  DWTXID  INTEGER,
  CPID    INTEGER,
  DJ      NUMBER(20,9),
  YHTJ    VARCHAR2(64),
  DFCPH   VARCHAR2(32),
  BZ      VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SC_WJGJG
  is '外加工价格';
comment on column SC_WJGJG.DJ
  is '单价';
comment on column SC_WJGJG.YHTJ
  is '优惠条件';
comment on column SC_WJGJG.DFCPH
  is '对方产品号';
comment on column SC_WJGJG.BZ
  is '备注';
alter table SC_WJGJG
  add constraint PK_SC_WJGJG primary key (WJGJGID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SC_WJGJG
  add constraint FK_SC_WJGJG_DWTX_WJGJ_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table SC_WJGJG
  add constraint FK_SC_WJGJG_KCDM_WJGJ_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DWTX_WJGJG_FK on SC_WJGJG (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_WJGJG_FK on SC_WJGJG (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SC_WLXQLSB
prompt =========================
prompt
create global temporary table SC_WLXQLSB
(
  SCJHMXID INTEGER,
  HTID     INTEGER,
  CPID     INTEGER,
  GYLXID   INTEGER,
  XQL      NUMBER(16,6),
  XQRQ     DATE,
  CHXZ     INTEGER,
  CC       NUMBER
)
on commit preserve rows;

prompt
prompt Creating table SP_XM
prompt ====================
prompt
create table SP_XM
(
  SPXMID   INTEGER not null,
  SPXMBM   VARCHAR2(32),
  SPXMMC   VARCHAR2(32),
  URL      VARCHAR2(128),
  DYBM     VARCHAR2(32),
  ZJZDM    VARCHAR2(32),
  ZTZDM    VARCHAR2(32),
  ZTTGZ    VARCHAR2(5),
  ZTBTGZ   VARCHAR2(5),
  ZTMSZDM  VARCHAR2(32),
  SPRIDZDM VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SP_XM
  is '审批项目';
comment on column SP_XM.SPXMBM
  is '审批项目编码';
comment on column SP_XM.SPXMMC
  is '审批项目名称';
comment on column SP_XM.DYBM
  is '对应表名';
comment on column SP_XM.ZJZDM
  is '主键字段名';
comment on column SP_XM.ZTZDM
  is '状态字段名';
comment on column SP_XM.ZTTGZ
  is '状态通过值';
comment on column SP_XM.ZTBTGZ
  is '状态不通过值';
comment on column SP_XM.ZTMSZDM
  is '状态描述字段名';
alter table SP_XM
  add constraint PK_SP_XM primary key (SPXMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XM
  add constraint AK_SP_XM_SPXMBM_AK_SP_XM unique (SPXMBM)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_JL
prompt ====================
prompt
create table SP_JL
(
  SPJLID   INTEGER not null,
  SPXMID   INTEGER not null,
  PERSONID INTEGER,
  DEPTID   INTEGER,
  SPXMBM   VARCHAR2(32),
  SPXMMC   VARCHAR2(32),
  ZJID     INTEGER,
  TJSPRQ   DATE,
  SFJS     INTEGER,
  SPNR     VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SP_JL
  is '审批记录';
comment on column SP_JL.PERSONID
  is '提交人';
comment on column SP_JL.DEPTID
  is '提交部门';
comment on column SP_JL.SPXMBM
  is '审批项目编码';
comment on column SP_JL.SPXMMC
  is '审批项目名称';
comment on column SP_JL.TJSPRQ
  is '提交审批日期';
comment on column SP_JL.SFJS
  is '1=结束';
alter table SP_JL
  add constraint PK_SP_JL primary key (SPJLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_JL
  add constraint FK_SP_JL_BM_SPJL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SP_JL
  add constraint FK_SP_JL_EMP_SPJL_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SP_JL
  add constraint FK_SP_JL_SPXM_SPJL_SP_XM foreign key (SPXMID)
  references SP_XM (SPXMID);
create index BM_SPJL_FK on SP_JL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_SPJL_FK on SP_JL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SPXM_SPJL_FK on SP_JL (SPXMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_JL_SFJS_IDX on SP_JL (SFJS)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_JL_ZJID_IDX on SP_JL (ZJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_XMTSMX
prompt ========================
prompt
create table SP_XMTSMX
(
  SPXMTSMXID INTEGER not null,
  SPXMID     INTEGER not null,
  TSMXBM     VARCHAR2(32),
  TSXMMC     VARCHAR2(32),
  URL        VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XMTSMX
  add constraint PK_SP_XMTSMX primary key (SPXMTSMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XMTSMX
  add constraint FK_SP_XMTSM_SPXM_TSMX_SP_XM foreign key (SPXMID)
  references SP_XM (SPXMID);
create index SPXM_TSMX_FK on SP_XMTSMX (SPXMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_XMMX
prompt ======================
prompt
create table SP_XMMX
(
  SPXMMXID   INTEGER not null,
  SPXMTSMXID INTEGER,
  SPXMID     INTEGER not null,
  SPDJ       INTEGER,
  SPMC       VARCHAR2(32),
  ZTMSTGZ    VARCHAR2(32),
  ZTMSBTGZ   VARCHAR2(32),
  URL        VARCHAR2(128),
  TSZ        VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SP_XMMX
  is '审批项目明细';
comment on column SP_XMMX.ZTMSTGZ
  is '状态描述通过值';
comment on column SP_XMMX.ZTMSBTGZ
  is '状态描述不通过值';
alter table SP_XMMX
  add constraint PK_SP_XMMX primary key (SPXMMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XMMX
  add constraint FK_SP_XMMX_SPXM_MX_SP_XM foreign key (SPXMID)
  references SP_XM (SPXMID);
alter table SP_XMMX
  add constraint FK_SP_XMMX_TSMX_XMMX_SP_XMTSM foreign key (SPXMTSMXID)
  references SP_XMTSMX (SPXMTSMXID);
create index SPXM_MX_FK on SP_XMMX (SPXMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TSMX_XMMX_FK on SP_XMMX (SPXMTSMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_JLMX
prompt ======================
prompt
create table SP_JLMX
(
  SPJLMXID   INTEGER not null,
  PERSONID   INTEGER,
  SPXMTSMXID INTEGER,
  SPXMMXID   INTEGER not null,
  SPJLID     INTEGER not null,
  SPDJ       INTEGER,
  SPMC       VARCHAR2(32),
  SFTG       INTEGER,
  SPRQ       DATE,
  SPYJ       VARCHAR2(256),
  URL        VARCHAR2(128),
  TSZ        VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table SP_JLMX
  is '审批记录明细';
comment on column SP_JLMX.PERSONID
  is '审批人';
comment on column SP_JLMX.SFTG
  is '0=未审批,1=通过,2=驳回';
comment on column SP_JLMX.SPYJ
  is '审批意见';
alter table SP_JLMX
  add constraint PK_SP_JLMX primary key (SPJLMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_JLMX
  add constraint FK_SP_JLMX_EMP_SPJLM_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SP_JLMX
  add constraint FK_SP_JLMX_SPJL_MX_SP_JL foreign key (SPJLID)
  references SP_JL (SPJLID);
alter table SP_JLMX
  add constraint FK_SP_JLMX_SPXMMX_SP_SP_XMMX foreign key (SPXMMXID)
  references SP_XMMX (SPXMMXID);
alter table SP_JLMX
  add constraint FK_SP_JLMX_TSMX_JLMX_SP_XMTSM foreign key (SPXMTSMXID)
  references SP_XMTSMX (SPXMTSMXID);
create index EMP_SPJLMX_FK on SP_JLMX (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SPJL_MX_FK on SP_JLMX (SPJLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SPXMMX_SPJLMX_FK on SP_JLMX (SPXMMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_JLMX_SFTG_IDX on SP_JLMX (SFTG)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TSMX_JLMX_FK on SP_JLMX (SPXMTSMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_JL_LS
prompt =======================
prompt
create table SP_JL_LS
(
  SPJLID INTEGER not null,
  SPXMBM VARCHAR2(32),
  SPXMMC VARCHAR2(32),
  ZJID   INTEGER,
  TJSPRQ DATE,
  TJBM   VARCHAR2(32),
  TJR    VARCHAR2(32),
  SPNR   VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SP_JL_LS.SPXMBM
  is '审批项目编码';
comment on column SP_JL_LS.SPXMMC
  is '审批项目名称';
comment on column SP_JL_LS.TJSPRQ
  is '提交审批日期';
alter table SP_JL_LS
  add constraint PK_SP_JL_LS primary key (SPJLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_JL_LS_XMBM_IDX on SP_JL_LS (SPXMBM)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_JL_LS_ZJID_IDX on SP_JL_LS (ZJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_JLMX_LS
prompt =========================
prompt
create table SP_JLMX_LS
(
  SPJLMXID INTEGER not null,
  SPJLID   INTEGER not null,
  SPDJ     INTEGER,
  SPMC     VARCHAR2(32),
  SFTG     INTEGER,
  SPRQ     DATE,
  SPYJ     VARCHAR2(256),
  URL      VARCHAR2(128),
  SPR      VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SP_JLMX_LS.SFTG
  is '0=未审批,1=通过,2=驳回';
comment on column SP_JLMX_LS.SPYJ
  is '审批意见';
alter table SP_JLMX_LS
  add constraint PK_SP_JLMX_LS primary key (SPJLMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_JLMX_LS
  add constraint FK_SP_JLMX__SPJLLS_MX_SP_JL_LS foreign key (SPJLID)
  references SP_JL_LS (SPJLID);
create index SPJLLS_MX_FK on SP_JLMX_LS (SPJLID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_SPR
prompt =====================
prompt
create table SP_SPR
(
  SPXMMXID INTEGER not null,
  PERSONID INTEGER not null,
  DEPTID   INTEGER default 0 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_SPR
  add constraint PK_SP_SPR primary key (SPXMMXID, PERSONID, DEPTID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_SPR
  add constraint FK_SP_SPR_DEPT_SPR_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table SP_SPR
  add constraint FK_SP_SPR_EMP_SPR_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table SP_SPR
  add constraint FK_SP_SPR_SPXMMX_SP_SP_XMMX foreign key (SPXMMXID)
  references SP_XMMX (SPXMMXID);
create index DEPT_SPR_FK on SP_SPR (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_SPR2_FK on SP_SPR (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index SP_SPR_FK on SP_SPR (SPXMMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SP_XMLX
prompt ======================
prompt
create table SP_XMLX
(
  SPXMID INTEGER not null,
  SPLX   INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XMLX
  add constraint PK_SP_XMLX primary key (SPXMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table SP_XMLX
  add constraint FK_SP_XMLX_SP_XM_LX_SP_XM foreign key (SPXMID)
  references SP_XM (SPXMID);

prompt
prompt Creating table SYSTEMPARAM
prompt ==========================
prompt
create table SYSTEMPARAM
(
  PARAMID INTEGER not null,
  CODE    VARCHAR2(32),
  NAME    VARCHAR2(32),
  VALUE   VARCHAR2(32),
  DEPTID  INTEGER,
  ISSHOW  INTEGER,
  BZ      VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column SYSTEMPARAM.CODE
  is '数量格式 - QTYFORMAT
价格格式 - PRICEFORMAT';
alter table SYSTEMPARAM
  add constraint PK_SYSTEMPARAM primary key (PARAMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table WHEREFIELD
prompt =========================
prompt
create table WHEREFIELD
(
  TABLECODE    VARCHAR2(32) not null,
  FIELDCODE    VARCHAR2(32) not null,
  EXTENDNAME   VARCHAR2(32),
  FIELDCAPTION VARCHAR2(32),
  DATATYPE     VARCHAR2(32),
  LINKTABLE    VARCHAR2(32),
  LINKCOLUMN   VARCHAR2(32),
  QUERYCOLUMN  VARCHAR2(32),
  OPERSIGN     VARCHAR2(32),
  INPUTTYPE    VARCHAR2(32),
  SPAN         VARCHAR2(10),
  ENUMVALUES   VARCHAR2(128),
  LOOKUP       VARCHAR2(32),
  SCRIPT       VARCHAR2(512),
  ORDERNUM     INTEGER,
  ISSHOW       INTEGER,
  ISCHANGE     INTEGER,
  INITVALUE    VARCHAR2(32),
  NEED         INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table WHEREFIELD
  add constraint AK_WHEREFIELD_AK_WHEREFIE unique (EXTENDNAME, FIELDCODE, TABLECODE)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WHEREFIELD_ISCHANGE_IDX on WHEREFIELD (ISCHANGE)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WHEREFIELD_ISSHOW_IDX on WHEREFIELD (ISSHOW)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_AREAPRICE
prompt ===========================
prompt
create table XS_AREAPRICE
(
  AREAPRICEID INTEGER not null,
  WZDJID      INTEGER,
  XS_JZJ      NUMBER(20,9),
  CJNO        VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_AREAPRICE
  add constraint PK_XS_AREAPRICE primary key (AREAPRICEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_AREAPRICE
  add constraint FK_XS_AREAP_XS_WZDJ_A_XS_WZDJ foreign key (WZDJID)
  references XS_WZDJ (WZDJID);
create index XS_WZDJ_AREAPRICE_FK on XS_AREAPRICE (WZDJID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_AREA_PRICE
prompt ============================
prompt
create table XS_AREA_PRICE
(
  AREA_PRICE_ID INTEGER not null,
  AREA_CODE     VARCHAR2(16),
  AREA_NAME     VARCHAR2(32),
  PER_PRICE     NUMBER(20,9),
  WAGE_CUST     NUMBER(16,6),
  WAGE_PRICE    NUMBER(20,9),
  PER_FEE       NUMBER(20,9),
  FEE_CUST      NUMBER(16,6),
  FEE_PRICE     NUMBER(20,9),
  ISSENDCAR     INTEGER default 0 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_AREA_PRICE
  add constraint PK_XS_AREA_PRICE primary key (AREA_PRICE_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_CAR
prompt =====================
prompt
create table XS_CAR
(
  CAR_ID    INTEGER not null,
  CAR_NO    VARCHAR2(32),
  CAR_STAND VARCHAR2(32),
  MEMO      VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_CAR
  add constraint PK_XS_CAR primary key (CAR_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_AREA_CAR
prompt ==========================
prompt
create table XS_AREA_CAR
(
  AREA_PRICE_ID INTEGER not null,
  CAR_ID        INTEGER not null,
  CAL_STAND     NUMBER(16,6),
  MEMO          VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_AREA_CAR.CAL_STAND
  is '小于该标准的重量用该标准,大于的用实际重量';
alter table XS_AREA_CAR
  add constraint PK_XS_AREA_CAR primary key (AREA_PRICE_ID, CAR_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_AREA_CAR
  add constraint FK_XS_AREA__AREA_CODE_XS_AREA_ foreign key (AREA_PRICE_ID)
  references XS_AREA_PRICE (AREA_PRICE_ID);
alter table XS_AREA_CAR
  add constraint FK_XS_AREA__CAR_MX_XS_CAR foreign key (CAR_ID)
  references XS_CAR (CAR_ID);
create index AREA_CODE_FK on XS_AREA_CAR (AREA_PRICE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index CAR_MX_FK on XS_AREA_CAR (CAR_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_DRIVER
prompt ========================
prompt
create table XS_DRIVER
(
  DRIVER_ID   INTEGER not null,
  DEPTID      INTEGER,
  DRIVER_CODE VARCHAR2(32),
  DRIVER_NAME VARCHAR2(32),
  ISSELFCORP  INTEGER,
  MEMO        VARCHAR2(512)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_DRIVER
  add constraint PK_XS_DRIVER primary key (DRIVER_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_DRIVER
  add constraint FK_XS_DRIVE_BM_DRIVER_BM foreign key (DEPTID)
  references BM (DEPTID);
create index BM_DRIVER_FK on XS_DRIVER (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_FLZ
prompt =====================
prompt
create table XS_FLZ
(
  FLZID INTEGER not null,
  MC    VARCHAR2(32),
  BZ    VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_FLZ
  add constraint PK_XS_FLZ primary key (FLZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_FLZMX
prompt =======================
prompt
create table XS_FLZMX
(
  FLZMXID INTEGER not null,
  CPID    INTEGER,
  FLZID   INTEGER,
  WZLBID  INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_FLZMX
  add constraint PK_XS_FLZMX primary key (FLZMXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_FLZMX
  add constraint FK_XS_FLZMX_FLZ_FLZMX_XS_FLZ foreign key (FLZID)
  references XS_FLZ (FLZID);
alter table XS_FLZMX
  add constraint FK_XS_FLZMX_KCDMLB_FL_KC_DMLB foreign key (WZLBID)
  references KC_DMLB (WZLBID);
alter table XS_FLZMX
  add constraint FK_XS_FLZMX_KCDM_FLZM_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index FLZ_FLZMX_FK on XS_FLZMX (FLZID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDMLB_FLZMX_FK on XS_FLZMX (WZLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_FLZMX_FK on XS_FLZMX (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_FUND_ITEM
prompt ===========================
prompt
create table XS_FUND_ITEM
(
  FUNDITEMID   INTEGER not null,
  FUNDITEMCODE VARCHAR2(32),
  FUNDITEMNAME VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_FUND_ITEM
  add constraint PK_XS_FUND_ITEM primary key (FUNDITEMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_JJZB
prompt ======================
prompt
create table XS_JJZB
(
  JJZBID INTEGER not null,
  NF     INTEGER not null,
  YF     NUMBER(20,9),
  SFJZ   INTEGER not null,
  LX     INTEGER default 1 not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_JJZB.LX
  is '1=默认计算方法,2=第2中计算方法';
alter table XS_JJZB
  add constraint PK_XS_JJZB primary key (JJZBID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_JJZB
  add constraint AK_XS_JJZB_AK_XS_JJZB unique (NF, YF, LX)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_JJ
prompt ====================
prompt
create table XS_JJ
(
  JJID     INTEGER not null,
  PERSONID INTEGER,
  DEPTID   INTEGER,
  JJZBID   INTEGER,
  SWBT     NUMBER(20,9),
  CGJ      NUMBER(20,8),
  GZ000266 NUMBER(20,8),
  TCJ      NUMBER(20,8),
  GZ000271 NUMBER(20,8),
  GZ000272 NUMBER(20,8),
  GZ000273 NUMBER(20,8),
  GZ000274 NUMBER(20,8),
  GZ000275 NUMBER(20,8),
  GZ000276 NUMBER(20,8),
  GZ000277 NUMBER(20,8),
  GZ000278 NUMBER(20,8),
  GZ000279 NUMBER(20,8),
  GZ000280 NUMBER(20,8),
  AVGCJTCL NUMBER(20,8),
  SL       NUMBER(20,8),
  XSA      NUMBER(20,8),
  XSB      NUMBER(20,8),
  XSC      NUMBER(20,8),
  XSD      NUMBER(20,8),
  RLL      NUMBER(20,8),
  JJ       NUMBER(20,8),
  XSJE     NUMBER(20,8),
  GZ000290 NUMBER(20,8),
  GZ000302 NUMBER(20,8)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_JJ
  add constraint PK_XS_JJ primary key (JJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_JJ
  add constraint FK_XS_JJ_BM_XS_JJ_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table XS_JJ
  add constraint FK_XS_JJ_EMP_XS_JJ_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table XS_JJ
  add constraint FK_XS_JJ_XS_JJZB_J_XS_JJZB foreign key (JJZBID)
  references XS_JJZB (JJZBID);
create index BM_XS_JJ_FK on XS_JJ (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_XS_JJ_FK on XS_JJ (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XS_JJZB_JJ_FK on XS_JJ (JJZBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_JJGSSZ
prompt ========================
prompt
create table XS_JJGSSZ
(
  JJGSSZID INTEGER not null,
  MC       VARCHAR2(32) not null,
  DYZDM    VARCHAR2(32),
  LX       INTEGER not null,
  CD       INTEGER not null,
  JD       INTEGER,
  LY       INTEGER,
  JSGS     VARCHAR2(128),
  JSQGS    VARCHAR2(256),
  PXH      INTEGER,
  SFKXG    INTEGER,
  SFXS     INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_JJGSSZ.SFKXG
  is '1=可修改,0=不可修改';
alter table XS_JJGSSZ
  add constraint PK_XS_JJGSSZ primary key (JJGSSZID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_JJJSGS
prompt ========================
prompt
create table XS_JJJSGS
(
  JJJSGSID INTEGER not null,
  JSFS     INTEGER not null,
  RLL      NUMBER(20,9),
  XSJZJ    NUMBER(20,9),
  TCLZJ    NUMBER(20,9),
  HLTSZJ   NUMBER(20,9),
  XSJJS    NUMBER(20,9),
  TCLJS    NUMBER(20,9),
  HLTSJS   NUMBER(20,9),
  JJJSGS   VARCHAR2(64),
  KXBL     NUMBER(20,9),
  SFXDW    INTEGER default 0
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table XS_JJJSGS
  is '奖金计算公式';
comment on column XS_JJJSGS.JSFS
  is '1=按发票,2=按提单';
comment on column XS_JJJSGS.KXBL
  is '(每天%)';
alter table XS_JJJSGS
  add constraint PK_XS_JJJSGS primary key (JJJSGSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_KHCPZK
prompt ========================
prompt
create table XS_KHCPZK
(
  CPID   INTEGER not null,
  DWTXID INTEGER not null,
  FGSID  INTEGER not null,
  KHCPDM VARCHAR2(32),
  DJ     NUMBER(20,9),
  ZK     NUMBER(9,6),
  BJ     NUMBER(20,9),
  JJBL   NUMBER(9,6),
  BZ     VARCHAR2(64),
  DMSXID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_KHCPZK
  add constraint AK_XS_KHCPZK unique (CPID, DWTXID, FGSID, DMSXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_KHCPZK
  add constraint FK_XS_KHCPZ_DMSX_KHCP_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table XS_KHCPZK
  add constraint FK_XS_KHCPZ_DWTX_KHCP_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index DMSX_KHCPZK_FK on XS_KHCPZK (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_KHCPZK_FK on XS_KHCPZK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index WZDM_KHCPZK_FK on XS_KHCPZK (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_KHDJXS
prompt ========================
prompt
create table XS_KHDJXS
(
  XYDJ     VARCHAR2(32),
  ADJUSTXS VARCHAR2(32),
  RTNLIMIT VARCHAR2(32),
  FUNDXS   VARCHAR2(32),
  DJXSID   INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_KHDJXS
  add constraint AK_XS_KHDJXS_PK_XS_KHDJX unique (DJXSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_KHXYED
prompt ========================
prompt
create table XS_KHXYED
(
  XYEDID INTEGER not null,
  DWTXID INTEGER,
  XYED   NUMBER(20,9),
  XYDJ   VARCHAR2(16),
  FGSID  INTEGER,
  HKTS   INTEGER,
  XYSDL  NUMBER(20,9),
  YSK    NUMBER(20,9),
  HLTS   INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table XS_KHXYED
  is '客户信誉额度';
alter table XS_KHXYED
  add constraint PK_XS_KHXYED primary key (XYEDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_KHXYED
  add constraint AK_XS_KHXYED unique (DWTXID, FGSID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_KHXYED
  add constraint FK_XS_KHXYE_DWTX_QKED_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index DWTX_QKED_FK on XS_KHXYED (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KHXYED_FGSID_IDX on XS_KHXYED (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_TDYJ
prompt ======================
prompt
create table XS_TDYJ
(
  TDYJID       INTEGER not null,
  TDID         INTEGER not null,
  BEFOREID     INTEGER,
  BEFORENAME   VARCHAR2(32),
  AFTERID      INTEGER,
  AFTERNAME    VARCHAR2(32),
  CZRQ         DATE,
  CZY          VARCHAR2(32),
  CZYID        INTEGER,
  FGSID        INTEGER,
  ZT           INTEGER,
  ZTMS         VARCHAR2(32),
  SPRID        INTEGER,
  BEFOREDEPTID INTEGER,
  AFTERDEPTID  INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TDYJ
  add constraint PK_XS_TDYJ primary key (TDYJID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TDYJ
  add constraint FK_XS_TDYJ_DEPT_AFTE_BM foreign key (AFTERDEPTID)
  references BM (DEPTID);
alter table XS_TDYJ
  add constraint FK_XS_TDYJ_DEPT_BEFO_BM foreign key (BEFOREDEPTID)
  references BM (DEPTID);
alter table XS_TDYJ
  add constraint FK_XS_TDYJ_EMP_AFTER_EMP foreign key (AFTERID)
  references EMP (PERSONID);
alter table XS_TDYJ
  add constraint FK_XS_TDYJ_EMP_BEFOR_EMP foreign key (BEFOREID)
  references EMP (PERSONID);
alter table XS_TDYJ
  add constraint FK_XS_TDYJ_XSTD_YJ_XS_TD foreign key (TDID)
  references XS_TD (TDID);
create index DEPT_AFTERID_FK on XS_TDYJ (AFTERDEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DEPT_BEFOREID_FK on XS_TDYJ (BEFOREDEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_AFTERID_IDX on XS_TDYJ (AFTERID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_BEFOREID_FK on XS_TDYJ (BEFOREID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSTD_CZYID_IDX on XS_TDYJ (CZYID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSTD_FGSID_IDX on XS_TDYJ (FGSID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index XSTD_YJ_FK on XS_TDYJ (TDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_TRANSPORT
prompt ===========================
prompt
create table XS_TRANSPORT
(
  TRANSPORT_ID INTEGER not null,
  DEPTID       INTEGER,
  TRANS_CODE   VARCHAR2(32),
  TRANS_DATE   DATE,
  STATE        INTEGER,
  CAR_ID       INTEGER,
  DRIVER_ID    INTEGER,
  DWTXID       INTEGER,
  FEE_WEIGHT   NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_TRANSPORT.STATE
  is '8=完成';
alter table XS_TRANSPORT
  add constraint PK_XS_TRANSPORT primary key (TRANSPORT_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TRANSPORT
  add constraint FK_XS_TRANS_CAR_TRANS_XS_CAR foreign key (CAR_ID)
  references XS_CAR (CAR_ID);
alter table XS_TRANSPORT
  add constraint FK_XS_TRANS_DEPT_TRAN_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table XS_TRANSPORT
  add constraint FK_XS_TRANS_DRIV_TRAN_XS_DRIVE foreign key (DRIVER_ID)
  references XS_DRIVER (DRIVER_ID);
alter table XS_TRANSPORT
  add constraint FK_XS_TRANS_DWTX_TRAN_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
create index CAR_TRANS_FK on XS_TRANSPORT (CAR_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DEPT_TRANS_FK on XS_TRANSPORT (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DRIV_TRAN_FK on XS_TRANSPORT (DRIVER_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_TRAN_FK on XS_TRANSPORT (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_TRANS_DETAIL
prompt ==============================
prompt
create table XS_TRANS_DETAIL
(
  TRANS_DETAIL_ID INTEGER not null,
  AREA_PRICE_ID   INTEGER not null,
  TRANSPORT_ID    INTEGER,
  WEIGHT          NUMBER(16,6),
  FEE_WEIGHT      NUMBER(16,6),
  PER_PRICE       NUMBER(20,9),
  WAGE_CUST       NUMBER(16,6),
  WAGE_PRICE      NUMBER(20,9),
  PER_FEE         NUMBER(20,9),
  FEE_CUST        NUMBER(16,6),
  FEE_PRICE       NUMBER(20,9),
  ISSENDCAR       INTEGER,
  PERSONID        INTEGER,
  DWTXID          INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column XS_TRANS_DETAIL.WEIGHT
  is '单位:kg';
comment on column XS_TRANS_DETAIL.WAGE_PRICE
  is '单位:kg';
comment on column XS_TRANS_DETAIL.FEE_PRICE
  is '单位:kg';
alter table XS_TRANS_DETAIL
  add constraint PK_XS_TRANS_DETAIL primary key (TRANS_DETAIL_ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_TRANS_DETAIL
  add constraint FK_XS_TRANS_AREA_TRAN_XS_AREA_ foreign key (AREA_PRICE_ID)
  references XS_AREA_PRICE (AREA_PRICE_ID);
alter table XS_TRANS_DETAIL
  add constraint FK_XS_TRANS_DWTX_PRIC_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table XS_TRANS_DETAIL
  add constraint FK_XS_TRANS_EMP_PRICE_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table XS_TRANS_DETAIL
  add constraint FK_XS_TRANS_TRANS_DET_XS_TRANS foreign key (TRANSPORT_ID)
  references XS_TRANSPORT (TRANSPORT_ID);
create index AREA_TRANS_FK on XS_TRANS_DETAIL (AREA_PRICE_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_PRICE_FK on XS_TRANS_DETAIL (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_PRICE_FK on XS_TRANS_DETAIL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TRANS_DETAIL_FK on XS_TRANS_DETAIL (TRANSPORT_ID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XS_YSK
prompt =====================
prompt
create table XS_YSK
(
  DWTXID   INTEGER not null,
  RQ       DATE,
  YSK      NUMBER(20,9),
  KHLX     VARCHAR2(1),
  FGSID    INTEGER not null,
  PERSONID INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_YSK
  add constraint AK_XS_YSK_AK_XS_YSK unique (KHLX, FGSID, DWTXID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table XS_YSK
  add constraint FK_XS_YSK_DWTX_YSK_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table XS_YSK
  add constraint FK_XS_YSK_EMP_YSK_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index DWTX_YSK_FK on XS_YSK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_YSK_FK on XS_YSK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_ADMINICLECHECK
prompt ================================
prompt
create table ZL_ADMINICLECHECK
(
  ADMINICLECHECKID INTEGER not null,
  CPID             INTEGER not null,
  DEPTID           INTEGER not null,
  DWTXID           INTEGER not null,
  ADMINICLECHECKNO VARCHAR2(32) not null,
  GOODS_DATE       DATE not null,
  TOT_NUM          NUMBER(16,6),
  FACIES           VARCHAR2(32),
  SAMPLE_INTEGER   NUMBER(16,6),
  TRYOUT_DATE      DATE,
  STATE            INTEGER,
  APPROVERID       INTEGER,
  STATE_DESC       VARCHAR2(32),
  ESTIMATION       VARCHAR2(128),
  REMARK           VARCHAR2(128),
  CREATEDATE       DATE,
  CREATORID        INTEGER,
  CREATOR          VARCHAR2(32),
  FILIALEID        INTEGER,
  DMSXID           INTEGER,
  CHECK_VERDICT    INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_ADMINICLECHECK.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
alter table ZL_ADMINICLECHECK
  add constraint PK_ZL_ADMINICLECHECK primary key (ADMINICLECHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_ADMINICLECHECK
  add constraint FK_ZL_ADMIN_BM_ADMINI_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_ADMINICLECHECK
  add constraint FK_ZL_ADMIN_DMSX_ADMI_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_ADMINICLECHECK
  add constraint FK_ZL_ADMIN_DWTX_ADMI_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table ZL_ADMINICLECHECK
  add constraint FK_ZL_ADMIN_KCDM_ADMI_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index BM_ADMINICLE_FK on ZL_ADMINICLECHECK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_ADMINICLE_FK on ZL_ADMINICLECHECK (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_ADMINICLE_FK on ZL_ADMINICLECHECK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_ADMINICLE_FK on ZL_ADMINICLECHECK (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_BUGGRADE
prompt ==========================
prompt
create table ZL_BUGGRADE
(
  BUGID   INTEGER not null,
  BUGCODE VARCHAR2(32),
  BUGNAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_BUGGRADE
  add constraint PK_ZL_BUGGRADE primary key (BUGID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHECKSTANDARD
prompt ===============================
prompt
create table ZL_CHECKSTANDARD
(
  STANDARDID   INTEGER not null,
  STANDARDCODE VARCHAR2(32),
  STANDARDNAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHECKSTANDARD
  add constraint PK_ZL_CHECKSTANDARD primary key (STANDARDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_BUYCHECK
prompt ==========================
prompt
create table ZL_BUYCHECK
(
  BUYCHECKID         INTEGER not null,
  PERSONID           INTEGER not null,
  STANDARDID         INTEGER,
  DWTXID             INTEGER not null,
  CPID               INTEGER not null,
  DEPTID             INTEGER,
  RKDMXID            INTEGER,
  PRODUCTCHECKNO     VARCHAR2(32) not null,
  BILLTYPE           INTEGER not null,
  GET_NUM            NUMBER(16,6),
  GET_DATE           DATE,
  CHECK_NUM          NUMBER(16,6),
  BUYCHECKDATE       DATE,
  CHECK_VERDICT      INTEGER not null,
  STATE              INTEGER,
  APPROVERID         INTEGER,
  STATE_DESC         VARCHAR2(32),
  CHECKER_POSTSCRIPT VARCHAR2(128),
  REMARK             VARCHAR2(128),
  CREATEDATE         DATE,
  CREATORID          INTEGER,
  CREATOR            VARCHAR2(32),
  FILIALEID          INTEGER,
  DMSXID             INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_BUYCHECK.BILLTYPE
  is '1=原膜进货检验,2=原纸进货检验';
comment on column ZL_BUYCHECK.CHECK_VERDICT
  is '1=合格；0=不合格';
comment on column ZL_BUYCHECK.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
comment on column ZL_BUYCHECK.CHECKER_POSTSCRIPT
  is '原膜进货检验报告单';
alter table ZL_BUYCHECK
  add constraint PK_ZL_BUYCHECK primary key (BUYCHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_BILL_BUYC_KC_SFDJM foreign key (RKDMXID)
  references KC_SFDJMX (RKDMXID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_BM_BUYCHE_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_DMSX_BUY_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_DWTX_BUYC_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_EMP_BUYCH_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_KCDM_BUYC_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table ZL_BUYCHECK
  add constraint FK_ZL_BUYCH_STANDARD__ZL_CHECK foreign key (STANDARDID)
  references ZL_CHECKSTANDARD (STANDARDID);
create index BILL_BUYCHECK_FK on ZL_BUYCHECK (RKDMXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index BM_BUYCHECK_FK on ZL_BUYCHECK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_BUY_FK on ZL_BUYCHECK (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_BUYCHECK_FK on ZL_BUYCHECK (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_BUYCHECK_FK on ZL_BUYCHECK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_BUYCHECK_FK on ZL_BUYCHECK (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index STANDARD_BUYCHECK_FK on ZL_BUYCHECK (STANDARDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHECKITEM
prompt ===========================
prompt
create table ZL_CHECKITEM
(
  CHECKITEMID INTEGER not null,
  CODE        VARCHAR2(32),
  CHECKTYPE   INTEGER not null,
  CHECKITEM   VARCHAR2(32),
  UNIT        VARCHAR2(16),
  APPEAL      VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table ZL_CHECKITEM
  is '长度，直径，面积，体积，表面粗糙度，机器强度等';
comment on column ZL_CHECKITEM.CHECKTYPE
  is '1=原纸,2=原膜,3=成品纸,4=成品膜,5=辅助材料,6=化工原料,7=生产过程';
alter table ZL_CHECKITEM
  add constraint PK_ZL_CHECKITEM primary key (CHECKITEMID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_BUYCHECKDETAIL
prompt ================================
prompt
create table ZL_BUYCHECKDETAIL
(
  BUYCHECKDETAILID INTEGER not null,
  BUYCHECKID       INTEGER not null,
  CHECKITEMID      INTEGER,
  CHECKITEM        VARCHAR2(32),
  UNIT             VARCHAR2(16),
  TECHREQUEST      VARCHAR2(32),
  CHECK_VERDICT    INTEGER,
  CHECKRESULT      VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_BUYCHECKDETAIL.CHECK_VERDICT
  is '1=合格；0=不合格';
alter table ZL_BUYCHECKDETAIL
  add constraint PK_ZL_BUYCHECKDETAIL primary key (BUYCHECKDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_BUYCHECKDETAIL
  add constraint FK_ZL_BUYCH_BUYCHECK__ZL_BUYCH foreign key (BUYCHECKID)
  references ZL_BUYCHECK (BUYCHECKID);
alter table ZL_BUYCHECKDETAIL
  add constraint FK_ZL_BUYCH_ITEM_BUYC_ZL_CHECK foreign key (CHECKITEMID)
  references ZL_CHECKITEM (CHECKITEMID);
create index BUYCHECK_DETAIL_FK on ZL_BUYCHECKDETAIL (BUYCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ITEM_BUYCHECK_FK on ZL_BUYCHECKDETAIL (CHECKITEMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CERTIFIEDCARD
prompt ===============================
prompt
create table ZL_CERTIFIEDCARD
(
  CARDID       INTEGER not null,
  DMSXID       INTEGER,
  CPID         INTEGER not null,
  CARDDATE     DATE,
  QUALITYER    VARCHAR2(32),
  SALENUM      NUMBER(16,6),
  OTHERNUM     NUMBER(16,6),
  PRODUCENUM   NUMBER(16,6),
  BATNO        VARCHAR2(32),
  MEMO         VARCHAR2(128),
  CREATEDATE   DATE,
  CREATORID    INTEGER,
  CREATOR      VARCHAR2(32),
  PRODUCEGRADE VARCHAR2(32),
  DISPARTNUM   VARCHAR2(32),
  PRODUCEAREA  VARCHAR2(32),
  LINENUM      VARCHAR2(32),
  DEPTID       INTEGER,
  PAGENUM      NUMBER(16,6),
  GROSSNUM     NUMBER(16,6)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CERTIFIEDCARD
  add constraint PK_ZL_CERTIFIEDCARD primary key (CARDID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CERTIFIEDCARD
  add constraint FK_ZL_CERTI_DEPT_CERT_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_CERTIFIEDCARD
  add constraint FK_ZL_CERTI_DMSX_CERT_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_CERTIFIEDCARD
  add constraint FK_ZL_CERTI_KCDM_CERT_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DEPT_CERTCARD_FK on ZL_CERTIFIEDCARD (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CERTCARD_FK on ZL_CERTIFIEDCARD (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_CERTCARD_FK on ZL_CERTIFIEDCARD (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ZL_CARD_CREATORID_IDX on ZL_CERTIFIEDCARD (CREATORID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHECKLEVEL
prompt ============================
prompt
create table ZL_CHECKLEVEL
(
  LEVELID   INTEGER not null,
  LEVELCODE VARCHAR2(32),
  LEVELNAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHECKLEVEL
  add constraint PK_ZL_CHECKLEVEL primary key (LEVELID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHECKMETHOD
prompt =============================
prompt
create table ZL_CHECKMETHOD
(
  ID          INTEGER not null,
  CODE        VARCHAR2(32),
  CHECKMETHOD VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHECKMETHOD
  add constraint PK_ZL_CHECKMETHOD primary key (ID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHECKTYPE
prompt ===========================
prompt
create table ZL_CHECKTYPE
(
  WZLBID      INTEGER not null,
  CHECKTYPEID INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_CHECKTYPE.CHECKTYPEID
  is '1=原纸,2=原膜,3=成品纸,4=成品膜,5=辅助材料,6=化工原料,7=生产过程';
alter table ZL_CHECKTYPE
  add constraint PK_ZL_CHECKTYPE primary key (WZLBID, CHECKTYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHECKTYPE
  add constraint FK_ZL_CHECK_WZLB_TYPE_KC_DMLB foreign key (WZLBID)
  references KC_DMLB (WZLBID);
create index WZLB_TYPE_FK on ZL_CHECKTYPE (WZLBID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHEMICAL
prompt ==========================
prompt
create table ZL_CHEMICAL
(
  CHEMICALCHECKID INTEGER not null,
  DEPTID          INTEGER not null,
  PERSONID        INTEGER not null,
  DWTXID          INTEGER not null,
  CHEMICALCHECKNO VARCHAR2(32) not null,
  GET_DATE        DATE,
  CHECK_NUM       NUMBER(16,6),
  SHAREOUT_DATE   DATE,
  HUMIDITY        VARCHAR2(16),
  TEMPERATURE     VARCHAR2(16),
  CHECK_DATE      DATE,
  STATE           INTEGER not null,
  APPROVERID      INTEGER,
  STATE_DESC      VARCHAR2(32),
  ESTIMATION      VARCHAR2(128),
  CREATEDATE      DATE,
  CREATORID       INTEGER,
  CREATOR         VARCHAR2(32),
  FILIALEID       INTEGER,
  DMSXID          INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on table ZL_CHEMICAL
  is '状态 审批人 描述状态 制单日期 制单人 ';
comment on column ZL_CHEMICAL.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
alter table ZL_CHEMICAL
  add constraint PK_ZL_CHEMICAL primary key (CHEMICALCHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHEMICAL
  add constraint FK_ZL_CHEMI_BM_CHEMIC_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_CHEMICAL
  add constraint FK_ZL_CHEMI_DMSX_CHEM_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_CHEMICAL
  add constraint FK_ZL_CHEMI_DWTX_CHEM_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table ZL_CHEMICAL
  add constraint FK_ZL_CHEMI_EMP_CHEMI_EMP foreign key (PERSONID)
  references EMP (PERSONID);
create index BM_CHEMICAL_FK on ZL_CHEMICAL (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_CHEMICAL_FK on ZL_CHEMICAL (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_CHEMICAL_FK on ZL_CHEMICAL (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_CHEMICAL_FK on ZL_CHEMICAL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_CHEMICALDETAIL
prompt ================================
prompt
create table ZL_CHEMICALDETAIL
(
  CHEMICALDETAILID  INTEGER not null,
  CHEMICALCHECKID   INTEGER not null,
  PORDUCT_NAME      VARCHAR2(32),
  CONTENT_REQUEST   VARCHAR2(32),
  CONTENT_RESULT    VARCHAR2(32),
  ADHIBIT_REQUEST   VARCHAR2(32),
  ADHIBIT_RESULT    VARCHAR2(32),
  BEGINBOIL_REQUEST VARCHAR2(32),
  BEGINBOIL_RESULT  VARCHAR2(32),
  ENDBOIL_REQUEST   VARCHAR2(32),
  ENDBOIL_RESULT    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHEMICALDETAIL
  add constraint PK_ZL_CHEMICALDETAIL primary key (CHEMICALDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_CHEMICALDETAIL
  add constraint FK_ZL_CHEMI_CHEMICAL__ZL_CHEMI foreign key (CHEMICALCHECKID)
  references ZL_CHEMICAL (CHEMICALCHECKID);
create index CHEMICAL_DETAIL_FK on ZL_CHEMICALDETAIL (CHEMICALCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_PRODCHECK
prompt ===========================
prompt
create table ZL_PRODCHECK
(
  PRODUCTCHECKID  INTEGER not null,
  RECEIVEDETAILID INTEGER,
  CPID            INTEGER not null,
  STANDARDID      INTEGER,
  PERSONID        INTEGER not null,
  DEPTID          INTEGER not null,
  PRODUCTCHECKNO  VARCHAR2(32) not null,
  BILLTYPE        INTEGER not null,
  PRODUCTNO       VARCHAR2(32),
  CHECK_NUM       NUMBER(16,6),
  BUYCHECKDATE    DATE,
  REJECT_NUM      NUMBER(16,6),
  CHECK_VERDICT   INTEGER,
  STATE           INTEGER,
  STATE_DESC      VARCHAR2(32),
  APPROVERID      INTEGER,
  CREATEDATE      DATE,
  CREATORID       INTEGER,
  CREATOR         VARCHAR2(32),
  FILIALEID       INTEGER,
  DMSXID          INTEGER,
  MEMO            VARCHAR2(128),
  TIE_IN          VARCHAR2(256)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_PRODCHECK.BILLTYPE
  is '1=原膜进货检验,2=原纸进货检验';
comment on column ZL_PRODCHECK.CHECK_VERDICT
  is '1=合格；0=不合格';
comment on column ZL_PRODCHECK.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
alter table ZL_PRODCHECK
  add constraint PK_ZL_PRODCHECK primary key (PRODUCTCHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_BM_PRODUC_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_DMSX_PROD_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_EMP_PRODU_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_KCDM_PROD_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_PROD_CHEC_SC_RECEI foreign key (RECEIVEDETAILID)
  references SC_RECEIVEPRODDETAIL (RECEIVEDETAILID);
alter table ZL_PRODCHECK
  add constraint FK_ZL_PRODC_STANDARD__ZL_CHECK foreign key (STANDARDID)
  references ZL_CHECKSTANDARD (STANDARDID);
create index BM_PRODUCT_FK on ZL_PRODCHECK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_PROD_FK on ZL_PRODCHECK (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_PRODUCTCHECK_FK on ZL_PRODCHECK (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_PRODUCTCHECK_FK on ZL_PRODCHECK (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PROD_CHECK_FK on ZL_PRODCHECK (RECEIVEDETAILID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index STANDARD_PRODUCT_FK on ZL_PRODCHECK (STANDARDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_FACIES
prompt ========================
prompt
create table ZL_FACIES
(
  FACIESCHECKID  INTEGER not null,
  BUYCHECKID     INTEGER,
  PRODUCTCHECKID INTEGER,
  CHECKITEMID    INTEGER,
  RESULT         INTEGER not null,
  REMARK         VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_FACIES.RESULT
  is '1=合格,0=不合格';
alter table ZL_FACIES
  add constraint PK_ZL_FACIES primary key (FACIESCHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_FACIES
  add constraint FK_ZL_FACIE_FACIES_BU_ZL_BUYCH foreign key (BUYCHECKID)
  references ZL_BUYCHECK (BUYCHECKID);
alter table ZL_FACIES
  add constraint FK_ZL_FACIE_FACIES_PR_ZL_PRODC foreign key (PRODUCTCHECKID)
  references ZL_PRODCHECK (PRODUCTCHECKID);
alter table ZL_FACIES
  add constraint FK_ZL_FACIE_ITEM_FACI_ZL_CHECK foreign key (CHECKITEMID)
  references ZL_CHECKITEM (CHECKITEMID);
create index FACIES_BUYCHECK_FK on ZL_FACIES (BUYCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index FACIES_PRODUCTCHECK_FK on ZL_FACIES (PRODUCTCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ITEM_FACIES_FK on ZL_FACIES (CHECKITEMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_NEWPROVIDER
prompt =============================
prompt
create table ZL_NEWPROVIDER
(
  NEWPROVIDERID  INTEGER not null,
  DWTXID         INTEGER not null,
  STANDARDID     INTEGER,
  DEPTID         INTEGER not null,
  CPID           INTEGER not null,
  NEWPROVIDERNO  VARCHAR2(32) not null,
  GET_NUM        NUMBER(16,6),
  GET_DATE       DATE,
  CHECK_NUM      NUMBER(16,6),
  CHECK_DATE     DATE,
  CHECK_CIRCS    VARCHAR2(128),
  QUALITY_RESULT VARCHAR2(64),
  CHECK_VERDICT  INTEGER not null,
  QUALITYID      INTEGER,
  PRODUCE_TRYOUT VARCHAR2(512),
  PRODUCE_RESULT VARCHAR2(64),
  PRODUCEID      INTEGER,
  STATE          INTEGER,
  APPROVERID     INTEGER,
  STATE_DESC     VARCHAR2(32),
  CREATEDATE     DATE,
  CREATORID      INTEGER,
  CREATOR        VARCHAR2(32),
  FILIALEID      INTEGER,
  DMSXID         INTEGER
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_NEWPROVIDER.CHECK_VERDICT
  is '1=合格；0=不合格';
comment on column ZL_NEWPROVIDER.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
alter table ZL_NEWPROVIDER
  add constraint PK_ZL_NEWPROVIDER primary key (NEWPROVIDERID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_NEWPROVIDER
  add constraint FK_ZL_NEWPR_BM_NEWPRO_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_NEWPROVIDER
  add constraint FK_ZL_NEWPR_DMSX_PROV_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_NEWPROVIDER
  add constraint FK_ZL_NEWPR_DWTX_NEWP_DWTX foreign key (DWTXID)
  references DWTX (DWTXID);
alter table ZL_NEWPROVIDER
  add constraint FK_ZL_NEWPR_KCDM_NEWP_KC_DM foreign key (CPID)
  references KC_DM (CPID);
alter table ZL_NEWPROVIDER
  add constraint FK_ZL_NEWPR_STANDARD__ZL_CHECK foreign key (STANDARDID)
  references ZL_CHECKSTANDARD (STANDARDID);
create index BM_NEWPROVIDER_FK on ZL_NEWPROVIDER (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_PROVIDER_FK on ZL_NEWPROVIDER (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DWTX_NEWPROVIDER_FK on ZL_NEWPROVIDER (DWTXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_NEWPROVIDER_FK on ZL_NEWPROVIDER (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index STANDARD_NEW_FK on ZL_NEWPROVIDER (STANDARDID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_PROCESSCHECK
prompt ==============================
prompt
create table ZL_PROCESSCHECK
(
  PROCESSCHECKID INTEGER not null,
  CPID           INTEGER not null,
  DMSXID         INTEGER,
  PROCESSCHECKNO VARCHAR2(16),
  PLANTID        INTEGER,
  CHECKNUM       NUMBER(16,6),
  REJECTNUM      NUMBER(16,6),
  REMARK         VARCHAR2(256),
  CHECK_VERDICT  INTEGER not null,
  STATE          INTEGER,
  APPROVERID     INTEGER,
  STATE_DESC     VARCHAR2(32),
  CREATEDATE     DATE,
  CREATORID      INTEGER,
  CREATOR        VARCHAR2(32),
  FILIALEID      INTEGER,
  DEPTID         INTEGER not null
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_PROCESSCHECK.CHECK_VERDICT
  is '1=合格；0=不合格';
comment on column ZL_PROCESSCHECK.STATE
  is '0.初始化值,1.审核,2.已入库,9.审批中';
alter table ZL_PROCESSCHECK
  add constraint PK_ZL_PROCESSCHECK primary key (PROCESSCHECKID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_PROCESSCHECK
  add constraint FK_ZL_PROCE_DEPT_PROC_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_PROCESSCHECK
  add constraint FK_ZL_PROCE_DMSX_PROC_KC_DMSX foreign key (DMSXID)
  references KC_DMSX (DMSXID);
alter table ZL_PROCESSCHECK
  add constraint FK_ZL_PROCE_KCDM_PROC_KC_DM foreign key (CPID)
  references KC_DM (CPID);
create index DEPT_PROCCHECK_FK on ZL_PROCESSCHECK (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index DMSX_PROCESSCHECK_FK on ZL_PROCESSCHECK (DMSXID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index KCDM_PROCESS_FK on ZL_PROCESSCHECK (CPID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_PROCESSDETAIL
prompt ===============================
prompt
create table ZL_PROCESSDETAIL
(
  PROCESSDETAILID INTEGER not null,
  PROCESSCHECKID  INTEGER not null,
  PERSONID        INTEGER not null,
  CHECKITEMID     INTEGER not null,
  PROCEDURENAME   VARCHAR2(16),
  SERIAL_NUM      VARCHAR2(16),
  PRODUCE_DATE    DATE,
  CHECK_DATE      DATE,
  CHECKRESULT     VARCHAR2(64),
  CHECK_VERDICT   INTEGER not null,
  REMARK          VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_PROCESSDETAIL.CHECK_VERDICT
  is '1=合格；0=不合格';
alter table ZL_PROCESSDETAIL
  add constraint PK_ZL_PROCESSDETAIL primary key (PROCESSDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_PROCESSDETAIL
  add constraint FK_ZL_PROCE_EMP_DETAI_EMP foreign key (PERSONID)
  references EMP (PERSONID);
alter table ZL_PROCESSDETAIL
  add constraint FK_ZL_PROCE_ITEM_PROC_ZL_CHECK foreign key (CHECKITEMID)
  references ZL_CHECKITEM (CHECKITEMID);
create index DETAIL_PROCESS_FK on ZL_PROCESSDETAIL (PROCESSCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index EMP_DETAIL_FK on ZL_PROCESSDETAIL (PERSONID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index ITEM_PROCESS_FK on ZL_PROCESSDETAIL (CHECKITEMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_PRODCHECKDETAIL
prompt =================================
prompt
create table ZL_PRODCHECKDETAIL
(
  PRODUCTCHECKDETAILID INTEGER not null,
  PRODUCTCHECKID       INTEGER not null,
  CHECKITEMID          INTEGER,
  CHECKITEM            VARCHAR2(32),
  UNIT                 VARCHAR2(16),
  TECHREQUEST          VARCHAR2(32),
  CHECK_VERDICT        INTEGER,
  CHECKRESULT          VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
comment on column ZL_PRODCHECKDETAIL.CHECK_VERDICT
  is '1=合格；0=不合格';
alter table ZL_PRODCHECKDETAIL
  add constraint PK_ZL_PRODCHECKDETAIL primary key (PRODUCTCHECKDETAILID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_PRODCHECKDETAIL
  add constraint FK_ZL_PRODC_ITEM_PROD_ZL_CHECK foreign key (CHECKITEMID)
  references ZL_CHECKITEM (CHECKITEMID);
alter table ZL_PRODCHECKDETAIL
  add constraint FK_ZL_PRODC_PRODUCT_D_ZL_PRODC foreign key (PRODUCTCHECKID)
  references ZL_PRODCHECK (PRODUCTCHECKID);
create index ITEM_PRODUCT_FK on ZL_PRODCHECKDETAIL (CHECKITEMID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index PRODUCT_DETAIL_FK on ZL_PRODCHECKDETAIL (PRODUCTCHECKID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_QUALITYGRADE
prompt ==============================
prompt
create table ZL_QUALITYGRADE
(
  GRADEID       INTEGER not null,
  GRADECODE     VARCHAR2(32),
  GRADENAME     VARCHAR2(32),
  GRADEDESCRIBE VARCHAR2(64)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_QUALITYGRADE
  add constraint PK_ZL_QUALITYGRADE primary key (GRADEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_QUALITYREASON
prompt ===============================
prompt
create table ZL_QUALITYREASON
(
  REASONID   INTEGER not null,
  REASONCODE VARCHAR2(32),
  REASONNAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_QUALITYREASON
  add constraint PK_ZL_QUALITYREASON primary key (REASONID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_TOOLTYPE
prompt ==========================
prompt
create table ZL_TOOLTYPE
(
  TOOLTYPEID   INTEGER not null,
  TOOLTYPECODE VARCHAR2(32),
  TOOLTYPENAME VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_TOOLTYPE
  add constraint PK_ZL_TOOLTYPE primary key (TOOLTYPEID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZL_TOOLINFO
prompt ==========================
prompt
create table ZL_TOOLINFO
(
  TOOLID     INTEGER not null,
  TOOLTYPEID INTEGER,
  DEPTID     INTEGER,
  TOOLCODE   VARCHAR2(32),
  TOOLNAME   VARCHAR2(32),
  TOOLSPEC   VARCHAR2(32),
  TOOLMEMO   VARCHAR2(128)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_TOOLINFO
  add constraint PK_ZL_TOOLINFO primary key (TOOLID)
  using index 
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
alter table ZL_TOOLINFO
  add constraint FK_ZL_TOOLI_DEPT_TOOL_BM foreign key (DEPTID)
  references BM (DEPTID);
alter table ZL_TOOLINFO
  add constraint FK_ZL_TOOLI_TOOLTYPE__ZL_TOOLT foreign key (TOOLTYPEID)
  references ZL_TOOLTYPE (TOOLTYPEID);
create index DEPT_TOOL_FK on ZL_TOOLINFO (DEPTID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );
create index TOOLTYPE_TOOL_FK on ZL_TOOLINFO (TOOLTYPEID)
  tablespace infowarelab
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ZZ_APPROVELOG
prompt ============================
prompt
create table ZZ_APPROVELOG
(
  BILLID     INTEGER,
  BILLCODE   VARCHAR2(64),
  CHANGEDATE DATE,
  CAPTION    VARCHAR2(32)
)
tablespace infowarelab
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating sequence ACCOUNT_SEQ
prompt =============================
prompt
create sequence ACCOUNT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence ACTIVITY_AREA_SEQ
prompt ===================================
prompt
create sequence ACTIVITY_AREA_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence ADMIN_USER_SEQ
prompt ================================
prompt
create sequence ADMIN_USER_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 100
increment by 1
cache 20;

prompt
prompt Creating sequence BASE_MEMBER_SEQ
prompt =================================
prompt
create sequence BASE_MEMBER_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 100
increment by 1
cache 20;

prompt
prompt Creating sequence CATEGORY_SEQ
prompt ==============================
prompt
create sequence CATEGORY_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 3540
increment by 1
cache 20;

prompt
prompt Creating sequence CODE_SEQ
prompt ==========================
prompt
create sequence CODE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 120
increment by 1
cache 20;

prompt
prompt Creating sequence CONTENT_MANAGEMENT_SEQ
prompt ========================================
prompt
create sequence CONTENT_MANAGEMENT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence CUSTOMER_ADDRESS_SEQ
prompt ======================================
prompt
create sequence CUSTOMER_ADDRESS_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 141
increment by 1
cache 20;

prompt
prompt Creating sequence CUSTOMER_SEQ
prompt ==============================
prompt
create sequence CUSTOMER_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 141
increment by 1
cache 20;

prompt
prompt Creating sequence CUS_WEB_MESSAGE_SEQ
prompt =====================================
prompt
create sequence CUS_WEB_MESSAGE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 121
increment by 1
cache 20;

prompt
prompt Creating sequence DBOBJECTID_SEQUENCE
prompt =====================================
prompt
create sequence DBOBJECTID_SEQUENCE
minvalue 1
maxvalue 999999999999999999999999
start with 14782501
increment by 50
cache 50;

prompt
prompt Creating sequence ET1_PRODUCT_DESC_SEQ
prompt ======================================
prompt
create sequence ET1_PRODUCT_DESC_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence HIBERNATE_SEQUENCE
prompt ====================================
prompt
create sequence HIBERNATE_SEQUENCE
minvalue 1
maxvalue 999999999999999999999999999
start with 1301
increment by 1
cache 20;

prompt
prompt Creating sequence INFO_BLOCK_SEQ
prompt ================================
prompt
create sequence INFO_BLOCK_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence INSTALLMENT_BANK_SEQ
prompt ======================================
prompt
create sequence INSTALLMENT_BANK_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence MSG_TEMPLATE_SEQ
prompt ==================================
prompt
create sequence MSG_TEMPLATE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 100
increment by 1
cache 20;

prompt
prompt Creating sequence NEWS_INFO_SEQ
prompt ===============================
prompt
create sequence NEWS_INFO_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence ORDER_ITEM_SEQ
prompt ================================
prompt
create sequence ORDER_ITEM_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence ORDER_SEQ
prompt ===========================
prompt
create sequence ORDER_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence PAPER_CATALOG_SEQ
prompt ===================================
prompt
create sequence PAPER_CATALOG_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PERMISSION_ACTION_PARAM_SEQ
prompt =============================================
prompt
create sequence PERMISSION_ACTION_PARAM_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PERMISSION_ACTION_SEQ
prompt =======================================
prompt
create sequence PERMISSION_ACTION_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PERMMISSION_SEQ
prompt =================================
prompt
create sequence PERMMISSION_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_BRAND_SEQ
prompt ===================================
prompt
create sequence PRODUCT_BRAND_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_COLOR_SEQ
prompt ===================================
prompt
create sequence PRODUCT_COLOR_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_COLOR_STYLE_SEQ
prompt =========================================
prompt
create sequence PRODUCT_COLOR_STYLE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_COMMENT_SEQ
prompt =====================================
prompt
create sequence PRODUCT_COMMENT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_INSTALLMENT_SEQ
prompt =========================================
prompt
create sequence PRODUCT_INSTALLMENT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 23201
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_PIC_SEQ
prompt =================================
prompt
create sequence PRODUCT_PIC_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence PRODUCT_SEQ
prompt =============================
prompt
create sequence PRODUCT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 45
increment by 1
nocache;

prompt
prompt Creating sequence PRODUCT_STYLE_SEQ
prompt ===================================
prompt
create sequence PRODUCT_STYLE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence PRO_WATER_MARK_SEQ
prompt ====================================
prompt
create sequence PRO_WATER_MARK_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence ROLE_SEQ
prompt ==========================
prompt
create sequence ROLE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 120
increment by 1
cache 20;

prompt
prompt Creating sequence SEARCH_KEY_HOT_SEQ
prompt ====================================
prompt
create sequence SEARCH_KEY_HOT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SHIPPING_TYPE_SEQ
prompt ===================================
prompt
create sequence SHIPPING_TYPE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SHOPPING_CART_ITEM_SEQ
prompt ========================================
prompt
create sequence SHOPPING_CART_ITEM_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 101
increment by 1
cache 20;

prompt
prompt Creating sequence SHOPPING_FAILURE_RECORDE_SEQ
prompt ==============================================
prompt
create sequence SHOPPING_FAILURE_RECORDE_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence STUDENT_SEQUENCE
prompt ==================================
prompt
create sequence STUDENT_SEQUENCE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence SYSTEM_CONFIG_SEQ
prompt ===================================
prompt
create sequence SYSTEM_CONFIG_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 100
increment by 1
cache 20;

prompt
prompt Creating sequence S_BM
prompt ======================
prompt
create sequence S_BM
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_FEE_NAME
prompt ===============================
prompt
create sequence S_CB_FEE_NAME
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_FEE_TYPE
prompt ===============================
prompt
create sequence S_CB_FEE_TYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_OVERHEAD
prompt ===============================
prompt
create sequence S_CB_OVERHEAD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_OVERHEAD_DETAIL
prompt ======================================
prompt
create sequence S_CB_OVERHEAD_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_PROD_COST
prompt ================================
prompt
create sequence S_CB_PROD_COST
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CB_PROD_COST_D
prompt ==================================
prompt
create sequence S_CB_PROD_COST_D
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_BJ
prompt =========================
prompt
create sequence S_CG_BJ
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_HT
prompt =========================
prompt
create sequence S_CG_HT
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_HTFY
prompt ===========================
prompt
create sequence S_CG_HTFY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_HTHW
prompt ===========================
prompt
create sequence S_CG_HTHW
minvalue 1
maxvalue 9999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_HTJHD
prompt ============================
prompt
create sequence S_CG_HTJHD
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_HTJHDHW
prompt ==============================
prompt
create sequence S_CG_HTJHDHW
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_SQD
prompt ==========================
prompt
create sequence S_CG_SQD
minvalue 1
maxvalue 999999999999999999999999999
start with 82
increment by 1
cache 20;

prompt
prompt Creating sequence S_CG_SQDHW
prompt ============================
prompt
create sequence S_CG_SQDHW
minvalue 1
maxvalue 999999999999999999999999999
start with 82
increment by 1
cache 20;

prompt
prompt Creating sequence S_COUNTRY
prompt ===========================
prompt
create sequence S_COUNTRY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_CGFP
prompt ===========================
prompt
create sequence S_CW_CGFP
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_CGFPMX
prompt =============================
prompt
create sequence S_CW_CGFPMX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_CGJS
prompt ===========================
prompt
create sequence S_CW_CGJS
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_CGJSHX
prompt =============================
prompt
create sequence S_CW_CGJSHX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_CGYFK
prompt ============================
prompt
create sequence S_CW_CGYFK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_WJGJS
prompt ============================
prompt
create sequence S_CW_WJGJS
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_WJGJSHX
prompt ==============================
prompt
create sequence S_CW_WJGJSHX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_XJSZ
prompt ===========================
prompt
create sequence S_CW_XJSZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_XSFP
prompt ===========================
prompt
create sequence S_CW_XSFP
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_XSFPMX
prompt =============================
prompt
create sequence S_CW_XSFPMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_XSJS
prompt ===========================
prompt
create sequence S_CW_XSJS
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_XSJSHX
prompt =============================
prompt
create sequence S_CW_XSJSHX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_YHZHSZ
prompt =============================
prompt
create sequence S_CW_YHZHSZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_CW_ZPLY
prompt ===========================
prompt
create sequence S_CW_ZPLY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_DWDQ
prompt ========================
prompt
create sequence S_DWDQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_DWTX
prompt ========================
prompt
create sequence S_DWTX
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_DWTX_FILE
prompt =============================
prompt
create sequence S_DWTX_FILE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_DWTX_LX
prompt ===========================
prompt
create sequence S_DWTX_LX
minvalue 1
maxvalue 999999999999999999999999999
start with 121
increment by 1
cache 20;

prompt
prompt Creating sequence S_DWTX_LXR
prompt ============================
prompt
create sequence S_DWTX_LXR
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_EMP
prompt =======================
prompt
create sequence S_EMP
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_FY_YZF
prompt ==========================
prompt
create sequence S_FY_YZF
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_HTJHDMD
prompt ===========================
prompt
create sequence S_HTJHDMD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_BASIC_TECHNICS
prompt =====================================
prompt
create sequence S_JC_BASIC_TECHNICS
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_CHECKDETAIL
prompt ==================================
prompt
create sequence S_JC_CHECKDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_CHECKOUT
prompt ===============================
prompt
create sequence S_JC_CHECKOUT
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_COMMON_UNIT
prompt ==================================
prompt
create sequence S_JC_COMMON_UNIT
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_FPLB
prompt ===========================
prompt
create sequence S_JC_FPLB
minvalue 1
maxvalue 999999999999999999999999999
start with 5
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_FYFL
prompt ===========================
prompt
create sequence S_JC_FYFL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_ORDERTYPE
prompt ================================
prompt
create sequence S_JC_ORDERTYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 25
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_RZ
prompt =========================
prompt
create sequence S_JC_RZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_SENDMODE
prompt ===============================
prompt
create sequence S_JC_SENDMODE
minvalue 1
maxvalue 999999999999999999999999999
start with 3
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_WZCD
prompt ===========================
prompt
create sequence S_JC_WZCD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_WZCZ
prompt ===========================
prompt
create sequence S_JC_WZCZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_WZDL
prompt ===========================
prompt
create sequence S_JC_WZDL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_WZGG
prompt ===========================
prompt
create sequence S_JC_WZGG
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JC_WZPM
prompt ===========================
prompt
create sequence S_JC_WZPM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JG_YSD
prompt ==========================
prompt
create sequence S_JG_YSD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JG_ZLD
prompt ==========================
prompt
create sequence S_JG_ZLD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JG_ZLDJL
prompt ============================
prompt
create sequence S_JG_ZLDJL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JG_ZLDYQ
prompt ============================
prompt
create sequence S_JG_ZLDYQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_JSFS
prompt ========================
prompt
create sequence S_JSFS
minvalue 1
maxvalue 999999999999999999999999999
start with 165
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_CHLB
prompt ===========================
prompt
create sequence S_KC_CHLB
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_CK
prompt =========================
prompt
create sequence S_KC_CK
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_CSDJYT
prompt =============================
prompt
create sequence S_KC_CSDJYT
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_DM
prompt =========================
prompt
create sequence S_KC_DM
minvalue 1
maxvalue 999999999999999999999999999
start with 121
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_DMLB
prompt ===========================
prompt
create sequence S_KC_DMLB
minvalue 1
maxvalue 999999999999999999999999999
start with 25
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_DMLBSX
prompt =============================
prompt
create sequence S_KC_DMLBSX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_DMSX
prompt ===========================
prompt
create sequence S_KC_DMSX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_DM_LS
prompt ============================
prompt
create sequence S_KC_DM_LS
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_KCHZ
prompt ===========================
prompt
create sequence S_KC_KCHZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_KW
prompt =========================
prompt
create sequence S_KC_KW
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence S_KC_KWTZ
prompt ===========================
prompt
create sequence S_KC_KWTZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_PACKAGE
prompt ==============================
prompt
create sequence S_KC_PACKAGE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_PACKAGE_DETAIL
prompt =====================================
prompt
create sequence S_KC_PACKAGE_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_PD
prompt =========================
prompt
create sequence S_KC_PD
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_PDMX
prompt ===========================
prompt
create sequence S_KC_PDMX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_SFDJ
prompt ===========================
prompt
create sequence S_KC_SFDJ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_SFDJLB
prompt =============================
prompt
create sequence S_KC_SFDJLB
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_SFDJMX
prompt =============================
prompt
create sequence S_KC_SFDJMX
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_KC_WZMX
prompt ===========================
prompt
create sequence S_KC_WZMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_LIMITLIST
prompt =============================
prompt
create sequence S_LIMITLIST
minvalue 1
maxvalue 999999999999999999999999999
start with 2770
increment by 1
cache 20;

prompt
prompt Creating sequence S_NODEFIELD
prompt =============================
prompt
create sequence S_NODEFIELD
minvalue 1
maxvalue 999999999999999999999999999
start with 1710
increment by 1
cache 20;

prompt
prompt Creating sequence S_NODEFIELD_FIELDCODE
prompt =======================================
prompt
create sequence S_NODEFIELD_FIELDCODE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_NODEINFO
prompt ============================
prompt
create sequence S_NODEINFO
minvalue 1
maxvalue 999999999999999999999999999
start with 3080
increment by 1
cache 20;

prompt
prompt Creating sequence S_NODEPRIVILIGE
prompt =================================
prompt
create sequence S_NODEPRIVILIGE
minvalue 1
maxvalue 999999999999999999999999999
start with 202
increment by 1
cache 20;

prompt
prompt Creating sequence S_PERSONLIMITS
prompt ================================
prompt
create sequence S_PERSONLIMITS
minvalue 1
maxvalue 999999999999999999999999999
start with 1021
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_EMP_CHANGE
prompt =================================
prompt
create sequence S_RL_EMP_CHANGE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_EMP_CHANGE_DETAIL
prompt ========================================
prompt
create sequence S_RL_EMP_CHANGE_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_EVECTION_APPLY
prompt =====================================
prompt
create sequence S_RL_EVECTION_APPLY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_EVECTION_ROUT
prompt ====================================
prompt
create sequence S_RL_EVECTION_ROUT
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_GZKX
prompt ===========================
prompt
create sequence S_RL_GZKX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_GZKXSZ
prompt =============================
prompt
create sequence S_RL_GZKXSZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_GZKXZB
prompt =============================
prompt
create sequence S_RL_GZKXZB
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_INVITE_APPLY
prompt ===================================
prompt
create sequence S_RL_INVITE_APPLY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_INVITE_PLAN
prompt ==================================
prompt
create sequence S_RL_INVITE_PLAN
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_INVITE_PLAN_DETAIL
prompt =========================================
prompt
create sequence S_RL_INVITE_PLAN_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_MSXX
prompt ===========================
prompt
create sequence S_RL_MSXX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_PXJH
prompt ===========================
prompt
create sequence S_RL_PXJH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_PXKC
prompt ===========================
prompt
create sequence S_RL_PXKC
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_TRAIN_BACK
prompt =================================
prompt
create sequence S_RL_TRAIN_BACK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YGFZXX
prompt =============================
prompt
create sequence S_RL_YGFZXX
minvalue 1
maxvalue 999999999999999999999999999
start with 442
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YGXYKH
prompt =============================
prompt
create sequence S_RL_YGXYKH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YHXYK
prompt ============================
prompt
create sequence S_RL_YHXYK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YPGZJL
prompt =============================
prompt
create sequence S_RL_YPGZJL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YPJYQK
prompt =============================
prompt
create sequence S_RL_YPJYQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_YPXX
prompt ===========================
prompt
create sequence S_RL_YPXX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGBXQK
prompt =============================
prompt
create sequence S_RL_ZGBXQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGCJQK
prompt =============================
prompt
create sequence S_RL_ZGCJQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGGZJL
prompt =============================
prompt
create sequence S_RL_ZGGZJL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGJCQK
prompt =============================
prompt
create sequence S_RL_ZGJCQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGJTQK
prompt =============================
prompt
create sequence S_RL_ZGJTQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGJYQK
prompt =============================
prompt
create sequence S_RL_ZGJYQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGPXQK
prompt =============================
prompt
create sequence S_RL_ZGPXQK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGQTXX
prompt =============================
prompt
create sequence S_RL_ZGQTXX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGTCAH
prompt =============================
prompt
create sequence S_RL_ZGTCAH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGXXBD
prompt =============================
prompt
create sequence S_RL_ZGXXBD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_RL_ZGXXBDMX
prompt ===============================
prompt
create sequence S_RL_ZGXXBDMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ROLEINFO
prompt ============================
prompt
create sequence S_ROLEINFO
minvalue 1
maxvalue 999999999999999999999999999
start with 2
increment by 1
cache 20;

prompt
prompt Creating sequence S_ROLELIMIT
prompt =============================
prompt
create sequence S_ROLELIMIT
minvalue 1
maxvalue 999999999999999999999999999
start with 741
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_EQUIPSTATE
prompt =================================
prompt
create sequence S_SB_EQUIPSTATE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_EQUIPTYPE
prompt ================================
prompt
create sequence S_SB_EQUIPTYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_EXCEPTIONREASON
prompt ======================================
prompt
create sequence S_SB_EXCEPTIONREASON
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_EXCEPTIONTYPE
prompt ====================================
prompt
create sequence S_SB_EXCEPTIONTYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_MACHINE_TOOL_RECORD
prompt ==========================================
prompt
create sequence S_SB_MACHINE_TOOL_RECORD
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SB_MAINTAINTYPE
prompt ===================================
prompt
create sequence S_SB_MAINTAINTYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_BMGZL
prompt ============================
prompt
create sequence S_SC_BMGZL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_BMGZLMX
prompt ==============================
prompt
create sequence S_SC_BMGZLMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_BOM
prompt ==========================
prompt
create sequence S_SC_BOM
minvalue 1
maxvalue 999999999999999999999999999
start with 61
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_DRAWMATERIAL
prompt ===================================
prompt
create sequence S_SC_DRAWMATERIAL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_DRAWMATERIALDETAIL
prompt =========================================
prompt
create sequence S_SC_DRAWMATERIALDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_FQJHMX
prompt =============================
prompt
create sequence S_SC_FQJHMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_FQJHWL
prompt =============================
prompt
create sequence S_SC_FQJHWL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GRGZ
prompt ===========================
prompt
create sequence S_SC_GRGZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GRGZL
prompt ============================
prompt
create sequence S_SC_GRGZL
minvalue 1
maxvalue 9999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GRGZLMX
prompt ==============================
prompt
create sequence S_SC_GRGZLMX
minvalue 1
maxvalue 99999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GRGZRY
prompt =============================
prompt
create sequence S_SC_GRGZRY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GXFD
prompt ===========================
prompt
create sequence S_SC_GXFD
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GYLX
prompt ===========================
prompt
create sequence S_SC_GYLX
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GYLXLX
prompt =============================
prompt
create sequence S_SC_GYLXLX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GYLXMX
prompt =============================
prompt
create sequence S_SC_GYLXMX
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GYMC
prompt ===========================
prompt
create sequence S_SC_GYMC
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GZZ
prompt ==========================
prompt
create sequence S_SC_GZZ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GZZGZL
prompt =============================
prompt
create sequence S_SC_GZZGZL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GZZGZLMX
prompt ===============================
prompt
create sequence S_SC_GZZGZLMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GZZGZLRY
prompt ===============================
prompt
create sequence S_SC_GZZGZLRY
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_GZZX
prompt ===========================
prompt
create sequence S_SC_GZZX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_JGD
prompt ==========================
prompt
create sequence S_SC_JGD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_JGDMX
prompt ============================
prompt
create sequence S_SC_JGDMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_JGDWL
prompt ============================
prompt
create sequence S_SC_JGDWL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_JH
prompt =========================
prompt
create sequence S_SC_JH
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_JHMX
prompt ===========================
prompt
create sequence S_SC_JHMX
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_KHBOM
prompt ============================
prompt
create sequence S_SC_KHBOM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_RECEIVEPROD
prompt ==================================
prompt
create sequence S_SC_RECEIVEPROD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_RECEIVEPRODDETAIL
prompt ========================================
prompt
create sequence S_SC_RECEIVEPRODDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_RWD
prompt ==========================
prompt
create sequence S_SC_RWD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_RWDMX
prompt ============================
prompt
create sequence S_SC_RWDMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_SCNL
prompt ===========================
prompt
create sequence S_SC_SCNL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_SJBOM
prompt ============================
prompt
create sequence S_SC_SJBOM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_TRACK_BILL
prompt =================================
prompt
create sequence S_SC_TRACK_BILL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_TRACK_DETAIL
prompt ===================================
prompt
create sequence S_SC_TRACK_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_TRACK_DISPART
prompt ====================================
prompt
create sequence S_SC_TRACK_DISPART
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_TRACK_PROC
prompt =================================
prompt
create sequence S_SC_TRACK_PROC
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_TRACK_TYPE
prompt =================================
prompt
create sequence S_SC_TRACK_TYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_WJGJG
prompt ============================
prompt
create sequence S_SC_WJGJG
minvalue 1
maxvalue 999999999999999999999999999
start with 181
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_WLXQJH
prompt =============================
prompt
create sequence S_SC_WLXQJH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SC_WLXQJHMX
prompt ===============================
prompt
create sequence S_SC_WLXQJHMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SP_JL
prompt =========================
prompt
create sequence S_SP_JL
minvalue 1
maxvalue 999999999999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence S_SP_JLMX
prompt ===========================
prompt
create sequence S_SP_JLMX
minvalue 1
maxvalue 999999999999999999999999999
start with 81
increment by 1
cache 20;

prompt
prompt Creating sequence S_SP_XM
prompt =========================
prompt
create sequence S_SP_XM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SP_XMMX
prompt ===========================
prompt
create sequence S_SP_XMMX
minvalue 1
maxvalue 999999999999999999999999999
start with 742
increment by 1
cache 20;

prompt
prompt Creating sequence S_SP_XMTSMX
prompt =============================
prompt
create sequence S_SP_XMTSMX
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_SYSTEMPARAM
prompt ===============================
prompt
create sequence S_SYSTEMPARAM
minvalue 1
maxvalue 999999999999999999999999999
start with 43
increment by 1
cache 20;

prompt
prompt Creating sequence S_WB
prompt ======================
prompt
create sequence S_WB
minvalue 1
maxvalue 999999999999999999999999999
start with 3
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_AREA_CAR
prompt ===============================
prompt
create sequence S_XS_AREA_CAR
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_AREA_PRICE
prompt =================================
prompt
create sequence S_XS_AREA_PRICE
minvalue 1
maxvalue 9999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_DJSZ
prompt ===========================
prompt
create sequence S_XS_DJSZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_DRIVER
prompt =============================
prompt
create sequence S_XS_DRIVER
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_FUND_ITEM
prompt ================================
prompt
create sequence S_XS_FUND_ITEM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_HT
prompt =========================
prompt
create sequence S_XS_HT
minvalue 1
maxvalue 999999999999999999999999999
start with 181
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_HTHW
prompt ===========================
prompt
create sequence S_XS_HTHW
minvalue 1
maxvalue 999999999999999999999999999
start with 141
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_JJ
prompt =========================
prompt
create sequence S_XS_JJ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_JJGSSZ
prompt =============================
prompt
create sequence S_XS_JJGSSZ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_JJJSGS
prompt =============================
prompt
create sequence S_XS_JJJSGS
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_JJZB
prompt ===========================
prompt
create sequence S_XS_JJZB
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_KHDJXS
prompt =============================
prompt
create sequence S_XS_KHDJXS
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_KHXYED
prompt =============================
prompt
create sequence S_XS_KHXYED
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_TD
prompt =========================
prompt
create sequence S_XS_TD
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_TDHW
prompt ===========================
prompt
create sequence S_XS_TDHW
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_TDYJ
prompt ===========================
prompt
create sequence S_XS_TDYJ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_TRANSPORT
prompt ================================
prompt
create sequence S_XS_TRANSPORT
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_TRANS_DETAIL
prompt ===================================
prompt
create sequence S_XS_TRANS_DETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_XS_WZDJ
prompt ===========================
prompt
create sequence S_XS_WZDJ
minvalue 1
maxvalue 999999999999999999999999999
start with 41
increment by 1
cache 20;

prompt
prompt Creating sequence S_YH
prompt ======================
prompt
create sequence S_YH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_YHZH
prompt ========================
prompt
create sequence S_YHZH
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_ADMINICLECHECK
prompt =====================================
prompt
create sequence S_ZL_ADMINICLECHECK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_BUYCHECK
prompt ===============================
prompt
create sequence S_ZL_BUYCHECK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_BUYCHECKDETAIL
prompt =====================================
prompt
create sequence S_ZL_BUYCHECKDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CERTIFIEDCARD
prompt ====================================
prompt
create sequence S_ZL_CERTIFIEDCARD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CHECKITEM
prompt ================================
prompt
create sequence S_ZL_CHECKITEM
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CHECKLEVEL
prompt =================================
prompt
create sequence S_ZL_CHECKLEVEL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CHECKMETHOD
prompt ==================================
prompt
create sequence S_ZL_CHECKMETHOD
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CHEMICAL
prompt ===============================
prompt
create sequence S_ZL_CHEMICAL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_CHEMICALDETAIL
prompt =====================================
prompt
create sequence S_ZL_CHEMICALDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_FACIES
prompt =============================
prompt
create sequence S_ZL_FACIES
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_NEWPROVIDER
prompt ==================================
prompt
create sequence S_ZL_NEWPROVIDER
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_PROCESSCHECK
prompt ===================================
prompt
create sequence S_ZL_PROCESSCHECK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_PROCESSDETAIL
prompt ====================================
prompt
create sequence S_ZL_PROCESSDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_PRODCHECK
prompt ================================
prompt
create sequence S_ZL_PRODCHECK
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZL_PRODCHECKDETAIL
prompt ======================================
prompt
create sequence S_ZL_PRODCHECKDETAIL
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence S_ZXWH
prompt ========================
prompt
create sequence S_ZXWH
minvalue 1
maxvalue 999999999999999999999999999
start with 265
increment by 1
cache 20;

prompt
prompt Creating sequence TAG_REALLY_SEQ
prompt ================================
prompt
create sequence TAG_REALLY_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence TRYOUT_APPLY_SEQ
prompt ==================================
prompt
create sequence TRYOUT_APPLY_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence TRYOUT_REPORT_SEQ
prompt ===================================
prompt
create sequence TRYOUT_REPORT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence TRYOUT_SEQ
prompt ============================
prompt
create sequence TRYOUT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence USER_ADMINUSER_SEQ
prompt ====================================
prompt
create sequence USER_ADMINUSER_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 320
increment by 1
cache 20;

prompt
prompt Creating sequence VOTE_ITEM_SEQ
prompt ===============================
prompt
create sequence VOTE_ITEM_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence VOTE_SUBJECT_SEQ
prompt ==================================
prompt
create sequence VOTE_SUBJECT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 21
increment by 1
cache 20;

prompt
prompt Creating sequence ZIPCODE_MAP_SEQ
prompt =================================
prompt
create sequence ZIPCODE_MAP_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 2961
increment by 1
cache 20;

prompt
prompt Creating view BILL_BUY_INVOICE_EDIT
prompt ===================================
prompt
CREATE OR REPLACE VIEW BILL_BUY_INVOICE_EDIT AS
SELECT
       a.cgfpid,a.dwtxid,a.jsfsid,a.deptid,a.personid,a.fphm,a.kprq,a.fpzl,a.dz
       ,a.sh,a.khh,a.zh,a.bz,a.czrq,a.czyid,a.czy,a.zt,a.ztms,a.fgsid,a.sprid,a.sjhm,a.isrefer,
       b.sl,b.hsdj,b.wsdj,b.je,b.zzsl,b.se,b.jshj,b.cpid,
       c.cpbm,(c.pm||c.gg)product,d.dwmc,e.xm,f.mc,g.sxz,c.jldw,h.jsfs
FROM cw_cgfp a,cw_cgfpmx b,kc_dm c,dwtx d,emp e,bm f,kc_dmsx g,jsfs h
WHERE a.cgfpid=b.cgfpid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND a.personid=e.personid
AND a.deptid=f.deptid
AND b.dmsxid=g.dmsxid(+)
AND a.jsfsid=h.jsfsid(+)
--采购发票打印;

prompt
prompt Creating view BILL_BUY_ORDER_EDIT
prompt =================================
prompt
CREATE OR REPLACE VIEW BILL_BUY_ORDER_EDIT AS
SELECT k."HTID",k."FGSID",k."HTBH",k."HTRQ",k."KSRQ",k."JSRQ",k."DWMC",k."KHLX",k."MC",k."XM",k."QDDD",k."WBMC",k."HL",k."CPBM",k."PM",k."GG",k."SL",k."JLDW",k."DJ",k."JE",k."YBJE",k."JHRQ",k."GYSZYH",k."BZ",k."SJJHL",k."SXZ",k."CZY",k."SPRID",k."SQBH", l.xm spr
FROM(
SELECT a.htid, a.fgsid, a.htbh, a.htrq, a.ksrq, a.jsrq, e.dwmc, a.khlx, f.mc, d.xm, a.qddd, g.mc wbmc,g.hl,
        c.cpbm, c.pm, c.gg, b.sl, c.jldw, b.dj, b.je, b.ybje,b.jhrq,b.gyszyh,
       b.bz,b.sjjhl,j.sxz, a.czy, a.sprid,
       (SELECT h.sqbh  FROM cg_sqd h, cg_sqdhw i WHERE h.cgsqdid=i.cgsqdid AND i.cgsqdhwid=b.cgsqdhwid) sqbh
FROM cg_ht a, cg_hthw b, kc_dm c, emp d, dwtx e, bm f, wb g, kc_dmsx j
WHERE a.htid=b.htid AND b.cpid = c.cpid AND a.personid = d.personid(+) AND a.deptid=f.deptid(+)
AND a.dwtxid=e.dwtxid(+) AND a.wbid=g.wbid(+) AND b.dmsxid=j.dmsxid(+)
) k, emp l
WHERE k.sprid=l.personid(+)
--采购合同单据打印试图;

prompt
prompt Creating view BILL_CONSTRACT_INSTORE_EDIT
prompt =========================================
prompt
CREATE OR REPLACE VIEW BILL_CONSTRACT_INSTORE_EDIT AS
SELECT a.sfdjid,
       a.sfdjdh,   --采购入库单号
       a.sfrq,    --收发日期
       d.ckmc,    --仓库名称
       c.mc AS bmmc,      --部门名称
       a.dwtxid,  --单位通信id,即:供应商id
       e.dwmc,    --供应商名称
       a.khlx,    --客户类型
       f.lbmc,    --单据类型
       g.jsfs,    --结算方式
       a.jsr,     --经手人
       (
        SELECT  e.jhdbm
        FROM
        cg_ht c,
        cg_hthw d,
        cg_htjhd e,
        cg_htjhdhw f
        WHERE a.sfdjid = b.sfdjid
              AND b.wjid = f.jhdhwid
              AND f.hthwid = d.hthwid
              AND d.htid = c.htid
              AND f.jhdid = e.jhdid
       ) AS jhdbm, --进货单编码.即页面上的 单据号
       (
        SELECT  c.htbh
        FROM
        cg_ht c,
        cg_hthw d,
        cg_htjhd e,
        cg_htjhdhw f
        WHERE a.sfdjid = b.sfdjid
              AND b.wjid = f.jhdhwid
              AND f.hthwid = d.hthwid
              AND d.htid = c.htid
              AND f.jhdid = e.jhdid
       ) AS htbh, --合同编号
       (
        SELECT g.cpbm
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS cpbm,
       (
        SELECT g.pm
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS pm,
       (
        SELECT g.gg
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS gg,  --产品编码, 品名, 规格等
       (
        SELECT g.jldw
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS jldw,  --产品编码, 品名, 规格等
       b.ph,      --批号
       b.hssl,    --换算数量
       b.sl,      --数量
       b.dj,      --单价
       b.je,      --金额
       h.mc AS kwmc,      --库存名称
       (
        SELECT h.sxz
        FROM  kc_dmsx h --物资规格属性 (
        WHERE h.dmsxid = b.dmsxid
              AND b.cpid = h.cpid
       ) AS wzggsx, --物资规格属性
       a.zdr,    --制单人
       a.bz,     --备注
       a.fgsid   --分公司id
FROM
     kc_sfdj a,
     kc_sfdjmx b,
     bm c,
     kc_ck d, --仓库设置 (
     dwtx e, --往来单位通信录 (
     kc_sfdjlb f, --收发单据类别 (
     jsfs g, --结算方式 (
     kc_kw h --库位设置 (
WHERE a.sfdjid = b.sfdjid
      AND a.storeid = d.storeid(+)
      AND a.deptid = c.deptid(+)
      AND a.dwtxid = e.dwtxid(+)
      AND a.sfdjlbID = f.sfdjlbID(+)
      AND a.jsfsid = g.jsfsid(+)
      AND b.kwid = h.kwid(+)
      AND a.djxz = 1 --采购入库单;

prompt
prompt Creating view VW_KC_DM
prompt ======================
prompt
CREATE OR REPLACE VIEW VW_KC_DM AS
SELECT CPID, WZLBID, CPBM, ZJM, PM, GG, (a.pm ||' '||a.gg) product,
       TH, ABC, JLDW, HSDW, HSBL, JHDJ, CHXZ, TQQ, BZ, ISPROPS,
       ISSALE, JJFF, MAXSL, MINSL, ISDELETE, XGR, TXM, a.ztqq, a.deptid, a.storeid,
       a.chlbid, a.scydw, a.scdwgs, a.isbatchno
FROM kc_dm a
--提取物资类别和品名规格材质;

prompt
prompt Creating view BILL_LADING_WRAPPER_PRINT
prompt =======================================
prompt
CREATE OR REPLACE VIEW BILL_LADING_WRAPPER_PRINT AS
SELECT a.tdbh,a.tdrq,a.tdid,a.czy,
       e.dwmc,f.ckmc,d.htbh,h.jsfs,
       t.product,b.sl
FROM xs_td a,xs_tdhw b,xs_hthw c,xs_ht d,dwtx e,kc_ck f,emp g,jsfs h,vw_kc_dm t
WHERE a.tdid=b.tdid
AND b.tdhwid=c.hthwid
AND c.htid=d.htid
AND a.dwtxid=e.dwtxid
AND a.storeid=f.storeid
AND a.personid=g.personid
AND a.jsfsid=h.jsfsid
AND b.cpid=t.cpid;

prompt
prompt Creating view BILL_OUTPUTLIST_EDIT
prompt ==================================
prompt
CREATE OR REPLACE VIEW BILL_OUTPUTLIST_EDIT AS
SELECT
       a.sfdjdh, -- 收发单据号
       a.sfrq, -- 收发日期
       e.ckmc,    --仓库名称
       f.mc AS bmmc,      --部门名称
       g.dwmc,    --供应商名称
       a.khlx, --客户类型
       a.jsr, --经手人
       i.jsfs,    --结算方式
       j.lbmc,    --单据类型
       a.bz, --备注
       c.tdbh , --提单编号
       n.htbh, --销售合同号
       k.cpbm, --产品编码
       k.pm,   --品名
       k.gg,   --规格
       k.jldw, --计量单位
       l.sxz AS wzggsx,  --规格属性
       b.sl,   --数量
       b.hssl, --换算数量
       b.ph,   --批号
       m.mc AS kwmc, --库位名称
       b.bz AS mxbz, --备注
       a.zdr, --制单人
       a.sprid, --审批人
       a.fgsid,    --分公司id
       a.sfdjid    --收发单据id
FROM
     kc_sfdj a, --收发单据 (kc_sfdj)
     kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
     xs_td c, --销售提单 (xs_td)
     xs_tdhw d, --销售提单货物 (xs_tdhw)
     kc_ck e, --仓库设置 (
     bm f, --部门 (
     dwtx g, -- 往来单位通信录 (
     emp h, --人员信息 (emp) 主要想取出经手人
     jsfs i, --结算方式 (
     kc_sfdjlb j, --收发单据类别 (
     kc_dm k, --库存代码
     kc_dmsx l, --代码属性
     kc_kw m, --库位设置 (
     xs_ht n, --销售合同
     xs_hthw o --销售合同货物 (
WHERE
      a.sfdjid = b.sfdjid
      AND a.storeid = e.storeid(+)
      AND a.deptid = f.deptid(+)
      AND a.dwtxid = g.dwtxid(+)
      AND a.jsfsid = i.jsfsid(+)
      AND a.sfdjlbid = j.sfdjlbid(+)
      AND b.wjid = d.tdhwid(+)
      AND d.hthwid = o.hthwid(+)
      AND o.htid = n.htid(+)
      AND b.cpid = k.cpid(+)
      AND b.dmsxid = l.dmsxid(+)
      AND b.kwid = m.kwid(+)
      AND a.djxz = 2
--销售出库单单据打印视图;

prompt
prompt Creating view BILL_PROVIDE_CORP_LETTER
prompt ======================================
prompt
CREATE OR REPLACE VIEW BILL_PROVIDE_CORP_LETTER AS
SELECT a.htid, a.fgsid, a.htbh, a.htrq, d.dwmc, a.qddd,
        c.cpbm, c.pm, c.gg, b.sl, c.jldw, b.dj, b.je, b.ybje,b.jhrq,b.gyszyh,
       b.bz,b.sjjhl, (nvl(b.sl,0)-nvl(b.sjjhl,0)) wjsl, e.sxz,c.hsdw,
       to_date(to_char(SYSDATE,'YYYY_MM_DD'),'YYYY_MM_DD')-to_date('2004-03-01','YYYY_MM_DD') tqts,
       to_char(SYSDATE,'YYYY_MM_DD') dqrq
FROM cg_ht a, cg_hthw b, kc_dm c, dwtx d, kc_dmsx e
WHERE a.htid=b.htid AND b.cpid = c.cpid AND a.dwtxid=d.dwtxid AND b.dmsxid=e.dmsxid(+)
--催货涵打印试图;

prompt
prompt Creating view BILL_RECEIVEMATERAIL_EDIT
prompt =======================================
prompt
CREATE OR REPLACE VIEW BILL_RECEIVEMATERAIL_EDIT AS
SELECT "ID","HANDLEPERSON","BZ","DRAWCODE","STATE","CREATOR","FILIALEID","DRAWDATE","DJLX","CKMC","BMMC","XM","LBMC","NETNUM","DYNESIDE","HOTSIDE","CHECKOR","CHECKRESULT","YTMC","JGDH","CPBM","PM","GG","JLDW","SCYDW","HSDW","WZGGSX","HSSL","SL","SCYSL","PH","KWMC","MXBZ","DRAWID" FROM
(
  SELECT  a.drawid id, a.handleperson, a.memo bz, a.drawcode,a.state,a.creator,a.filialeid,
  a.drawdate, decode(a.drawtype, 1, '领料','退料') djlx, b.ckmc, c.mc bmmc, d.xm, e.lbmc,
  a.netnum, a.dyneside, a.hotside, a.checkor, a.checkresult, f.ytmc
  FROM sc_drawmaterial a, kc_ck b,bm c, emp d,kc_sfdjlb e, kc_csdjyt f
  WHERE a.storeid = b.storeid AND   a.deptid = c.deptid AND   a.sfdjlbid = e.sfdjlbid(+)
  AND   a.approveid = d.personid(+) AND a.ytid=f.ytid(+)
) a, --生产领料单打印主表资料选取
(
SELECT
(SELECT jgdh FROM sc_jgd d WHERE d.jgdid = f.jgdid) jgdh,  --生产加工单号
  k.cpbm, k.pm,k.gg, k.jldw, k.scydw, k.hsdw, l.sxz AS wzggsx, b.drawbignum hssl,
  b.drawnum sl, b.producenum scysl, b.batchno ph,  m.mc AS kwmc, b.memo AS mxbz, b.drawid
  FROM sc_drawmaterialdetail b, sc_jgdmx f, kc_dm k, kc_dmsx l, kc_kw m
  WHERE  b.jgdmxid = f.jgdmxid(+)
  AND   b.cpid = k.cpid
  AND   b.dmsxid = l.dmsxid(+)
  AND   b.kwid = m.kwid(+)
) b
WHERE a.id = b.drawid---生产领料单;

prompt
prompt Creating view BILL_SALE_INVOICE_EDIT
prompt ====================================
prompt
CREATE OR REPLACE VIEW BILL_SALE_INVOICE_EDIT AS
SELECT
       a.xsfpid,a.dwtxid,a.jsfsid,a.deptid,a.personid,a.fphm,a.kprq,a.fpzl,a.dz
       ,a.sh,a.khh,a.zh,a.bz,a.czrq,a.czyid,a.czy,a.zt,a.ztms,a.fgsid,a.hkrq,a.sprid,a.sjhm,a.isrefer,
       b.sl,b.hsdj,b.wsdj,b.je,b.zzsl,b.se,b.jshj,b.cpid,
       c.cpbm,(c.pm||c.gg)product,d.dwmc,e.xm,f.mc,g.sxz,c.jldw,h.jsfs
FROM cw_xsfp a,cw_xsfpmx b,kc_dm c,dwtx d,emp e,bm f,kc_dmsx g,jsfs h
WHERE a.xsfpid=b.xsfpid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND a.personid=e.personid
AND a.deptid=f.deptid
AND b.dmsxid=g.dmsxid(+)
AND a.jsfsid=h.jsfsid(+)
--销售发票打印;

prompt
prompt Creating view VW_KC_DM_EXIST
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_KC_DM_EXIST AS
SELECT CPID, WZLBID, CPBM, ZJM, PM, GG, (a.pm ||' '||a.gg) product,
       TH, ABC, JLDW, HSDW, HSBL, JHDJ, CHXZ, TQQ, BZ, ISPROPS, CHLBID,
       ISSALE, JJFF, MAXSL, MINSL, ISDELETE, XGR, TXM, a.ztqq, a.deptid, a.storeid,
       a.scydw, a.scdwgs, a.isbatchno
FROM kc_dm a WHERE a.isdelete = 0
--剔除已经删除记录的物资;

prompt
prompt Creating view VW_XS_WZDJ
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_XS_WZDJ AS
SELECT k.wzdjid, k.xsjzj, k.xstcl, k.hkts, k.hktcl, k.fgsid, nvl(k.xsj, k.xsjzj) xsj, k.xsdj, nvl(k.isnet,0) isnet,
       w.cpid, w.cpbm, w.pm, w.gg, w.product, w.isprops, --品名规格
       w.jldw, w.zjm, w.th, w.jhdj, w.hsbl, w.txm, w.ztqq, w.wzlbid, w.storeid, w.abc, w.chxz
FROM   xs_wzdj k, vw_kc_dm_exist w
WHERE  k.cpid = w.cpid AND w.issale=1
--k.isnet=1 OR (nvl(k.isnet,0)=0 AND nvl(k.shbj,0) = 1)--已经审批
--AND    k.cpid = kd.cpid
--销售合同选择物资视图;

prompt
prompt Creating view BILL_SALE_ORDER_EDIT
prompt ==================================
prompt
CREATE OR REPLACE VIEW BILL_SALE_ORDER_EDIT AS
SELECT a.htid,         --合同ID
       a.htbh,         --合同编号
       a.htrq,         --合同日期
       a.ksrq,         --合同有效期始
       a.jsrq,         --合同结束日期
       a.dwtxid,       --销货商ID
       e.dwmc,         --销货商名称
       a.khlx,         --客户类型
       a.personid,     --业务员ID
       d.xm ywyxm,     --业务员姓名
       a.qddd,         --签订地点
       a.deptid,       --部门ID
       c.mc AS bmmc,   --部门名称
       f.cpbm,         --产品编码
       f.product,      --产品名称
       g.sxz,          --规格属性值
       b.hssl,         --换算数量
       b.sl,           --数量
       f.jldw,         --计量单位
       b.skdsl,        --已开单数量
       b.dj,           --单价
       b.jje,          --金额
       b.jzj,          --基准价
       b.cjtcl,        --差价提成率
       b.jxts,         --计息天数
       b.hlts,         --回笼天数
       b.hltcl,        --回笼提成率
       b.jhrq,         --交货日期
       b.bz ,          --备注
       a.qtxx,         --其他信息
       a.czrq ,        --登记日期
       a.czy,          --制单人
       a.fgsid,        --分公司id
       (
        SELECT xm
        FROM emp j
        WHERE
        a.sprid = j.personid
        )
        AS sprid      --审批人
FROM
     xs_ht a,       --合同主表
     xs_hthw b,     --合同货物明细
     bm c,          --部门
     emp d,         --业务员
     dwtx e,        --往来单位通信录
     vw_xs_wzdj f,  --通过wzdjid关联产品信息
     kc_dmsx g      --关联规格属性
WHERE a.htid=b.htid
      AND a.deptid=c.deptid
      AND a.personid=d.personid
      AND a.dwtxid = e.dwtxid
      AND b.wzdjid=f.wzdjid
      AND b.dmsxid=g.dmsxid
--销售合同打印;

prompt
prompt Creating view BILL_SALE_TD_EDIT
prompt ===============================
prompt
CREATE OR REPLACE VIEW BILL_SALE_TD_EDIT AS
SELECT a.tdid,a.personid,a.deptid,a.dwt_dwtxid,a.hkrq,a.zsl,a.ddfy,a.yf,a.djlx,a.ztms,a.dwtxid,
       a.czyid,a.hkts,a.jsfsid,a.tdbh,a.tdrq,a.zt,a.czrq,a.czy,a.zje,a.storeid,a.fgsid,
       a.sprid,a.khlx,a.sendmodeid,a.isrefer,a.dz,a.lxr,a.dh,a.yfdj,
       b.cpid,b.hthwid,b.wzdjid,b.hssl,b.sl,b.xsj,b.xsje,b.zk,b.jje,b.bz,b.dj,
       c.pm,c.gg,d.dwmc,d.dwdm,e.xm,f.mc,g.sxz,h.jsfs,j.ckmc,k.sendmode,
       (SELECT dwmc FROM dwtx x WHERE x.dwtxid=a.dwt_dwtxid )dw
FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,emp e,bm f,kc_dmsx g,
     jsfs h,kc_ck j,jc_sendmode k
WHERE a.tdid=b.tdid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND a.personid=e.personid
AND a.deptid=f.deptid
AND b.dmsxid=g.dmsxid(+)
AND a.jsfsid=h.jsfsid(+)
AND a.storeid=j.storeid(+)
AND a.sendmodeid=k.sendmodeid(+)
--销售提单打印(网面打印);

prompt
prompt Creating view BILL_SELFGAIN_EDIT
prompt ================================
prompt
CREATE OR REPLACE VIEW BILL_SELFGAIN_EDIT AS
SELECT "ID","HANDLEPERSON","BZ","RECEIVEDATE","STATE","CREATOR","FILIALEID","RECEIVECODE","CKMC","BMMC","XM","LBMC","JGDH","CPBM","PM","GG","JLDW","SCYDW","HSDW","WZGGSX","HSSL","SL","SCYSL","PH","KWMC","MXBZ","RECEIVEID" FROM
(
  SELECT  a.receiveid id, a.handleperson, a.memo bz, a.receivedate,a.state,a.creator,a.filialeid,
  a.receivecode, b.ckmc, c.mc bmmc, d.xm, e.lbmc
  FROM sc_receiveprod a, kc_ck b,bm c, emp d,kc_sfdjlb e
  WHERE a.storeid = b.storeid AND   a.deptid = c.deptid AND   a.sfdjlbid = e.sfdjlbid(+)
  AND   a.approveid = d.personid(+)
) a, --自制收货单据单据打印主表资料选取
(
SELECT
(SELECT jgdh FROM sc_jgd d WHERE d.jgdid = f.jgdid) jgdh,  --生产加工单号
  k.cpbm, k.pm,k.gg, k.jldw, k.scydw, k.hsdw, l.sxz AS wzggsx, b.drawbignum hssl,
  b.drawnum sl, b.producenum scysl, b.batchno ph,  m.mc AS kwmc, b.memo AS mxbz, b.receiveid
  FROM sc_receiveproddetail b, sc_jgdmx f, kc_dm k, kc_dmsx l, kc_kw m
  WHERE  b.jgdmxid = f.jgdmxid(+)
  AND   b.cpid = k.cpid
  AND   b.dmsxid = l.dmsxid(+)
  AND   b.kwid = m.kwid(+)
 ) b
WHERE a.id = b.receiveid--自制收货单;

prompt
prompt Creating view KC_DM_REPEAT
prompt ==========================
prompt
CREATE OR REPLACE VIEW KC_DM_REPEAT AS
SELECT a."GG",a."PM",a."CHLBID",a."CN",a."STOREID" FROM (
select t.gg,t.pm, t.chlbid,COUNT(*)cn,t.storeid from kc_dm t     GROUP BY t.gg,t.pm  ,t.chlbid  ,t.storeid
)a   WHERE a.cn>1;

prompt
prompt Creating view KC_WZMX
prompt =====================
prompt
CREATE OR REPLACE VIEW KC_WZMX AS
SELECT (fgsid ||'-'|| storeid ||'-'|| kwid ||'-'|| dmsxid ||'-'|| cpid ||'-'|| ph) wzmxid,
  fgsid, storeid, kwid, dmsxid, cpid, ph,
  SUM(nvl(srsl,0))-SUM(nvl(fcsl,0)) zl,   SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0)) hszl
FROM
(
  SELECT a.fgsid, a.storeid, b.kwid, b.dmsxid, b.cpid, b.ph, --b.wzmxid,
         decode(a.djxz, 1, b.sl,   7, b.sl,   9, b.sl, 0) srsl,
         decode(a.djxz, 1, b.hssl, 7, b.hssl, 9, b.hssl, 0) srhssl,
         decode(a.djxz, 2, b.sl, 0) fcsl,
         decode(a.djxz, 2, b.hssl, 0) fchssl
  FROM   kc_sfdj a, kc_sfdjmx b
  WHERE  a.sfdjid=b.sfdjid AND a.djxz IN(1,7,9,2)--1=合同入库单, 7=损溢单, 9=其他入库单, 2=销售出库单
  AND    a.isrefer = 1
  --(3=自制收货单5=外加工入库单)
  UNION ALL
  SELECT a1.filialeid, a1.storeid, b1.kwid, b1.dmsxid, b1.cpid, b1.batchno, --b1.wzmxid,
         b1.drawnum, b1.drawbignum, 0 fcsl, 0 fchssl
  FROM   sc_receiveprod a1, sc_receiveproddetail b1
  WHERE  a1.receiveid = b1.receiveid AND a1.isrefer = 1
  --4=生产领料单, 6=外加工发料单
  UNION ALL
  SELECT a2.filialeid, a2.storeid, b2.kwid, b2.dmsxid, b2.cpid, b2.batchno, --b2.wzmxid,
         0 srsl, 0 srhssl, b2.drawnum fcsl, b2.drawbignum fchssl
  FROM   sc_drawmaterial a2, sc_drawmaterialdetail b2
  WHERE  a2.drawid = b2.drawid AND a2.isrefer = 1
  --(-1 调入)
  --得到该段时间移库单调入数量--kc__storeid 调入仓库, kc__kwid 调入库位id
  UNION ALL
  SELECT a.fgsid, a.kc__storeid, b.kc__kwid, b.dmsxid, b.cpid, b.ph, --b.wzmxid,
         b.sl srsl, b.hssl srhssl, 0 fcsl, 0 fchssl
  FROM   kc_sfdj a, kc_sfdjmx b
  WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8 AND a.isrefer = 1
  --得到该段时间移库单调出数量 (8 调出)
  UNION ALL
  SELECT a.fgsid, a.storeid, b.kwid, b.dmsxid, b.cpid, b.ph, --b.wzmxid,
         0 srsl, 0 srhssl, b.sl fcsl, b.hssl fchssl
  FROM   kc_sfdj a, kc_sfdjmx b
  WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8 AND a.isrefer = 1
) t
GROUP BY fgsid, storeid, kwid, dmsxid, cpid, ph;

prompt
prompt Creating view KC_KCHZ
prompt =====================
prompt
CREATE OR REPLACE VIEW KC_KCHZ AS
SELECT a.fgsid, a.storeid, a.cpid, SUM(a.zl) kcsl, SUM(a.hszl) kchssl
FROM kc_wzmx a
GROUP BY a.fgsid, a.storeid, a.cpid
--仓库库存汇总视图代替kc_kchz表;

prompt
prompt Creating view KC_SL
prompt ===================
prompt
CREATE OR REPLACE VIEW KC_SL AS
SELECT a.cpid,SUM(nvl(a.kcsl,0))kcsl FROM KC_KCHZ a GROUP BY a.cpid
-- 产品的总库在数量
-- 销售排行榜;

prompt
prompt Creating view OTHER_KC_WZMX
prompt ===========================
prompt
CREATE OR REPLACE VIEW OTHER_KC_WZMX AS
SELECT cpid, fgsid, dwtxid, dmsxid,
  SUM(nvl(srsl,0))-SUM(nvl(fcsl,0)) zl,   SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0)) hszl
FROM
(
  SELECT a.fgsid, a.storeid,  b.dmsxid, b.cpid,  a.dwtxid,
         decode(a.djxz, 1, b.sl,   7, b.sl,   9, b.sl, 0) srsl,
         decode(a.djxz, 1, b.hssl, 7, b.hssl, 9, b.hssl, 0) srhssl,
         decode(a.djxz, 2, b.sl, 0) fcsl,
         decode(a.djxz, 2, b.hssl, 0) fchssl
  FROM   kc_other_sfdj a, kc_other_sfdjmx b
  WHERE  a.sfdjid=b.sfdjid AND a.djxz IN(1,7,9,2)--1=合同入库单, 7=损溢单, 9=其他入库单, 2=销售出库单
  --合同入库单
  UNION ALL
  SELECT a.fgsid, a.storeid,  b.dmsxid, b.cpid,  a.dwtxid,
         b.sl srsl,
         b.hssl srhssl,
         0 fcsl,
         0 fchssl
  FROM   xs_td a, xs_tdhw b
  WHERE  a.tdid=b.tdid AND a.zt IN(1,8)--合同入库单
) t
GROUP BY fgsid, dmsxid, cpid, dwtxid;

prompt
prompt Creating view OUTPUTLIST_EDIT_BILL
prompt ==================================
prompt
CREATE OR REPLACE VIEW OUTPUTLIST_EDIT_BILL AS
SELECT
       a.sfdjdh, -- 收发单据号
       a.sfrq, -- 收发日期
       e.ckmc,    --仓库名称
       f.mc AS bmmc,      --部门名称
       g.dwmc,    --供应商名称
       a.khlx, --客户类型
       i.jsfs,    --结算方式
       j.lbmc,    --单据类型
       a.bz, --备注
       c.tdbh , --提单编号
       n.htbh, --销售合同号
       k.cpbm, --产品编码
       k.pm,   --品名
       k.gg,   --规格
       k.jldw, --计量单位
       l.sxz AS wzggsx,  --规格属性
       b.sl,   --数量
       b.hssl, --换算数量
       b.ph,   --批号
       m.mc AS kwmc, --库位名称
       b.bz AS mxbz, --备注
       a.fgsid,    --分公司id
       a.sfdjid    --收发单据id
FROM
     kc_sfdj a, --收发单据 (kc_sfdj)
     kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
     xs_td c, --销售提单 (xs_td)
     xs_tdhw d, --销售提单货物 (xs_tdhw)
     kc_ck e, --仓库设置 (
     bm f, --部门 (
     dwtx g, -- 往来单位通信录 (
     emp h, --人员信息 (emp) 主要想取出经手人
     jsfs i, --结算方式 (
     kc_sfdjlb j, --收发单据类别 (
     kc_dm k, --库存代码
     kc_dmsx l, --代码属性
     kc_kw m, --库位设置 (
     xs_ht n, --销售合同
     xs_hthw o --销售合同货物 (
WHERE
      a.sfdjid = b.sfdjid
      AND a.storeid = e.storeid(+)
      AND a.deptid = f.deptid(+)
      AND a.dwtxid = g.dwtxid(+)
      AND a.jsfsid = i.jsfsid(+)
      AND a.sfdjlbid = j.sfdjlbid(+)
      AND b.wjid = d.tdhwid(+)
      AND d.hthwid = o.hthwid(+)
      AND o.htid = n.htid(+)
      AND b.cpid = k.cpid(+)
      AND b.dmsxid = l.dmsxid(+)
      AND b.kwid = m.kwid(+);

prompt
prompt Creating view REP_BUY_FP_DETAIL
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_BUY_FP_DETAIL AS
SELECT a.kprq, a.fphm, a.dwtxid, a.fgsid, a.deptid, a.personid,a.cgfpid,
       (CASE WHEN a.zt IN(0,1,9) THEN 0 ELSE 1 END) zt,
       b.cpid, b.sl, b.wsdj, b.je, b.hsdj, b.se, b.zzsl, b.jshj, b.gsl,b.gs,
       d.xm, e.dwmc, f.mc, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, e.sxz
FROM cw_cgfp a, cw_cgfpmx b, kc_dm c, emp d, dwtx e, bm f, kc_dmsx e
WHERE a.cgfpid=b.cgfpid AND b.cpid = c.cpid AND a.personid = d.personid(+)
AND a.dwtxid=e.dwtxid(+) AND a.deptid = f.deptid(+) AND b.dmsxid=e.dmsxid(+)
--采购发票明细帐报表试图;

prompt
prompt Creating view REP_BUY_JHD_DETAIL
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_BUY_JHD_DETAIL AS
SELECT a.jhrq, a.jhdbm, a.dwtxid, a.fgsid, a.deptid, a.personid, a.khlx, a.jhdid,
       (CASE WHEN a.zt IN (0,1,9) THEN 0 ELSE 1 END) zt,
       b.cpid, b.gyszyh, b.hthwid, b.sl, b.dj, b.je,b.dmsxid,
       d.xm, e.dwmc, f.mc, g.htbh, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw,i.sxz
FROM cg_htjhd a, cg_htjhdhw b, vw_kc_dm_exist c, emp d, dwtx e, bm f, cg_ht g, cg_hthw h, kc_dmsx i
WHERE a.jhdid=b.jhdid AND b.cpid = c.cpid AND a.personid = d.personid(+) AND h.htid=g.htid(+)
AND a.dwtxid=e.dwtxid(+) AND a.deptid = f.deptid(+) AND b.hthwid = h.hthwid(+) AND b.dmsxid=i.dmsxid(+)
--采购提货单明细帐报表试图;

prompt
prompt Creating view REP_BUY_LLD_DETAIL
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_BUY_LLD_DETAIL AS
SELECT a.drawdate, a.drawcode, a.dwtxid, a.filialeid, a.deptid, a.drawid,a.storeid,a.handleperson,
       (CASE WHEN a.state IN (0,1,9) THEN 0 ELSE 1 END) state,
       b.cpid, b.drawnum, b.drawprice, b.drawsum,b.dmsxid,h.ckmc,
       e.dwmc, f.mc,  c.cpbm, c.pm, c.gg, c.jldw, c.product, b.drawbignum, c.hsdw,i.sxz,a.isout
FROM sc_drawmaterial a, sc_drawmaterialdetail b, vw_kc_dm_exist c, dwtx e, bm f, kc_ck h,kc_dmsx i
WHERE a.drawid=b.drawid
AND b.cpid = c.cpid
AND a.dwtxid=e.dwtxid(+)
AND a.deptid = f.deptid(+)
AND b.dmsxid=i.dmsxid(+)
AND a.storeid=h.storeid(+)
AND a.isout=0
-----领料单报表视图;

prompt
prompt Creating view REP_BUY_ORDER_DETAIL
prompt ==================================
prompt
CREATE OR REPLACE VIEW REP_BUY_ORDER_DETAIL AS
SELECT a.fgsid, a.htbh, a.dwtxid, a.htrq, a.khlx, a.htid,
      (CASE WHEN a.zt IN(0,9,1) THEN 0 ELSE 1 END) zt,
       b.cpid, b.sl,b.sjjhl,b.sjrkl, (nvl(b.sl,0)-nvl(b.sjjhl,0)) wjhsl,(nvl(b.sl,0)-nvl(b.sjrkl,0)) wrksl,
        b.jhrq, b.dj, b.je, b.gyszyh, b.bz, e.sxz,
       c.dwmc, d.cpbm, d.pm, d.gg, d.jldw, d.hsdw, f.dqmc
FROM cg_ht a, cg_hthw b, dwtx c, vw_kc_dm_exist d, kc_dmsx e, dwdq f
WHERE a.htid=b.htid AND b.dmsxid=e.dmsxid(+) AND a.zt<>4
AND a.dwtxid=c.dwtxid AND b.cpid =d.cpid AND c.dqh=f.dqh
--采购合同明细报表(合同执行情况表);

prompt
prompt Creating view REP_BUY_PERFORM
prompt =============================
prompt
CREATE OR REPLACE VIEW REP_BUY_PERFORM AS
SELECT dwtxid,fgsid,htbh,htrq,htid,zsl,zje,zt,dwmc,dwdm,dqmc,areacode, (nvl(zsl,0)-nvl(zjhl,0)) wjhl,
       (nvl(zsl,0)-nvl(zrkl,0)) wrkl,zrkl,zjhl
FROM(
SELECT a.dwtxid, a.fgsid, a.htbh, a.htrq, a.htid, a.zsl,a.zje,
   (CASE WHEN a.zt IN(0,1,9) THEN 0 ELSE 8 END) zt,
   sum(nvl(b.sjrkl,0)) zrkl, SUM(nvl(b.sjjhl,0)) zjhl,
   c.dwmc, c.dwdm, d.dqmc, d.areacode
FROM cg_ht a, cg_hthw b, dwtx c, dwdq d
WHERE a.htid = b.htid AND c.dqh=d.dqh AND a.dwtxid=c.dwtxid  AND a.zt<>4
GROUP BY a.dwtxid, a.fgsid, a.htbh, a.htrq,c.dwmc, c.dwdm, d.dqmc,zt, a.htid,d.areacode,a.zsl,a.zje
) ORDER BY htbh
--采购合同汇总表;

prompt
prompt Creating view REP_BUY_TAX
prompt =========================
prompt
CREATE OR REPLACE VIEW REP_BUY_TAX AS
SELECT x.mon, SUM(x.je) cgje,SUM(x.cgse) cgse,SUM(x.jshj) jshj,SUM(nvl(x.gs,0)) gs, x.fgsid
FROM
(
SELECT to_char(a.kprq,'mm') mon, SUM(nvl(b.je,0)) je,
       SUM (nvl(b.se,0)) cgse, SUM(nvl(b.jshj,0)) jshj, SUM(nvl(b.gs,0)) gs,
       a.fgsid
FROM cw_cgfp a, cw_cgfpmx b
WHERE a.cgfpid=b.cgfpid AND to_char(a.kprq, 'YYYY')>=to_char(SYSDATE,'YYYY')
GROUP BY a.kprq, a.fgsid
) x
GROUP BY x.mon,x.fgsid
--采购进项税统计;

prompt
prompt Creating view REP_KC_BUY_MATERIAL_DETAIL
prompt ========================================
prompt
CREATE OR REPLACE VIEW REP_KC_BUY_MATERIAL_DETAIL AS
SELECT a.sfrq, --收发日期
       '采购入库单' AS lbmc, --类别名称 单据类型
       a.sfdjdh, --收发单据号
       a.sfdjid,
       a.bz, --备注
       b.sl, --sl 数量  损溢单：正(报溢),负(报损)
       b.dj, --单价
       b.je, --金额
       c.jhdj, -- 计划单价
       nvl(c.jhdj*b.sl, 0) jhje, --计划金额
       nvl(b.sl - c.jhdj*b.sl, 0) ci, -- 金额差异
       a.zt, --zt 状态 .主要来提供给已记帐,未记帐作为条件用的. 1, 8:记账. 0, 9:未记账
       c.cpbm, --产品编码 应该 对应 web界面上查询要求输入 存放代码 这一项
       a.fgsid --分公司id
FROM kc_sfdj a, --收发单据
     kc_sfdjmx b, --收发单据明细
     kc_dm c, -- 物资代码
     kc_sfdjlb d -- 收发单据类别
WHERE
      b.sfdjid = a.sfdjid
      AND b.djxz = 1 -- 合同入库单
      AND b.cpid = c.cpid
      AND c.jjff = 3     --04.03.17 15:47 新增 新增上计划单价法的产品条件. yjg
      AND a.sfdjlbid = d.sfdjlbid
--材料采购明细帐;

prompt
prompt Creating view REP_KC_LOW_STOCKS
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_KC_LOW_STOCKS AS
SELECT  a.cpbm, a.pm, a.gg, a.jldw, a.minsl, b.kcsl, b.fgsid,
       -(nvl(b.kcsl, 0) - nvl(a.minsl, 0)) ce
    FROM  kc_dm a, kc_kchz b
    WHERE nvl(b.kcsl, 0) - nvl(a.minsl, 0) < 0 AND a.cpid = b.cpid
--缺储存货列表;

prompt
prompt Creating view REP_KC_OVER_STOCKS
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_KC_OVER_STOCKS AS
SELECT a.cpbm, a.pm, a.gg, a.jldw, nvl(a.maxsl,0) maxsl, b.kcsl, b.fgsid,
       (nvl(b.kcsl,0)-nvl(a.maxsl,0)) ce
FROM   kc_dm a, kc_kchz b
WHERE  nvl(b.kcsl,0)-nvl(a.maxsl,0) > 0 AND a.cpid = b.cpid
--超储存货列表;

prompt
prompt Creating view REP_KC_STOCKS_COST_DIFF
prompt =====================================
prompt
CREATE OR REPLACE VIEW REP_KC_STOCKS_COST_DIFF AS
SELECT b.cpbm, b.pm, b.chlbid, --存货代码, 存货名称
       a.nf, a.yf, --年份, 月份
       nvl(a.syje, 0) syje, nvl(b.jhdj*a.sysl, 0) qcjh, nvl( nvl(a.syje, 0) - nvl(b.jhdj*a.sysl, 0), 0) qcci, --库存年结存表 (kc_kcnjc)表中的 上月数量, 物资代码表中的计划单价*上月数量
       nvl(a.sje, 0) sje, nvl(b.jhdj*a.ssl, 0) bqsrjh, nvl(nvl(a.sje, 0) - nvl(b.jhdj*a.ssl, 0), 0) bqsrci,   --本其收入.
       nvl((a.sje - b.jhdj*a.ssl)/b.jhdj*a.fsl*100, 0) bqcyl, --差异率= (本月实际-计划)/计划内*100
       nvl(a.fje, 0) fje, nvl(b.jhdj*a.fsl, 0 ) bqfcjh, nvl(a.fje - b.jhdj*a.fsl, 0) bqfcci,  --本其发出.
       nvl(a.jcje, 0) jcje, nvl(b.jhdj*a.jcsl, 0)qmjcjh, nvl( a.jcje - b.jhdj*a.jcsl, 0) qmjcci, -- 其末结存.
       sign(nvl(a.sje, 0) - nvl(b.jhdj*a.ssl, 0)) diffKinds, --目地是想要取出本其计划-本其实际的是正负还是零的结果 02.21 15:02
       a.fgsid
FROM kc_kcnjc a, --库存年结存表
     kc_dm b --物资代码表
WHERE a.cpid = b.cpid
--存货成本差异表;

prompt
prompt Creating view VW_KC_STOREBILL
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_KC_STOREBILL AS
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     a.djxz, a.isrefer, a.zt,     a.fgsid,
       decode(a.djxz, 1,'采购入库单', 7,'损益单', '其他入库单') djmc,
       b.rkdmxid, b.kwid,    b.dmsxid, b.cpid,  b.ph,     b.wzmxid,
       b.sl srsl, b.hssl srhssl, b.dj srdj, b.je srje,     NULL fcsl, NULL fchssl, NULL fcdj, NULL fcje
       --dafa
       , NULL bc,a.khlx
FROM   kc_sfdj a, kc_sfdjmx b
WHERE  a.sfdjid=b.sfdjid AND a.djxz IN(1,7,9)--1=合同入库单, 7=损溢单, 9=其他入库单
--(3=自制收货单5=外加工入库单)
UNION ALL
SELECT a1.receiveid,   a1.sfdjlbid, a1.ytid, a1.storeid, a1.deptid, a1.dwtxid,
       a1.receivecode, a1.receivedate, decode(a1.isout, 1, 5 ,3), a1.isrefer, a1.state,  a1.filialeid,
       decode(a1.isout, 1, '外加工入库单', '自制收货单') djmc,
       b1.receivedetailid, b1.kwid, b1.dmsxid, b1.cpid, b1.batchno, b1.wzmxid,
       b1.drawnum, b1.drawbignum, b1.drawprice, b1.drawsum srje, NULL fcsl, NULL fchssl, NULL fcdj, NULL fcje
       --dafa
       , a1.bc,null khlx
FROM   sc_receiveprod a1, sc_receiveproddetail b1
WHERE  a1.receiveid = b1.receiveid
--得到该时间段支出数据（销售出库单）
UNION ALL
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     a.djxz, a.isrefer, a.zt,     a.fgsid, decode(a.djxz, 2,'销售出库单', '其他出库单') djmc,
       b.rkdmxid, b.kwid,    b.dmsxid, b.cpid,  b.ph,     b.wzmxid,
       NULL srsl, NULL srhssl, NULL srdj, NULL srje,     b.sl fcsl, b.hssl fchssl, b.dj fcdj, b.je fcje
       --dafa
       , NULL bc,a.khlx
FROM   kc_sfdj a, kc_sfdjmx b
WHERE  a.sfdjid=b.sfdjid AND a.djxz IN(2,10)
--4=生产领料单, 6=外加工发料单
UNION ALL
SELECT a2.drawid,   a2.sfdjlbid, a2.ytid, a2.storeid, a2.deptid, a2.dwtxid,
       a2.drawcode, a2.drawdate, decode(a2.isout, 1, 6 ,4), a2.isrefer, a2.state,  a2.filialeid,
       decode(a2.isout, 1, '外加工发料单', '生产领料单') djmc,
       b2.drawdetailid, b2.kwid, b2.dmsxid, b2.cpid, b2.batchno, b2.wzmxid,
       NULL srsl, NULL srhssl, NULL srdj, NULL srje,     b2.drawnum fcsl, b2.drawbignum fchssl, b2.drawprice fcdj, b2.drawsum fcje
       --dafa
       , a2.bc,null khlx
FROM   sc_drawmaterial a2, sc_drawmaterialdetail b2
WHERE  a2.drawid = b2.drawid
--(-1 调入)
--得到该段时间移库单调入数量--kc__storeid 调入仓库, kc__kwid 调入库位id
UNION ALL
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.kc__storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     -1, a.isrefer, a.zt,     a.fgsid, '移库单' djmc,
       b.rkdmxid, b.kc__kwid, b.dmsxid, b.cpid,  b.ph, b.wzmxid,
       b.sl srsl, b.hssl srhssl, b.dj srdj, b.je srje,     NULL fcsl, NULL fchssl, NULL fcdj, NULL fcje
       --dafa
       , NULL bc,a.khlx
FROM   kc_sfdj a, kc_sfdjmx b
WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8
--得到该段时间移库单调出数量 (8 调出)
UNION ALL
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     8, a.isrefer, a.zt,     a.fgsid, '移库单' djmc,
       b.rkdmxid, b.kwid,    b.dmsxid, b.cpid,  b.ph, b.wzmxid,
       NULL srsl, NULL srhssl, NULL srdj, NULL srje,     b.sl fcsl, b.hssl fchssl, b.dj fcdj, b.je fcje
       --dafa
       , NULL bc,a.khlx
FROM   kc_sfdj a, kc_sfdjmx b
WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8;

prompt
prompt Creating view REP_KC_STOCKS_PROD_DETAIL
prompt =======================================
prompt
CREATE OR REPLACE VIEW REP_KC_STOCKS_PROD_DETAIL AS
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl,dmsxid,sxz,ph,
       SUM(nvl(kcsl,0)) kcsl,SUM(nvl(wjzssl,0)) wjzssl,SUM(nvl(wjzfsl,0)) wjzfsl,
       SUM(nvl(hjsl,0)) hjsl
FROM(
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,dmsxid,sxz,ph,
       kcsl,wjzssl,wjzfsl,kchssl,wjzshssl,wjzfhssl,hsbl,
       (nvl(kcsl,0)+nvl(wjzssl,0)-nvl(wjzfsl,0)) hjsl,(nvl(kchssl,0)+nvl(wjzshssl,0)-nvl(wjzfhssl,0)) hjhssl
FROM(
SELECT a.storeid, a.sfrq,a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,a.dmsxid,c.sxz,a.ph,
       b.cpbm,b.pm,b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,nvl(a.srsl,0)-nvl(a.fcsl,0) kcsl,
       NULL wjzssl, NULL wjzfsl, nvl(a.srhssl,0)-nvl(a.fchssl,0) kchssl, NULL wjzshssl,NULL wjzfhssl
FROM vw_kc_storebill a,kc_dm b,kc_dmsx c
WHERE a.cpid=b.cpid AND a.dmsxid=c.dmsxid(+) AND a.zt IN(2,8)
UNION ALL
SELECT a.storeid,a.sfrq, a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,a.dmsxid,c.sxz,a.ph,
       b.cpbm,b.pm, b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,NULL kcsl,
       a.srsl,a.fcsl, NULL kchssl, nvl(a.srhssl,0) wjzshssl, nvl(a.fchssl,0) wjzfhssl
FROM vw_kc_storebill a,kc_dm b,kc_dmsx c
WHERE a.cpid=b.cpid AND a.dmsxid=c.dmsxid(+) AND  a.zt<>2 AND a.zt<>8
)
) GROUP BY storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl,dmsxid,sxz,ph
ORDER BY cpbm
/**
SELECT a.wzmxid, a.ph, c.sxz, a.storeid, a.zl, b.wzlbid, b.chlbid, a.fgsid,
       b.cpbm, b.pm, b.gg, b.jldw, a.dmsxid, a.cpid
FROM kc_wzmx a, kc_dm b, kc_dmsx c
WHERE a.cpid=b.cpid AND a.dmsxid=c.dmsxid(+)
*/
--存货不同规格属性不同批号明细表;

prompt
prompt Creating view REP_KC_USE_MATERIAL_DETAIL
prompt ========================================
prompt
CREATE OR REPLACE VIEW REP_KC_USE_MATERIAL_DETAIL AS
SELECT c.ytmc, c.ytid, a.sfrq, f.cpbm, a.djxz, a.sfdjid,
       d.lbmc, a.sfdjdh, --收发单据号
       e.ckmc, e.storeid, nvl(b.xhsl,0) xhsl, nvl(b.dj, 0) dj, nvl(b.je, 0) je, a.fgsID
FROM kc_sfdj a, kc_sfdjmx b,
     kc_csdjyt c, kc_sfdjlb d,
     kc_ck e,  kc_dm f
WHERE   a.sfdjID = b.sfdjID  --收发单据明细表中的收发单据ID = 收发单据表中的收发单据ID
  and a.SFDJLBID = d.SFDJLBID(+)  --收发单据表.收发单据类别ID = 收发单据类别表.收发单据类别ID
  and a.YTID = c.YTID  --用途ID = 用途ID
  AND a.storeid = e.storeid(+)
  and b.cpid = f.cpid
  and a.djxz in (4, 6) --生产领料单, 外包加工单
  --and  b.CPID = 指定的查询条件
  --and a.fgsID = 分公司ID
--材料耗用明细表;

prompt
prompt Creating view REP_PRODUCT
prompt =========================
prompt
CREATE OR REPLACE VIEW REP_PRODUCT AS
SELECT a.cpbm, a.pm, a.gg, a.wzlbid, a.chxz, a.chlbid, a.storeid, a.deptid, a.scydw, a.scdwgs,
       a.jldw, a.hsdw, a.hsbl, a.jhdj, a.jjff, a.abc, a.th,a.bz, a.isprops, a.issale,
       a.isdelete, a.maxsl, a.minsl, a.txm,
       b.mc wzlbmc, c.chmc, decode(a.jjff, 1, '加权平均法', 2, '移动平均法', 3,'计划单价法') ff,
       d.mc bmmc, e.ckmc,
       decode(a.chxz, 1, '自制件', 2, '外构件', 3, '外协件', 4, '虚拟件') xz,
       decode(a.isprops, 0, '否', 1,'是') props, decode(a.issale, 0, '否', '是') sale
FROM kc_dm a, kc_dmlb b, kc_chlb c, bm d, kc_ck e
WHERE a.wzlbid = b.wzlbid AND a.chlbid=c.chlbid AND a.deptid = d.deptid(+)
AND a.storeid=e.storeid(+)
ORDER BY a.cpbm
--物资编码打印试图;

prompt
prompt Creating view REP_PRODUCT_DETAIL
prompt ================================
prompt
create or replace view rep_product_detail as
select "SFDJID","SFDJDH","SFRQ","CPID","SL","DJ","JE","DJLB"
from (
  select a.receiveid sfdjid,b.cpid
        ,a.receivedate sfrq,a.receivecode sfdjdh
        ,b.drawnum sl,null je,null dj,1 djlb  --1为购入
  from sc_receiveprod a,sc_receiveproddetail b
  where a.receiveid = b.receiveid
      AND a.state = 8
      AND filialeID ='0'
      AND isout = '0'
UNION
   select c.sfdjid,d.cpid
        ,c.sfrq,c.sfdjdh
        ,d.sl,d.je,d.dj,-1 djlb --  -1为发出
   from kc_sfdj c,kc_sfdjmx d
   where c.sfdjid = d.sfdjid
        AND c.zt = 8
        AND c.djxz = 2 AND c.fgsid = 0
 ) s
--仓库产成品明细帐;

prompt
prompt Creating view REP_RL_AWARD_PERSON
prompt =================================
prompt
CREATE OR REPLACE VIEW REP_RL_AWARD_PERSON AS
SELECT
      b.mc, --部门名称
      b.deptid, --部门编号
      a.personid, -- 职工编号
      a.xm, --姓名
      a.zw, --职务
      a.lb, --用工类别
      c.jcjg, --奖惩结果
      c.yy, --奖惩原因
      c.rq --奖惩日期
FROM emp a,
     bm b,
     rl_zgjcqk c --职工奖惩情况
WHERE
      a.personid = c.personid(+)
      AND a.deptid = b.deptid
  --职工奖罚情况表;

prompt
prompt Creating view REP_RL_CHANGE_PERSON
prompt ==================================
prompt
CREATE OR REPLACE VIEW REP_RL_CHANGE_PERSON AS
SELECT  a.xm, a.lb, a.zw, a.date_in,
        a.personid, a.deptid, C.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              c.bdlx AS bdlxid,
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              d.mc, b.bdqid,     --变动前id或属性.
              b.bdhid,      --变动后id或属性
              c.fgsID
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d
        WHERE a.personid(+) = b.personid    --员工表中的个人id与变动明细中的personid关联
              AND b.zgxxid = c.zgxxid(+)  --主动主及明细表变动信息id关联
              AND a.deptid = d.deptid(+)   --部门及员工表的用部门关联
              AND c.bdlx IN (1, 3, 4, 5) --表示包含1=职工离职3=类别变动,4=职务变迁5=职员复职
UNION ALL
SELECT  a.xm, a.lb, a.zw, a.date_in,
        a.personid, a.deptid, c.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              c.bdlx AS bdlxid,
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              d.mc,
              e.mc AS bdqid, --变动前id或属性.
              f.mc AS bdhid,      --变动后id或属性
              c.fgsID
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d,
          (SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,bm c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdqid=to_char(c.deptid)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) e,--此表中根据变动前id取出相应的部门名称
           (
            SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,bm c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdhid=to_char(c.deptid)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) f    ----此表中根据变动后id取出相应的部门名称
        WHERE a.personid(+) = b.personid
              AND b.zgxxid = c.zgxxid(+)
              AND a.deptid = d.deptid(+)
              AND c.bdlx = 2 --表示部门调动
              AND e.xxbdmxid = b.xxbdmxid
              AND f.xxbdmxid = b.xxbdmxid
--职工变动情况表;

prompt
prompt Creating view REP_RL_INSURANCE_PERSON
prompt =====================================
prompt
CREATE OR REPLACE VIEW REP_RL_INSURANCE_PERSON AS
SELECT
       b.mc,
       b.deptid,
       a.personid,
       a.xm,
       a.lb,
       a.study,
       a.date_in,
       c.xz,      --险种
       c.bxgs,    --保险公司
       c.bxrq,    --保险日期
       c.bxe,     --保险额
       c.bz       --备注
FROM emp a,
     bm b,
     rl_zgbxqk c --职工保险情况表
WHERE a.personid(+) = c.personid
      AND a.deptid = b.deptid(+);

prompt
prompt Creating view REP_RL_OFF_PERSON
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_RL_OFF_PERSON AS
SELECT  a.xm, a.lb, a.zw, a.date_in,
        a.personid, a.deptid,
        c.bdyy, c.zgxxid, c.bdrq,
        DEcode
        (c.zt,
        0, '未审核',
        NULL, '未审核',
        1, '审核',
        2, '已入库',
        9, '已完成') AS zt,
        d.mc,
        c.fgsid
FROM
     emp a,
     rl_zgxxbdmx b, --职工信息变动明细
     rl_zgxxbd c, --职工信息变动
     bm d
WHERE a.personid(+) = b.personid
      AND b.zgxxid = c.zgxxid
      AND c.bdlx = 1 --表示离职
      AND c.zt = 1
      AND a.deptid = d.deptid
ORDER BY a.personid;

prompt
prompt Creating view REP_RL_OTHER_PERSON
prompt =================================
prompt
CREATE OR REPLACE VIEW REP_RL_OTHER_PERSON AS
SELECT
       b.mc,      --部门名称
       b.deptid,  --部门编号
       a.personid, --人员编码
       a.xm,       --姓名
       a.lb,       --类别
       a.zw,       --职位
       a.date_in, --进厂日期
       c.hth,     --合同号
       c.qdrq,    --签定日期
       c.syrq,    --试用日期
       c.htqx,    --合同期限
       c.rzrq,    --入住日期
       c.fjh,     --房间号
       c.gh,      --工会
       c.hk,      --户口
       c.zzz      --暂住证
FROM emp a,
     bm b,
     rl_zgqtxx c    --职工其他信息
WHERE a.personid = c.personid(+)
      AND a.deptid(+) = b.deptid;

prompt
prompt Creating view REP_RL_TRAIN_PERSON
prompt =================================
prompt
CREATE OR REPLACE VIEW REP_RL_TRAIN_PERSON AS
SELECT a.personid, -- 职工代码
       a.xm, -- 姓名
       a.lb, --用工类别
       a.zw, --职务
       a.study, -- 学历
       a.date_in , --进工厂日期
       a.deptid, --部门id
       nvl((SELECT mc FROM bm WHERE a.deptid = deptid), '') AS mc,
       d.pxxm, -- 培训项目
       d.zzjg, --组织机构
       d.kssj, --开始日期
       d.jssj, --结束结束日期
       d.bz -- 备注
FROM
    emp a,  --人员信息
    rl_zgpxqk d -- 职工培训情况
WHERE a.personid(+) = d.personid;

prompt
prompt Creating view REP_SC_BOM_DETAIL
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_SC_BOM_DETAIL AS
SELECT a.sl, a.shl,a.kc__cpid, a.cpid,
       b.cpbm, b.pm, b.gg, b.jldw, c.cpbm zjcpbm, c.pm zjpm, c.gg zjgg, c.jldw zjjldw
FROM sc_bomthj a, vw_kc_dm_exist b, vw_kc_dm_exist c
WHERE a.kc__cpid=b.cpid AND a.cpid = c.cpid
--配料明细表;

prompt
prompt Creating view VW_PLAN_LOCK
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_PLAN_LOCK AS
SELECT cpid, dmsxid, SUM(sdl) sdl
FROM
(
  SELECT wl.cpid, wl.dmsxid, nvl(wl.xql,0)-nvl(ll.drawnum,0) AS sdl FROM
  (
    SELECT l.cpid, nvl(l.dmsxid, -100) dmsxid, SUM(nvl(l.xql,0)) xql
    FROM   sc_wlxqjh w, sc_wlxqjhmx l
    WHERE  l.cc>0 AND l.wlxqjhid=w.wlxqjhid AND w.zt<>8 AND w.isrefer=1
    GROUP BY l.cpid, l.dmsxid
  ) wl,
  (
    SELECT d.cpid, nvl(d.dmsxid,-100) dmsxid, SUM(d.drawnum) drawnum
    FROM   sc_wlxqjhmx l, sc_rwdmx r, sc_jgdmx g, sc_drawmaterialdetail d, sc_drawmaterial j
    WHERE  l.cc>0 AND l.wlxqjhmxid=r.wlxqjhmxid AND r.rwdmxid=g.rwdmxid
    AND    g.jgdmxid=d.jgdmxid AND d.drawid=j.drawid
    AND    l.wlxqjhid IS NOT NULL AND j.isrefer=1
    GROUP BY d.cpid, d.dmsxid
  ) ll
  WHERE wl.dmsxid=ll.dmsxid(+) AND wl.cpid=ll.cpid(+)
  --物料需求的半成品和原料的计划锁定量
  UNION ALL
  SELECT wl.cpid, wl.dmsxid, -1*(nvl(wl.xql,0)-nvl(ll.drawnum,0)) AS sdl FROM
  (
    SELECT l.cpid, nvl(l.dmsxid,-100) dmsxid, SUM(nvl(l.xql,0)) xql
    FROM   sc_wlxqjh w, sc_wlxqjhmx l
    WHERE  l.cc=0 AND l.wlxqjhid=w.wlxqjhid AND w.zt<>8 AND w.isrefer=1
    GROUP BY l.cpid, l.dmsxid
  ) wl,
  (
    SELECT d2.cpid, nvl(d2.dmsxid,-100) dmsxid, SUM(d2.drawnum) drawnum
    FROM   sc_wlxqjhmx l, sc_rwdmx r, sc_jgdmx g, sc_receiveproddetail d2, sc_receiveprod j2
    WHERE  l.cc=0 AND l.wlxqjhmxid=r.wlxqjhmxid AND r.rwdmxid=g.rwdmxid
    AND    g.jgdmxid=d2.jgdmxid AND d2.receiveid=j2.receiveid
    AND    l.wlxqjhid IS NOT NULL AND j2.isrefer=1
    GROUP BY d2.cpid, d2.dmsxid
  ) ll
  WHERE wl.dmsxid=ll.dmsxid(+) AND wl.cpid=ll.cpid(+)
  --物料需求计划的成品的计划锁定量
) t
GROUP BY cpid, dmsxid
--dmsxid=-100表示dmsxid是空值;

prompt
prompt Creating view REP_SC_MRP_DETAIL
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_SC_MRP_DETAIL AS
SELECT a.deptid, a.rq, a.fgsid, a.zt, a.wlxqh,
       b.xql, b.xgl, b.xqrq, b.cpid, b.bz, b.jlxql,
       (CASE WHEN nvl(b.ygl,0) > 0 THEN 1 ELSE 0 END) dh,
       c.cpbm, c.pm, c.gg, c.jldw, d.jhh,  nvl(k.kcl,0)-nvl(e.sdl,0) jhkgl,
       decode(d.zt, 0,0, 1,0, 2,0, 3,0, 9,0, 8) jhzt, f.sxz, c.scydw
FROM  sc_wlxqjh a, sc_wlxqjhmx b, vw_kc_dm_exist c, sc_jh d, vw_plan_lock e, kc_dmsx f,
      (SELECT k.cpid, nvl(k.dmsxid,-100) dmsxid, SUM(k.zl) kcl FROM kc_wzmx k GROUP BY k.cpid, k.dmsxid) k
WHERE a.wlxqjhid=b.wlxqjhid AND b.cpid = c.cpid AND a.scjhid=d.scjhid
AND   b.cpid=e.cpid(+) AND nvl(b.dmsxid, -100)=e.dmsxid(+)
AND   b.cpid=k.cpid(+) AND nvl(b.dmsxid, -100)=k.dmsxid(+)
AND   b.dmsxid=f.dmsxid(+);

prompt
prompt Creating view REP_SC_PERSONALWAGE
prompt =================================
prompt
CREATE OR REPLACE VIEW REP_SC_PERSONALWAGE AS
SELECT a.grgzid, a.gzzid, a.deptid, a.zgf, a.djrq, a.bc, a.djh, a.jsr,
       c.mc, d.gzzmc, b.jjgz, e.xm, b.personid grid
FROM sc_grgz a, sc_grgzry b, bm c, sc_gzz d, emp e
WHERE a.grgzid =b.grgzid AND a.gzzid=d.gzzid AND a.deptid=c.deptid AND b.personid=e.personid
ORDER BY a.deptid, b.personid, a.bc, a.gzzid, a.djh, A.djrq;

prompt
prompt Creating view REP_SC_PLAN_STAT
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_SC_PLAN_STAT AS
SELECT t."SCJHID",t."JHH",t."JHRQ",t."ZT",t."JHLX",t."FGSID",t."CPID",t."SL",t."YWCL",t."CE",t."SCSL",t."DMSXID",t."CPBM",t."PM",t."GG",t."JLDW",t."HSDW",t."SXZ",t."SCYDW", decode(nvl(t.scsl,0), 0, 0, nvl(t.ywcl,0)*100/nvl(t.scsl,0)) wcbl
FROM
(
SELECT a.scjhid, a.jhh, a.jhrq, (CASE WHEN a.zt IN(0,1,2,3,9) THEN 0 ELSE 8 END) zt,a.jhlx,
       a.fgsid, b.cpid, b.sl, b.ywcl, (nvl(b.scsl,0)-nvl(b.ywcl,0)) ce, b.scsl,b.dmsxid,
       c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, d.sxz, c.scydw
FROM sc_jh a, sc_jhmx b, vw_kc_dm_exist c, kc_dmsx d
WHERE a.scjhid=b.scjhid AND b.cpid = c.cpid AND b.dmsxid=d.dmsxid(+)
) t
--生产计划完成情况表;

prompt
prompt Creating view REP_SC_PROD_COST
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_SC_PROD_COST AS
SELECT  b.pm, b.gg, b.cpbm, b.wzlbid, a.cpid, a.nf,a.yf,
       b.jldw, a.jcsl, a.jcdj, a.jcje,c.chmc, c.chlbid
FROM kc_kcnjc a, kc_dm b,kc_chlb c
WHERE a.cpid=b.cpid and c.chlbid=b.chlbid
--产品生产成本计算表;

prompt
prompt Creating view REP_SC_SHOP_DAY_PRODUCE
prompt =====================================
prompt
CREATE OR REPLACE VIEW REP_SC_SHOP_DAY_PRODUCE AS
SELECT a.deptid, a.rq, a.fgsid, a.personid,
       b.gx, b.sl, b.de, b.desl, b.jjgs, b.jjgz,
       c.cpbm, c.pm, c.gg, c.jldw, d.xm
FROM sc_grgzl a, sc_grgzlmx b, vw_kc_dm_exist c, emp d
WHERE a.gzlid=b.gzlid AND b.cpid = c.cpid AND a.personid=d.personid
--车间生产日报表;

prompt
prompt Creating view REP_SC_SHOP_TASK_STAT
prompt ===================================
prompt
CREATE OR REPLACE VIEW REP_SC_SHOP_TASK_STAT AS
SELECT t."RWDID",t."BMID",t."RQ",t."FGSID",t."ZT",t."RWDH",t."SL",t."YJGL",t."CE",t."KSRQ",t."WCRQ",t."DMSXID",t."CPID",t."CPBM",t."PM",t."GG",t."JLDW",t."GYLXLXMC",t."MC",t."SXZ",t."SCYDW", decode(nvl(t.sl,0), 0, 0, nvl(t.yjgl,0)*100/nvl(t.sl,0)) wcbl
FROM
(
SELECT a.rwdid, a.deptid bmid, a.rq, a.fgsid, a.zt, a.rwdh,
       b.sl, b.yjgl, (nvl(b.sl,0)-nvl(b.yjgl,0)) ce, b.ksrq, b.wcrq,b.dmsxid,b.cpid,
       c.cpbm, c.pm, c.gg, c.jldw, e.gylxlxmc, f.mc, g.sxz, c.scydw
FROM sc_rwd a, sc_rwdmx b, vw_kc_dm_exist c, sc_gylx d, sc_gylxlx e, bm f, kc_dmsx g
WHERE a.rwdid=b.rwdid AND b.cpid = c.cpid AND b.gylxid = d.gylxid(+) AND a.deptid=f.deptid
AND d.gylxlxid=e.gylxlxid(+) AND b.dmsxid=g.dmsxid(+)
) t
--生产任务汇总表(车间产品完成情况表);

prompt
prompt Creating view REP_SC_SHOP_WAGE_COLLECT
prompt ======================================
prompt
CREATE OR REPLACE VIEW REP_SC_SHOP_WAGE_COLLECT AS
SELECT a.gzzid, a.deptid bmid, a.zgf, a.djrq, a.bc, a.avgce,
       c.mc, d.gzzmc, b.jjgz, b.personid grid, e.xm
--SELECT gzzid,bmid,zgf,djrq,bc,jsr,mc,gzzmc,zjjgz, nvl(zgf,0)-nvl(zjjgz,0) ce
FROM
(
  SELECT a.grgzid, a.gzzid, a.deptid, a.zgf, a.djrq, a.bc, (a.zgf-SUM(nvl(t.jjgz,0)))/COUNT(t.jjgz) avgce
  FROM  sc_grgz a, sc_grgzry t
  WHERE a.grgzid = t.grgzid
  GROUP BY a.grgzid, a.gzzid, a.deptid, a.zgf, a.djrq, a.bc
) a, sc_grgzry b, bm c, sc_gzz d, emp e
WHERE a.grgzid=b.grgzid AND a.gzzid=d.gzzid AND a.deptid=c.deptid
AND   b.personid=e.personid
--GROUP BY a.gzzid, a.deptid, a.zgf, a.djrq, a.bc, a.jsr,c.mc, d.gzzmc
ORDER BY a.djrq,a.deptid,a.gzzid --车间工人工资汇总报表;

prompt
prompt Creating view REP_SC_TECHNICS_ROUTE
prompt ===================================
prompt
CREATE OR REPLACE VIEW REP_SC_TECHNICS_ROUTE AS
SELECT b.desl, b.deje, b.lbjj, b.hsj, b.gdjg, b.scgs, b.bz,a.cpid, a.gylxlxid,
       c.cpbm, c.pm, c.gg, c.jldw, b.gymcid,
       d.gylxlxmc, e.gymc, f.gdmc
FROM sc_gylx a, sc_gylxmx b, vw_kc_dm_exist c, sc_gylxlx d, sc_gymc e, sc_gxfd f
WHERE a.gylxid=b.gylxid AND a.cpid = c.cpid
AND a.gylxlxid=d.gylxlxid AND b.gymcid=e.gymcid(+) AND b.gxfdid=f.gxfdid(+)
--产品工艺明细表;

prompt
prompt Creating view REP_SC_WORKER_WAGE
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_SC_WORKER_WAGE AS
SELECT a."ZJID",a."DEPTID",a."PERSONID",a."FGSID",a."JE",a."RQ",a."CQ",a."RB",a."YB",a."QJ",a."SL",a."JJGS",a."LX", b.xm, c.mc
FROM
(
SELECT a1.gzlid zjid, a1.deptid, a1.personid, a1.fgsid, nvl(a1.je,0) je, --总金额
  a1.rq, nvl(a1.cq,0) cq, nvl(a1.rb,0) rb, nvl(a1.yb,0) yb, nvl(a1.qj,0) qj,
  SUM(nvl(b2.sl,0)) sl, SUM(nvl(b2.jjgs,0)) jjgs, 'gr' lx
FROM sc_grgzl a1, sc_grgzlmx b2
WHERE a1.gzlid=b2.gzlid
GROUP BY a1.gzlid, a1.deptid, a1.personid, a1.fgsid, rq,cq,rb,yb,qj,je
--部门工作量
UNION ALL
SELECT a2.bmgzlid zjid, a2.deptid, b2.personid, a2.fgsid, sum(nvl(b2.jjgz,0)) je,
  a2.rq, 0 , 0, 0, 0, sum(nvl(b2.sl,0)) sl, sum(nvl(b2.jjgs,0)) jjgs,'bm' lx
FROM sc_bmgzl a2, sc_bmgzlmx b2
WHERE a2.bmgzlid = b2.bmgzlid
GROUP BY a2.bmgzlid, a2.deptid, b2.personid, a2.fgsid, a2.rq
--工作组工作量
UNION ALL
SELECT a3.gzzgzlid zjid, a3.deptid, b3.personid, a3.fgsid, nvl(b3.jjgz,0) je,
  a3.rq, 0, 0, 0, 0, decode(a3.empCount, 0, 0, a3.sl/a3.empCount) sl, 0, 'gzz' lx
FROM
(
    SELECT t.gzzgzlid, t.deptid, t.rq, t.sl, t.fgsid,
      (SELECT COUNT(*) FROM sc_gzzgzlry r WHERE r.gzzgzlid=t.gzzgzlid) empCount,
      (SELECT COUNT(*) FROM sc_gzzgzlmx d WHERE d.gzzgzlid=t.gzzgzlid) prodCount
    FROM sc_gzzgzl t
  ) a3, sc_gzzgzlry b3, sc_gzzgzlmx c3
WHERE a3.gzzgzlid = b3.gzzgzlid AND a3.gzzgzlid=c3.gzzgzlid
) a, emp b, bm c
WHERE a.deptid=c.deptid AND a.personid=b.personid
ORDER BY a.rq,c.mc,b.xm;

prompt
prompt Creating view REP_SC_WORKLOAD
prompt =============================
prompt
CREATE OR REPLACE VIEW REP_SC_WORKLOAD AS
SELECT a1.gzlid zjid, a1.deptid, a1.personid, a1.fgsid, a1.rq,
  b1.jgdmxid, b1.gylxid, b1.cpid, b1.gx,
  nvl(b1.sl,0) sl, nvl(b1.de,0) de, nvl(b1.jjgz,0) jjgz,
  c1.cpbm, c1.pm, c1.gg, c1.jldw, d1.xm,'gr' lx, e1.sxz, c1.scydw
FROM sc_grgzl a1, sc_grgzlmx b1 , kc_dm c1, emp d1, kc_dmsx e1
WHERE a1.gzlid = b1.gzlid AND b1.cpid=c1.cpid AND a1.personid=d1.personid AND b1.dmsxid=e1.dmsxid(+)
--部门工作量
UNION ALL
SELECT a2.bmgzlid zjid, a2.deptid, b2.personid, a2.fgsid, a2.rq,
  b2.jgdmxid, b2.gylxid, b2.cpid, b2.gx,
  nvl(b2.sl,0) sl, nvl(b2.jjdj,0) de, nvl(b2.jjgz,0) jjgz,
  c2.cpbm, c2.pm, c2.gg, c2.jldw, d2.xm, 'bm' lx, e2.sxz, c2.scydw
FROM sc_bmgzl a2, sc_bmgzlmx b2, kc_dm c2, emp d2, kc_dmsx e2
WHERE a2.bmgzlid = b2.bmgzlid AND b2.cpid=c2.cpid AND b2.personid=d2.personid AND b2.dmsxid=e2.dmsxid(+)
--工作组工作量
UNION ALL
SELECT a3.gzzgzlid zjid, a3.deptid, b3.personid, a3.fgsid, a3.rq,
  c3.jgdmxid, c3.gylxid, c3.cpid, c3.gx, decode(a3.empCount, 0, 0, a3.sl/a3.empCount) sl,
  c3.jjdj, c3.jjgz*b3.bl, d3.cpbm, d3.pm,d3.gg,d3.jldw,e3.xm, 'gzz' lx, f3.sxz, d3.scydw
FROM
  (
    SELECT t.gzzgzlid, t.deptid, t.rq, t.sl, t.fgsid,
      (SELECT COUNT(*) FROM sc_gzzgzlry r WHERE r.gzzgzlid=t.gzzgzlid) empCount,
      (SELECT COUNT(*) FROM sc_gzzgzlmx d WHERE d.gzzgzlid=t.gzzgzlid) prodCount
    FROM sc_gzzgzl t
  ) a3, sc_gzzgzlry b3, sc_gzzgzlmx c3, kc_dm d3, emp e3, kc_dmsx f3
WHERE a3.gzzgzlid = b3.gzzgzlid AND a3.gzzgzlid=c3.gzzgzlid AND c3.cpid=d3.cpid AND b3.personid=e3.personid
AND c3.dmsxid=f3.dmsxid(+);

prompt
prompt Creating view REP_STOCK_DETAIL
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_STOCK_DETAIL AS
SELECT decode(djxz, 1, '采购入库单', 2, '销售出库单', 3, '自制入库单', 4, '生产领料单', 5, '外加工入库单', 6, '外加工出库单') djxz,
       cpid, sfdjdh, sfrq, storeid, cpbm, fgsid, SUM(srsl) srsl, SUM(srdj) srdj, SUM(srje) srje,
       SUM(fcsl) fcsl, SUM(fcdj) fcdj, SUM(fcje) fcje
FROM
(
SELECT a.djxz, a.fgsid, a.sfdjdh, a.sfrq, a.storeid, b.cpid, b.sfdjid, c.cpbm, (b.sl) srsl, (nvl(b.dj,0)) srdj, (nvl(b.je,0)) srje,
       0 fcsl, 0 fcdj, 0 fcje
       --nvl(srsl,0)-nvl(fcsl,0) jcsl,  (srdj) jcdj  nvl(srje,0)-nvl(fcje,0) jcje,
FROM kc_sfdj a, kc_sfdjmx b, vw_kc_dm_exist c
WHERE a.sfdjid=b.sfdjid AND b.cpid = c.cpid
AND a.djxz IN(1,3,5)
UNION ALL
SELECT a.djxz, a.fgsid, a.sfdjdh, a.sfrq, a.storeid, b.cpid, b.sfdjid, c.cpbm, 0 srsl, 0 srdj, 0 srje,
       (b.sl) fcsl, (nvl(b.dj,0)) fcdj, (nvl(b.je,0)) fcje
       --nvl(srsl,0)-nvl(fcsl,0) jcsl,  (srdj) jcdj  nvl(srje,0)-nvl(fcje,0) jcje,
FROM kc_sfdj a, kc_sfdjmx b, vw_kc_dm_exist c
WHERE a.sfdjid = b.sfdjid AND b.cpid= c.cpid
AND a.djxz IN(2,4,6)
)
GROUP BY djxz, cpid, sfdjdh, sfrq, storeid, cpbm, fgsid;

prompt
prompt Creating view REP_STOCK_INTEGER
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_STOCK_INTEGER AS
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl,
       SUM(nvl(kcsl,0)) kcsl,SUM(nvl(wjzssl,0)) wjzssl,SUM(nvl(wjzfsl,0)) wjzfsl,
       SUM(nvl(hjsl,0)) hjsl,SUM(nvl(kchssl,0)) kchssl,SUM(nvl(wjzshssl,0)) wjzshssl,SUM(nvl(wjzfhssl,0)) wjzfhssl,
       SUM(nvl(hjhssl,0)) hjhssl
FROM(
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,
       kcsl,wjzssl,wjzfsl,kchssl,wjzshssl,wjzfhssl,hsbl,
       (nvl(kcsl,0)+nvl(wjzssl,0)-nvl(wjzfsl,0)) hjsl,(nvl(kchssl,0)+nvl(wjzshssl,0)-nvl(wjzfhssl,0)) hjhssl
FROM(
SELECT a.storeid, a.sfrq,a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,
       b.cpbm,b.pm,b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,nvl(a.srsl,0)-nvl(a.fcsl,0) kcsl,
       NULL wjzssl, NULL wjzfsl, nvl(a.srhssl,0)-nvl(a.fchssl,0) kchssl, NULL wjzshssl,NULL wjzfhssl
FROM vw_kc_storebill a,kc_dm b
WHERE a.cpid=b.cpid AND a.zt IN(2,8)
UNION ALL
SELECT a.storeid,a.sfrq, a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,
       b.cpbm,b.pm, b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,NULL kcsl,
       a.srsl,a.fcsl, NULL kchssl, nvl(a.srhssl,0) wjzshssl, nvl(a.fchssl,0) wjzfhssl
FROM vw_kc_storebill a,kc_dm b
WHERE a.cpid=b.cpid AND a.zt<>2 AND a.zt<>8
)
) GROUP BY storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl
ORDER BY cpbm
--存货库存量表报表试图，2004-04-14为了增加用户时间段查询，和显示未记账数量
  /*
  SELECT a.cpid, a.kcsl, a.storeid, a.fgsid,
         b.jldw, b.cpbm, b.pm, b.gg, b.hsdw, b.chlbid, b.wzlbid
  FROM kc_kchz a, vw_kc_dm_exist b
  WHERE a.cpid=b.cpid
  --存货库存量表报表试图(相同产品编码汇总)
  */;

prompt
prompt Creating view REP_STOCK_NUMBER
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_STOCK_NUMBER AS
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl,
       SUM(nvl(kcsl,0)) kcsl,SUM(nvl(wjzssl,0)) wjzssl,SUM(nvl(wjzfsl,0)) wjzfsl,
       SUM(nvl(hjsl,0)) hjsl,SUM(nvl(kchssl,0)) kchssl,SUM(nvl(wjzshssl,0)) wjzshssl,SUM(nvl(wjzfhssl,0)) wjzfhssl,
       SUM(nvl(hjhssl,0)) hjhssl
FROM(
SELECT storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,
       kcsl,wjzssl,wjzfsl,kchssl,wjzshssl,wjzfhssl,hsbl,
       (nvl(kcsl,0)+nvl(wjzssl,0)-nvl(wjzfsl,0)) hjsl,(nvl(kchssl,0)+nvl(wjzshssl,0)-nvl(wjzfhssl,0)) hjhssl
FROM(
SELECT a.storeid, a.sfrq,a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,
       b.cpbm,b.pm,b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,nvl(a.srsl,0)-nvl(a.fcsl,0) kcsl,
       NULL wjzssl, NULL wjzfsl, nvl(a.srhssl,0)-nvl(a.fchssl,0) kchssl, NULL wjzshssl,NULL wjzfhssl
FROM vw_kc_storebill a,kc_dm b
WHERE a.cpid=b.cpid AND a.zt IN(2,8)
UNION ALL
SELECT a.storeid,a.sfrq, a.isrefer, a.zt,a.fgsid, a.cpid,b.hsbl,
       b.cpbm,b.pm, b.gg,b.jldw,b.hsdw,b.chlbid,b.wzlbid,NULL kcsl,
       a.srsl,a.fcsl, NULL kchssl, nvl(a.srhssl,0) wjzshssl, nvl(a.fchssl,0) wjzfhssl
FROM vw_kc_storebill a,kc_dm b
WHERE a.cpid=b.cpid AND a.zt<>2 AND a.zt<>8
)
) GROUP BY storeid, sfrq, isrefer,zt,fgsid,cpid,cpbm,pm,gg,jldw,hsdw,chlbid,wzlbid,hsbl
ORDER BY cpbm
--存货库存量表报表试图，2004-04-14为了增加用户时间段查询，和显示未记账数量
  /*
  SELECT a.cpid, a.kcsl, a.storeid, a.fgsid,
         b.jldw, b.cpbm, b.pm, b.gg, b.hsdw, b.chlbid, b.wzlbid
  FROM kc_kchz a, vw_kc_dm_exist b
  WHERE a.cpid=b.cpid
  --存货库存量表报表试图(相同产品编码汇总)
  */;

prompt
prompt Creating view REP_STORE_BILL
prompt ============================
prompt
CREATE OR REPLACE VIEW REP_STORE_BILL AS
SELECT a.sfdjdh, a.fgsid, a.sfrq, a.djxz, a.dmsxid,
       --显示单据名称
       decode(a.djxz, 1,'采购入库单',3,'自制入库单',5,'外加工入库单', 7,'报损单', 9, '其它入库单', 10, '其它出库单',
             2,'销售出库单',4, '生产领料单',6,'外加发料库', 8, '移库单', -1, '移库单', '') djmc,
       --根据单据性质得到收发数量
       decode(a.djxz, 1, a.srsl, 3, a.srsl, 5, a.srsl, 7, a.srsl, 9, a.srsl, -1, a.srsl, a.fcsl) sl,
       decode(a.djxz, 1, a.srdj, 3, a.srdj, 5, a.srdj, 7, a.srdj, 9, a.srdj, -1, a.srdj, a.fcdj) dj,
       decode(a.djxz, 1, a.srje, 3, a.srje, 5, a.srje, 7, a.srje, 9, a.srje, -1, a.srje, a.fcje) je,
       decode(a.zt,2,0,8,0,1) zt,
       a.storeid, a.deptid, a.sfdjid,
       a.dwtxid, a.isrefer, a.ph, a.cpid,a.khlx,
       c.pm, c.gg, c.cpbm, c.jldw, e.sxz, c.hsdw,c.wzlbid
FROM vw_kc_storebill a, kc_dm c, kc_dmsx e
WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) --AND a.djxz IN(1,3,5,7,9)
ORDER BY sfdjdh,cpbm
/*
UNION ALL
SELECT a.sfdjdh, a.fgsid, a.sfrq, a.djxz,a.dmsxid,
       decode(a.djxz, 2,'销售出库单',4, '生产领料单',6,'外加发料库','') djmc,
       a.storeid, a.deptid, a.sfdjid,
       a.dwtxid, a.Isrefer, a.fcsl sl, a.fcdj dj, a.fcje je,a.ph, a.cpid,
       c.pm,c.gg,c.cpbm, c.jldw, e.sxz, c.hsdw
FROM vw_kc_storebill a, kc_dm c, kc_dmsx e
WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND a.djxz IN(2,4,6)
UNION ALL
SELECT a.sfdjdh, a.fgsid, a.sfrq, 8 djxz,a.dmsxid,
       '移库单' djmc,
       a.storeid, a.deptid, a.sfdjid,
       a.dwtxid, a.Isrefer,decode(a.djxz,8,a.fcsl,a.srsl) sl,
       decode(a.djxz,8,a.fcdj,a.srdj) dj,decode(a.djxz,8,a.fcje,a.srje) dj,
       a.ph, a.cpid,
       c.pm,c.gg,c.cpbm, c.jldw, e.sxz, c.hsdw
FROM vw_kc_storebill a, kc_dm c, kc_dmsx e
WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND a.djxz IN(8,-1)
)
ORDER BY sfdjdh,cpbm*/
--存存收发单据明细帐;

prompt
prompt Creating view REP_XS_COLLECT_FP
prompt ===============================
prompt
create or replace view rep_xs_collect_fp as
select c.dwmc,c.dwdm,d.cpbm,d.pm,d.gg,d.jldw,b.sl,b.hsdj dj,
        b.jshj jje,a.fgsid,a.kprq,a.fphm,e.sxz
        ,g.xm,h.mc,a.dwtxid
from cw_xsfp a,cw_xsfpmx b,dwtx c,kc_dm d,kc_dmsx e,dwdq f,emp g,bm h
where a.xsfpid=b.xsfpid
and a.dwtxid=c.dwtxid
AND a.personid=g.personid
AND a.deptid=h.deptid
and b.cpid=d.cpid
AND b.dmsxid=e.dmsxid(+)
--销售汇总表(按发票);

prompt
prompt Creating view REP_XS_COLLECT_TD
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_XS_COLLECT_TD AS
SELECT zsl,dwtxid,tdrq,zje,fgsid,khlx,areacode,dqmc,cdjlx,dwmc ,dwdm,xm,mc,personid,zt,djlx,htlx,isnet
FROM (
SELECT
       sum(nvl(w.sl,0))zsl
       ,a.dwtxid,a.tdrq,sum(nvl(w.jje,0))zje,a.fgsid
       ,a.khlx,a.isnet
       ,b.dwmc,f.areacode,f.dqmc,'提货单' cdjlx ,b.dwdm,h.xm,q.mc,a.personid,a.zt,a.djlx
       ,decode(a.isnet,0,'销售合同','来料加工合同')htlx
FROM xs_td a,dwtx b,dwdq f,emp h,bm q,xs_tdhw w
WHERE a.dwtxid=b.dwtxid
AND a.tdid=w.tdid
AND b.dqh=f.dqh
AND a.personid=h.personid
AND a.deptid=q.deptid
AND a.djlx=1
GROUP BY
       a.dwtxid,a.tdrq,a.fgsid
       ,a.khlx,a.isnet
       ,b.dwmc,f.areacode,f.dqmc,b.dwdm,h.xm,q.mc,a.personid,a.zt,a.djlx
UNION ALL
SELECT
       sum(nvl(w.sl,0))zsl
       ,a.dwtxid,a.tdrq,sum(nvl(w.jje,0))zje,a.fgsid
       ,a.khlx,a.isnet
       ,b.dwmc,f.areacode,f.dqmc,'退货单' cdjlx ,b.dwdm,h.xm,q.mc,a.personid,a.zt,a.djlx
       ,decode(a.isnet,0,'销售合同','来料加工合同')htlx
FROM xs_td a,dwtx b,dwdq f,emp h,bm q,xs_tdhw w
WHERE a.dwtxid=b.dwtxid
AND a.tdid=w.tdid
AND b.dqh=f.dqh
AND a.personid=h.personid
AND a.deptid=q.deptid
AND a.djlx=-1
GROUP BY
       a.dwtxid,a.tdrq,a.fgsid
       ,a.khlx,a.isnet
       ,b.dwmc,f.areacode,f.dqmc,b.dwdm,h.xm,q.mc,a.personid,a.zt,a.djlx
)
--销售汇总表(按提单);

prompt
prompt Creating view REP_XS_CUSTER_DAYINCOME
prompt =====================================
prompt
CREATE OR REPLACE VIEW REP_XS_CUSTER_DAYINCOME AS
SELECT a.rq,a.dwtxid,a.je,a.zt,c.dwmc,c.dwdm ,a.fgsid ,a.xsjsid ,a.hxje,a.whxje,
       d.areacode,d.dqmc,e.personid,e.xm,a.isnet,decode(a.isnet,0,'销售合同',1,'来料外加工单合同')cnet
FROM cw_xsjs a,dwtx c ,dwdq d,emp e
WHERE  a.dwtxid=c.dwtxid and c.dqh=d.dqh  AND a.personid=e.personid
GROUP BY a.rq,a.dwtxid,a.je,a.zt,c.dwmc,c.dwdm ,a.fgsid ,a.xsjsid ,
         a.hxje,a.whxje,d.areacode,d.dqmc ,e.personid,e.xm,a.isnet
ORDER BY a.rq,c.dwdm ----收入日报表---按客户汇总   --zt:0=未审核;1=已审核;

prompt
prompt Creating view REP_XS_CUST_BILL
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_XS_CUST_BILL AS
SELECT
     a.fgsid,e.dwmc,e.dwdm,a.dwtxid,a.zt,a.tdrq,a.tdbh,a.jsfsid,x.xsje,nvl(a.ddfy,0)ddfy,a.tdid,a.djlx,
x.yhje,x.ssje,(nvl(x.jje,0)-nvl(x.ssje,0)-nvl(a.ddfy,0))ye,f.jsfs,h.areacode,h.dqmc,a.personid,q.xm
FROM
 xs_td a,
(
  SELECT
   sum(nvl(b.xsje,0))xsje,sum(nvl(b.xsje,0))-sum(nvl(b.jje,0)) yhje,sum(nvl(b.ssje,0)) ssje,b.tdid,sum(nvl(b.jje,0))jje
  FROM
   xs_td a,xs_tdhw b
  WHERE  a.tdid=b.tdid
  GROUP BY b.tdid
 ) x,dwtx e,jsfs f,dwdq h,emp q
WHERE
   a.tdid=x.tdid
   AND a.dwtxid=e.dwtxid
   AND a.jsfsid=f.jsfsid
   AND e.dqh=h.dqh
   AND a.personid=q.personid
ORDER BY a.dwtxid
--往来单位流水帐;

prompt
prompt Creating view REP_XS_DEDUCT_ACCRUAL
prompt ===================================
prompt
create or replace view rep_xs_deduct_accrual as
select d.dwmc,c.cpbm,c.pm,c.gg,c.jldw,b.sl,b.dj,b.jje,a.zt,a.tdrq,a.fgsid
from xs_td a,xs_tdhw b,kc_dm c,dwtx d
where a.tdid=b.tdid and b.cpid=c.cpid and a.dwtxid=d.dwtxid
ORDER BY d.dwmc
--销售汇总表(按提单);

prompt
prompt Creating view REP_XS_DEPT_STAT
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_XS_DEPT_STAT AS
SELECT djxz, deptid, personid, dwtxid, zt, sl, je, mc, dwmc,fgsid,xm,rq,dwdm,areacode,dqmc,sh
FROM
(
--按提单
select 2 djxz,a.deptid,a.personid,a.dwtxid,a.zt
       ,sum(nvl(b.sl,0))sl,sum(nvl(b.jje,0)) je,d.mc
       ,e.dwmc,a.fgsid,a.tdrq rq,f.xm,h.areacode,h.dqmc,e.dwdm,1 sh
from xs_td a,xs_tdhw b,bm d,dwtx e,emp f,dwdq h
where a.tdid=b.tdid
and a.deptid=d.deptid
and a.dwtxid=e.dwtxid
AND e.dqh=h.dqh
and a.personid=f.personid
AND a.zt IN(2,8)
GROUP BY a.deptid,a.personid,a.dwtxid,a.zt,d.mc,e.dwmc,a.fgsid,a.tdrq,f.xm,h.areacode,h.dqmc,e.dwdm
UNION ALL
select 2 djxz,a.deptid,a.personid,a.dwtxid,a.zt
       ,sum(nvl(b.sl,0))sl,sum(nvl(b.jje,0)) je,d.mc
       ,e.dwmc,a.fgsid,a.tdrq rq,f.xm,h.areacode,h.dqmc,e.dwdm,2 sh
from xs_td a,xs_tdhw b,bm d,dwtx e,emp f,dwdq h
where a.tdid=b.tdid
and a.deptid=d.deptid
and a.dwtxid=e.dwtxid
AND e.dqh=h.dqh
and a.personid=f.personid
AND a.zt =8
GROUP BY a.deptid,a.personid,a.dwtxid,a.zt,d.mc,e.dwmc,a.fgsid,a.tdrq,f.xm,h.areacode,h.dqmc,e.dwdm
UNION ALL
--按发票
select 1 djxz,a.deptid,a.personid,a.dwtxid,a.zt,
       sum(nvl(b.sl,0))sl,sum(nvl(b.je,0))je,d.mc
       ,e.dwmc,a.fgsid,a.kprq rq,f.xm,h.areacode,h.dqmc,e.dwdm,1 sh
from cw_xsfp a,cw_xsfpmx b,bm d,dwtx e,emp f,dwdq h
where a.xsfpid=b.xsfpid
and a.deptid=d.deptid
and a.dwtxid=e.dwtxid
AND e.dqh=h.dqh
and a.personid=f.personid
GROUP BY a.deptid,a.personid,a.dwtxid,a.zt,d.mc,e.dwmc,a.fgsid,a.kprq ,f.xm,h.areacode,h.dqmc,e.dwdm
UNION ALL
--按发票
select 1 djxz,a.deptid,a.personid,a.dwtxid,a.zt,
       sum(nvl(b.sl,0))sl,sum(nvl(b.je,0))je,d.mc
       ,e.dwmc,a.fgsid,a.kprq rq,f.xm,h.areacode,h.dqmc,e.dwdm,2 sh
from cw_xsfp a,cw_xsfpmx b,bm d,dwtx e,emp f,dwdq h
where a.xsfpid=b.xsfpid
and a.deptid=d.deptid
and a.dwtxid=e.dwtxid
AND e.dqh=h.dqh
and a.personid=f.personid
GROUP BY a.deptid,a.personid,a.dwtxid,a.zt,d.mc,e.dwmc,a.fgsid,a.kprq ,f.xm,h.areacode,h.dqmc,e.dwdm
)
order by areacode
--部门销售统计表;

prompt
prompt Creating view REP_XS_DETAIL_FP
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_XS_DETAIL_FP AS
SELECT a.kprq, a.fphm,c.cpbm,c.pm,c.gg,a.fgsid,--发票
       b.sl,b.wsdj,b.je,h.mc,g.xm,a.xsfpid id,
       b.zzsl,b.se,b.jshj,f.htbh,i.jsfs,j.dwmc,j.dwdm,
       b.cpid,h.sxz,k.areacode,k.dqmc,a.dwtxid
FROM cw_xsfp a,cw_xsfpmx b,kc_dm c,xs_tdhw d,xs_hthw e ,xs_ht f,emp g,bm h,jsfs i , dwtx j,kc_dmsx h,dwdq k
WHERE a.xsfpid=b.xsfpid
  AND b.cpid=c.cpid
  AND b.tdhwid=d.tdhwid
  AND a.deptid=h.deptid(+)
  AND d.hthwid=e.hthwid
  AND e.htid=f.htid
  AND a.personid=g.personid(+)
  AND a.jsfsid=i.jsfsid
  AND a.dwtxid=j.dwtxid
  AND b.dmsxid=h.dmsxid(+)
  AND j.dqh=k.dqh
--销售发票明细;

prompt
prompt Creating view REP_XS_DETAIL_TD
prompt ==============================
prompt
create or replace view rep_xs_detail_td as
select a.tdrq,a.tdbh,d.cpbm,d.pm,d.gg,a.tdid,--提单
       a.djlx,a.khlx,a.fgsid,a.dwtxid,nvl(b.stsl,0)stsl,a.personid,a.zt,a.djh,a.Isnet,
       b.sl,b.dj,b.jje,f.mc,e.xm, g.dwmc,h.htbh,
       j.sxz,d.jldw,g.dwdm,d.cpid,g.dqh,k.dqmc,k.areacode,b.dmsxid,t.chmc,d.chlbid
       ,decode(a.isnet,0,'销售合同','来料加工合同')htlx,a.yfdj,nvl(a.yfdj,0)*nvl(b.sl,0)yf,
       (nvl(b.dj,0)-nvl(a.yfdj,0))mdj,(nvl(b.jje,0)-(nvl(a.yfdj,0))*nvl(b.sl,0))mjje
from xs_td a,xs_tdhw b,xs_hthw c,kc_dm d,emp e,bm f,dwtx g,xs_ht h,kc_dmsx j,dwdq k,kc_chlb t
where b.tdid=a.tdid
 and b.hthwid=c.hthwid(+)
 and b.cpid=d.cpid
 and a.personid=e.personid(+)
 and a.deptid=f.deptid(+)
 and a.dwtxid=g.dwtxid
 and c.htid=h.htid(+)
 AND b.dmsxid=j.dmsxid(+)
 AND g.dqh=k.dqh
 AND d.chlbid=t.chlbid
--销售报表
--销售提单明细;

prompt
prompt Creating view REP_XS_FAVOUR_STAT
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_XS_FAVOUR_STAT AS
SELECT a.tdrq kprq,a.tdbh fphm,a.dwtxid,b.cpid--,nvl(b.xsje,0)-nvl(b.jje,0)je
        ,b.tdhwid,d.dwmc,a.zt,a.fgsid,e.areacode,e.dqmc,d.dwdm,b.jzj,c.pm,c.gg,b.sl,f.xm,a.personid
        ,(nvl(b.jzj,0)-nvl(b.dj,0))*nvl(b.sl,0)je,b.dj
FROM xs_td a,xs_tdhw b,dwtx d,dwdq e,kc_dm c,emp f
WHERE a.tdid=b.tdid
AND a.dwtxid=d.dwtxid
AND d.dqh=e.dqh
AND b.cpid=c.cpid
AND (nvl(b.dj,0)-nvl(b.jzj,0))<0
AND nvl(b.sl,0)>0
AND a.personid=f.personid
/*
SELECT  a.kprq,a.fphm,a.dwtxid,b.cpid,nvl(c.xsje,0)-nvl(c.jje,0)je
        ,b.tdhwid,d.dwmc,a.zt,a.fgsid,e.areacode,e.dqmc,d.dwdm
FROM  cw_xsfp a,cw_xsfpmx b,xs_tdhw c,dwtx d,dwdq e
WHERE
  a.xsfpid=b.xsfpid
  AND    b.tdhwid=c.tdhwid
  AND  a.dwtxid=d.dwtxid
  AND d.dqh=e.dqh
  */
-- 销售优惠统计表;

prompt
prompt Creating view REP_XS_FP_SALER_RESULT
prompt ====================================
prompt
CREATE OR REPLACE VIEW REP_XS_FP_SALER_RESULT AS
SELECT a.kprq,a.fphm,a.dwtxid,b.cpid,b.sl,b.wsdj,b.je,b.zzsl,b.se,b.jshj,c.cpbm,
       c.pm,c.gg,a.jsfsid,d.jsfs,b.tdhwid,g.htbh,a.fgsid,h.dwmc
       ,h.dwdm,a.personid,a.xsfpid id,k.xm,t.sxz,c.jldw,r.areacode,r.dqmc,w.mc
FROM cw_xsfp a,cw_xsfpmx b,kc_dm c,jsfs d,xs_tdhw e,xs_hthw f,xs_ht g,dwtx h,emp k,kc_dmsx t,dwdq r,bm w
WHERE a.xsfpid=b.xsfpid
AND b.cpid=c.cpid
AND a.jsfsid=d.jsfsid
AND a.personid=k.personid
AND b.tdhwid=e.tdhwid
AND e.hthwid=f.hthwid(+)
AND f.htid=g.htid(+)
AND a.dwtxid=h.dwtxid
AND b.dmsxid=t.dmsxid(+)
AND h.dqh=r.dqh
AND a.deptid=w.deptid
--业务员销售业绩(按发票);

prompt
prompt Creating view REP_XS_HT_LIST
prompt ============================
prompt
CREATE OR REPLACE VIEW REP_XS_HT_LIST AS
SELECT
       a.htid,a.dwtxid,a.personid,a.htbh,a.htrq,a.ksrq,a.jsrq,
       a.qddd,a.czrq,a.czy,a.czyid,a.fgsid,a.zt
       ,a.sprid,a.khlx,a.hl,a.wbid,a.deptid,a.jsfsid,a.isnet
       ,b.dwmc,b.dwdm
       ,c.xm
       ,d.mc
       ,e.areacode,e.dqmc
       ,f.jsfs
       ,j.pm
       ,SUM(nvl(h.sl,0))zsl
       ,SUM(nvl(h.jje,0))zje
       ,decode(a.isnet,0,'销售合同','来料加工合同')htlx
FROM xs_ht a,dwtx b,emp c,bm d,dwdq e,jsfs f,xs_hthw h,vw_xs_wzdj j
WHERE a.dwtxid=b.dwtxid
AND a.personid=c.personid
AND a.deptid=d.deptid
AND b.dqh=e.dqh
AND a.jsfsid=f.jsfsid
AND h.wzdjid=j.wzdjid
AND h.htid=a.htid
GROUP BY
       a.htid,a.dwtxid,a.personid,a.htbh,a.htrq,a.ksrq,a.jsrq,
       a.qddd,a.czrq,a.czy,a.czyid,a.fgsid,a.zt
       ,a.sprid,a.khlx,a.hl,a.wbid,a.deptid,a.jsfsid,a.isnet
       ,b.dwmc,b.dwdm
       ,c.xm
       ,d.mc
       ,e.areacode,e.dqmc
       ,f.jsfs
       ,j.pm
--销售合同汇总
--qddd 签定地点
--qtxx 其他信息
--spr 审批人
--dwmc
--dwdm
--外币类别 wbmc
--ordertypeid  合同类型
-- xm 业务员
--wcrq  完成日期(货物最延后的日期)
/*使用列表*/
--销售合同里的未完成合同列表;

prompt
prompt Creating view REP_XS_HT_PERFORM
prompt ===============================
prompt
CREATE OR REPLACE VIEW REP_XS_HT_PERFORM AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,a.zt htlb,a.isnet,
       b.sl, b.dj, b.jje,(nvl(b.sl,0)-nvl(b.skdsl,0))wtl,
       b.jhrq,d.pm,d.gg,d.cpbm, d.jldw,e.dwmc,f.sxz,e.dwdm,g.dqmc,g.areacode,g.dqh
       ,h.xm,k.mc,a.personid,b.skdsl,b.stsl
       ,decode(a.isnet,0,'销售合同','来料加工合同')htlx,b.bz,decode(a.zt,'0','未审','1','已审','9','审批中','8','完成','4','作废')zts
       ,a.khlx
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,kc_dm d,dwtx e,kc_dmsx f,dwdq g,emp h,bm k
WHERE a.htid = b.htid
AND b.wzdjid = c.wzdjid
AND a.personid=h.personid
AND a.deptid=k.deptid(+)
AND c.cpid=d.cpid
AND a.dwtxid=e.dwtxid
AND b.dmsxid=f.dmsxid(+)
AND e.dqh=g.dqh(+)
ORDER BY a.htrq;

prompt
prompt Creating view REP_XS_INTEGER
prompt ============================
prompt
CREATE OR REPLACE VIEW REP_XS_INTEGER AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,a.zt htlb,
   b.sl, b.dj, b.jje,(nvl(b.sl,0)-nvl(b.stsl,0))wtl,
   b.jhrq,d.pm,d.gg,d.cpbm, d.jldw,e.dwmc
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,kc_dm d,dwtx e
WHERE a.htid = b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
AND a.dwtxid=e.dwtxid
ORDER BY a.htrq
--销售合同发货情况表
--stsl 出库后回填;

prompt
prompt Creating view REP_XS_NUMBER
prompt ===========================
prompt
CREATE OR REPLACE VIEW REP_XS_NUMBER AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,a.zt htlb,
   b.sl, b.dj, b.jje,(nvl(b.sl,0)-nvl(b.stsl,0))wtl,
   b.jhrq,d.pm,d.gg,d.cpbm, d.jldw,e.dwmc
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,kc_dm d,dwtx e
WHERE a.htid = b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
AND a.dwtxid=e.dwtxid
ORDER BY a.htrq
--销售合同发货情况表
--stsl 出库后回填;

prompt
prompt Creating view REP_XS_PREPAY_STAT
prompt ================================
prompt
create or replace view rep_xs_prepay_stat as
select lb,dwtxid,rq,tdbh,ddfy,yf,dwmc,zt,fgsid,id,dwdm
from
(
select 1 lb,a.dwtxid,a.tdrq rq,a.tdbh,nvl(a.ddfy,0)ddfy,nvl(a.yf,0)yf,b.dwmc,a.zt,a.fgsid,a.tdid id,b.dwdm
from xs_td a,dwtx b
where a.dwtxid=b.dwtxid
union all
select 2 lb,a.dwtxid,a.kprq rq,c.tdbh,nvl(c.ddfy,0)ddfy,nvl(c.yf,0),e.dwmc,a.zt,a.fgsid,c.tdid id,e.dwdm
from cw_xsfp a,cw_xsfpmx b,xs_td c,xs_tdhw d,dwtx e
where a.xsfpid=b.xsfpid and b.tdhwid=d.tdhwid and d.tdid=c.tdid and a.dwtxid=e.dwtxid
group by a.dwtxid,a.kprq,c.tdbh,c.ddfy,c.yf,e.dwmc,a.zt,a.fgsid,c.tdid,e.dwdm
)
group by  lb,dwtxid,rq,tdbh,ddfy,yf,dwmc,zt,fgsid,id,dwdm;

prompt
prompt Creating view REP_XS_PROD_SEND
prompt ==============================
prompt
CREATE OR REPLACE VIEW REP_XS_PROD_SEND AS
select lx,tdrq rq,dwtxid,cpid,personid,stsl,dj,ssje,dwmc,tdhwid,
      jsfsid,jsfs,zt,djlx,tdbh,pm,gg,jldw,fgsid,tdid,sxz,cpbm,dqh,dwdm,areacode,dqmc,mc,deptid,khlx,isnet,cnet
from
(
SELECT 1 lx,a.tdrq,a.dwtxid,b.cpid,a.personid,nvl(b.stsl,0)stsl,nvl(b.dj,0)dj,b.ssje
       ,c.dwmc,c.dwdm,b.tdhwid,a.jsfsid,e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,
       a.fgsid,a.tdid,g.sxz,f.cpbm,c.dqh,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet,decode(a.isnet,0,'销售合同',1,'来料外加工单合同')cnet
FROM xs_td a,xs_tdhw b,dwtx c,Cw_Xsfpmx d,jsfs e,kc_dm f,kc_dmsx g,dwdq h,bm t
WHERE  a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
and b.tdhwid=d.tdhwid(+)
and a.jsfsid=e.jsfsid(+)
and b.cpid=f.cpid
AND b.dmsxid=g.dmsxid(+)
AND c.dqh=h.dqh
AND a.deptid=t.deptid
--全部
group by  a.tdrq,a.dwtxid,b.cpid,a.personid,stsl,dj,b.ssje,c.dwmc,c.dwdm,b.tdhwid,a.jsfsid,
           e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,a.fgsid,a.tdid,g.sxz,g.sxz,f.cpbm,
           c.dqh,c.dwdm,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet
union all
SELECT 2 lx,a.tdrq,a.dwtxid,b.cpid,a.personid,nvl(b.stsl,0)stsl,nvl(b.dj,0)dj,b.ssje,
       c.dwmc,c.dwdm,b.tdhwid,a.jsfsid,e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,
       a.fgsid,a.tdid,g.sxz,f.cpbm,c.dqh,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet,decode(a.isnet,0,'销售合同',1,'来料外加工单合同')cnet
FROM xs_td a,xs_tdhw b,dwtx c,Cw_Xsfpmx d,jsfs e,kc_dm f,kc_dmsx g,dwdq h,bm t
WHERE  a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
and b.tdhwid=d.tdhwid
and a.jsfsid=e.jsfsid(+)
and b.cpid=f.cpid
AND b.dmsxid=g.dmsxid(+)
AND c.dqh=h.dqh
AND a.deptid=t.deptid
--已开票
group by  a.tdrq,a.dwtxid,b.cpid,a.personid,stsl,dj,b.ssje,c.dwmc,c.dwdm,b.tdhwid,
          a.jsfsid,e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,a.fgsid,a.tdid,g.sxz,
          f.cpbm,c.dqh,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet
union all
SELECT 3 lx,a.tdrq,a.dwtxid,b.cpid,a.personid,nvl(b.stsl,0)stsl,nvl(b.dj,0)dj,b.ssje,
       c.dwmc,c.dwdm,b.tdhwid,a.jsfsid,e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,
       a.fgsid,a.tdid,g.sxz,f.cpbm,c.dqh,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet,decode(a.isnet,0,'销售合同',1,'来料外加工单合同')cnet
FROM xs_td a,xs_tdhw b,dwtx c,Cw_Xsfpmx d,jsfs e,kc_dm f,kc_dmsx g,dwdq h,bm t
WHERE  a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
and b.tdhwid=d.tdhwid(+)
and d.tdhwid is null
and a.jsfsid=e.jsfsid(+)
and b.cpid=f.cpid
AND b.dmsxid=g.dmsxid(+)
AND c.dqh=h.dqh
AND a.deptid=t.deptid
--未开票
group by  a.tdrq,a.dwtxid,b.cpid,a.personid,stsl,dj,b.ssje,c.dwmc,c.dwdm,b.tdhwid,
          a.jsfsid,e.jsfs,a.zt,a.djlx,a.tdbh,f.pm,f.gg,f.jldw,a.fgsid,a.tdid,
          g.sxz,f.cpbm,c.dqh,h.areacode,h.dqmc,t.mc,a.deptid,a.khlx,a.Isnet
)
order by dwtxid,personid;

prompt
prompt Creating view REP_XS_PROMOTION_STATIC
prompt =====================================
prompt
create or replace view rep_xs_promotion_static as
select a.tdrq,a.tdbh,d.cpbm,d.pm,d.gg,a.tdid,--提单
       a.djlx,a.khlx,a.fgsid,a.dwtxid,nvl(b.stsl,0)stsl,a.personid,a.zt,a.djh,
       b.sl,b.dj,b.jje,f.mc,e.xm, g.dwmc,h.htbh,
       j.sxz,d.jldw,g.dwdm,d.cpid,g.dqh,k.dqmc,k.areacode,b.dmsxid,t.chmc,d.chlbid
from xs_td a,xs_tdhw b,xs_hthw c,kc_dm d,emp e,bm f,dwtx g,xs_ht h,kc_dmsx j,dwdq k,kc_chlb t
where b.tdid=a.tdid
 and b.hthwid=c.hthwid(+)
 and b.cpid=d.cpid
 and a.personid=e.personid(+)
 and a.deptid=f.deptid(+)
 and a.dwtxid=g.dwtxid
 and c.htid=h.htid(+)
 AND b.dmsxid=j.dmsxid(+)
 AND g.dqh=k.dqh
 AND d.chlbid=t.chlbid
 AND a.djlx =2
--广告促销单;

prompt
prompt Creating view REP_XS_SALER_PRIZE
prompt ================================
prompt
CREATE OR REPLACE VIEW REP_XS_SALER_PRIZE AS
SELECT djxz, mc, xm, rq, bh, dwmc, cpbm, pm, gg,jldw,hkrq,sl,jje,fgsid,personid,deptid,id,sxz
FROM
(
SELECT 2 djxz, e.mc,d.xm,a.tdrq rq,a.tdbh bh,c.dwmc,
       f.cpbm,f.pm,f.gg,f.jldw,a.hkrq,sum(nvl(b.sl,0))sl,b.dj,sum(nvl(b.jje,0))jje,a.fgsid,a.personid,a.deptid,a.tdid id,e.sxz
FROM xs_td a,xs_tdhw b,dwtx c,emp d,bm e,kc_dm f,kc_dmsx e
WHERE a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
AND a.personid=d.personid
AND a.deptid=e.deptid
AND b.cpid=f.cpid
AND b.dmsxid=e.dmsxid(+)
GROUP BY e.mc,d.xm,a.tdrq,a.tdbh,c.dwmc,f.cpbm,f.pm,f.gg,f.jldw,a.hkrq,b.dj,a.fgsid,a.personid,a.deptid,a.tdid,e.sxz
UNION ALL
SELECT 1 djxz, e.mc,d.xm,a.kprq rq,a.fphm bh,c.dwmc,
       f.cpbm,f.pm,f.gg,f.jldw,a.hkrq,sum(nvl(b.sl,0))sl,b.hsdj,sum(nvl(b.jshj,0))jje,a.fgsid,a.personid,a.deptid,a.xsfpid id,e.sxz
FROM cw_xsfp a,cw_xsfpmx b,dwtx c,emp d,bm e,kc_dm f,kc_dmsx e
WHERE a.xsfpid=b.xsfpid
AND a.dwtxid=c.dwtxid
AND a.personid=d.personid
AND a.deptid=e.deptid
AND b.cpid=f.cpid
AND b.dmsxid=e.dmsxid(+)
GROUP BY e.mc,d.xm,a.kprq,a.fphm,c.dwmc,f.cpbm,f.pm,f.gg,f.jldw,a.hkrq,b.hsdj,a.fgsid,a.personid,a.deptid,a.xsfpid,e.sxz
)
--GROUP BY djxz, deptid, personid, dwtxid, zt, sl, je,mc,dwmc,fgsid,xm,rq
order by mc,xm
--部门销售统计表;

prompt
prompt Creating view REP_XS_SALER_RESULT
prompt =================================
prompt
create or replace view rep_xs_saler_result as
select a.tdbh,a.dwtxid,b.cpid,b.sl,b.jje,a.jsfsid,d.htbh,e.dwmc,f.cpbm,f.pm,f.gg,f.jldw,g.jsfs
from xs_td a,xs_tdhw b,xs_hthw c,xs_ht d,dwtx e,kc_dm f,jsfs g
where a.tdid=b.tdid and b.hthwid=c.hthwid(+) and c.htid=d.htid(+)
   and a.dwtxid=e.dwtxid(+) and b.cpid=f.cpid and a.jsfsid=g.jsfsid(+)
--业务员销售业绩;

prompt
prompt Creating view REP_XS_TAX_STAT
prompt =============================
prompt
create or replace view rep_xs_tax_stat as
select x.mon,sum(x.je)xsje,sum(x.xsje)sje,sum(x.jshj)jshj,x.fgsid from
(
select to_char(a.kprq,'mm')mon,sum(nvl(b.je,0))je,sum(nvl(b.jshj,0)-nvl(b.je,0))xsje,sum(nvl(b.jshj,0))jshj,a.kprq,a.fgsid
 FROM cw_xsfp a,cw_xsfpmx b
 where a.xsfpid=b.xsfpid and to_char(a.kprq,'yyyy')>=to_char(sysdate,'YYYY')
group by a.kprq,jshj,a.fgsid
) x
group by x.mon,x.fgsid
--销项税统计表;

prompt
prompt Creating view REP_XS_TD_SALER_RESULT
prompt ====================================
prompt
create or replace view rep_xs_td_saler_result as
select a.tdbh,a.dwtxid,b.cpid,b.sl,b.dj,b.jje,a.jsfsid,a.fgsid,a.tdid,
       a.personid,d.htbh,e.dwmc,e.dwdm,f.cpbm,f.pm,f.gg,f.jldw,g.jsfs,a.tdrq,h.sxz,k.xm
       ,t.mc,r.areacode,r.dqmc
from xs_td a,xs_tdhw b,xs_hthw c,xs_ht d,dwtx e,kc_dm f,jsfs g,kc_dmsx h,emp k,bm t,dwdq r
where a.tdid=b.tdid
AND b.hthwid=c.hthwid(+)
AND a.personid=k.personid
AND a.deptid=t.deptid
AND c.htid=d.htid(+)
AND a.dwtxid=e.dwtxid(+)
AND b.cpid=f.cpid
AND a.jsfsid=g.jsfsid(+)
AND b.dmsxid=h.dmsxid(+)
AND e.dqh=r.dqh
--业务员销售业绩;

prompt
prompt Creating view REP_XS_XYED
prompt =========================
prompt
CREATE OR REPLACE VIEW REP_XS_XYED AS
SELECT nvl(a.xyed,0)xyed,a.xydj,nvl(a.hkts,0)hkts,b.fgsid,a.xyedid,a.xysdl,nvl(a.xyed,0)-nvl(a.xysdl,0)kyxyed,
       b.dwtxid,b.dwmc,b.dwdm,b.dqh,c.dqmc,c.areacode
FROM xs_khxyed a,dwtx b,dwdq c
WHERE b.dwtxid = a.dwtxid
AND b.dqh=c.dqh
ORDER BY c.areacode,b.dwdm;

prompt
prompt Creating view SC_DRAW_JZ
prompt ========================
prompt
create or replace view sc_draw_jz as
select a.drawid,a.drawcode,a.drawdate,
       b.cpid,b.drawnum,b.drawprice,b.drawsum,a.storeid,a.deptid,c.CPBM,c.product,c.jldw,d.mc
from sc_drawmaterial a ,sc_drawmaterialdetail b,vw_kc_dm c,bm d
where a.drawid=b.drawid
AND b.cpid=c.cpid
AND a.deptid=d.deptid
and a.state IN(2,8)
and a.isout=0
----生产领料单记账后;

prompt
prompt Creating view SC_JHKGL
prompt ======================
prompt
CREATE OR REPLACE VIEW SC_JHKGL AS
SELECT "CPID","DMSXID","JHKGL" FROM (
  SELECT t.cpid, t.dmsxid, nvl(k.kcl,0)-nvl(l.sdl,0) jhkgl
  FROM
    (SELECT a.cpid, b.dmsxid FROM kc_dm a, kc_dmsx b WHERE a.cpid=b.cpid(+)) t,
    (SELECT k.cpid, nvl(k.dmsxid,-100) dmsxid, SUM(k.zl) kcl FROM kc_wzmx k GROUP BY k.cpid, k.dmsxid) k,
    vw_plan_lock l
  WHERE t.cpid=l.cpid(+) AND nvl(t.dmsxid,-100)=l.dmsxid(+)
  AND   t.cpid=k.cpid(+) AND nvl(t.dmsxid,-100)=k.dmsxid(+)
) WHERE jhkgl <> 0;

prompt
prompt Creating view VW_APPLY_IMPORT_MRP
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_APPLY_IMPORT_MRP AS
SELECT a.wlxqjhid, a.wlxqh, a.fgsid, a.rq,
    b.wlxqjhmxid, b.cpid, b.xgl, --2004-06-14 修改 给b.xgl 一个sl 的别名.因为 Import_MrpGoods用到
    --0 hssl, --2004-06-14 修改打开hssl.因为 Import_MrpGoods用到但是只给他一个0.在类里面会用程序求出
    b.ygl, b.xqrq, b.bz, b.dmsxid, d.sxz, --2004-06-14 新增 sxz
    c.product, c.cpbm, c.jldw, c.deptid, c.hsbl, (nvl(b.xgl,0)-nvl(b.ygl,0)) wgl
FROM sc_wlxqjh a, sc_wlxqjhmx b, vw_kc_dm_exist c, kc_dmsx d
WHERE (nvl(b.xgl,0)-nvl(b.ygl,0))>0 AND a.wlxqjhid = b.wlxqjhid AND b.cpid = c.cpid
AND a.isrefer=1 AND a.zt<>8 AND b.chxz=2 AND b.cpid = d.cpid(+) AND b.dmsxid = d.dmsxid(+) --2004-06-14 新增 sxz的条件
ORDER BY a.wlxqh DESC;

prompt
prompt Creating view VW_APPLY_SINGLE_MRP
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_APPLY_SINGLE_MRP AS
SELECT DISTINCT a.wlxqjhid, a.scjhid, a.deptid, a.wlxqh, a.zt, a.zdrq,
       a.zdrid, a.fgsid, a.rq, a.zdr, a.zsl
FROM sc_wlxqjh a, sc_wlxqjhmx b
WHERE nvl(b.xgl,0)>nvl(b.ygl,0) AND a.wlxqjhid=b.wlxqjhid
AND (a.zt=1 OR (a.isrefer=1 AND a.zt<>8 AND a.zt<>4))
ORDER BY a.wlxqh DESC
--采购申请单引入物料需求计划主表试图;

prompt
prompt Creating view VW_BEAN_BANK_ACCOUNT
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_BANK_ACCOUNT AS
SELECT a.yhzhid, a.yhid, a.zh, a.zhmc, a.zhlx, a.fgsid, b.yhmc,b.dm
FROM yhzh a, yh b WHERE a.yhid = b.yhid
--通过银行帐号lookupbean;

prompt
prompt Creating view VW_BEAN_BUY_APPLY_GOODS
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_BUY_APPLY_GOODS AS
SELECT a.cgsqdid, a.fgsid, a.sqbh,
       b.cgsqdhwid, b.dwtxid, b.cpid, b.sl, b.dj, b.je
FROM cg_sqd a, cg_sqdhw b
WHERE a.cgsqdid = b.cgsqdid
--是采购申请单货物查找申请单视图;

prompt
prompt Creating view VW_BEAN_BUY_ORDER_GOODS
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_BUY_ORDER_GOODS AS
SELECT a.htid, a.fgsid, a.htbh, a.djh,--a.htrq, a.dwtxid,
       b.hthwid, b.cpid, --b.sl, b.dj, b.je, b.jhrq,
       c.hsbl
FROM   cg_ht a, cg_hthw b, kc_dm c
WHERE  a.htid = b.htid AND b.cpid = c.cpid
--通过采购合同货物ID查询采购合同信息;

prompt
prompt Creating view VW_BEAN_BUY_ORDER_STOCK
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_BUY_ORDER_STOCK AS
SELECT t1."JHDID",t1."FGSID",t1."JHDBM",t1."JHDHWID",t1."CPID",t1."SL",t1."HSSL",t1."HTHWID",t1."JE", t2.htid, t2.htbh
FROM
  (SELECT a.jhdid, a.fgsid, a.jhdbm, b.jhdhwid, b.cpid, b.sl, b.hssl, b.hthwid, b.je
   FROM   cg_htjhd a, cg_htjhdhw b
   WHERE  a.jhdid = b.jhdid
  ) t1,
  (
   SELECT x.htid, x.htbh, y.hthwid
   FROM   cg_ht x, cg_hthw y
   WHERE  x.htid = y.htid
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--通过采购合同交货单ID查询交货单编号和采购合同编号信息;

prompt
prompt Creating view VW_BEAN_BUY_PRICE
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_BEAN_BUY_PRICE AS
SELECT a.cgbjid, a.cpid, a.dwtxid, a.bj, a.fgsid
FROM   cg_bj a
--是采购报价,根据报价ID得到相应信息;

prompt
prompt Creating view VW_BEAN_CORP
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_BEAN_CORP AS
SELECT a.dwtxid, a.dwdm, a.dwmc, a.cdm, a.dqh, b.dqmc, a.fgsid, a.deptid, a.personid, a.yfkje, a.yskje,
a.lxr/*联系人*/, a.addr/*地址*/, a.tel/*电话*/,a.yfdj
FROM dwtx a, dwdq b WHERE a.dqh = b.dqh
--是往来单位的视图;

prompt
prompt Creating view VW_BEAN_CORP_CREDIT
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_CORP_CREDIT AS
SELECT a."DWTXID",a."DWDM",a."DWMC",a."CDM",a."DQH",a."DQMC",a."FGSID",a."DEPTID",a."PERSONID", t.xyed, t.hkts, t.xysdl
FROM
(SELECT a.dwtxid, a.dwdm, a.dwmc, a.cdm, a.dqh, b.dqmc, a.fgsid, a.deptid, a.personid
 FROM dwtx a, dwdq b WHERE a.dqh = b.dqh
) a, xs_khxyed t
WHERE a.dwtxid = t.dwtxid(+) AND a.fgsid=t.fgsid(+)
--是往来单位信誉度的视图;

prompt
prompt Creating view VW_BEAN_MRP_GOODS
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_BEAN_MRP_GOODS AS
SELECT b.wlxqjhmxid, a.wlxqh, c.dwmc
FROM   sc_wlxqjhmx b, sc_wlxqjh a,
      (SELECT h.htid, d.dwmc FROM xs_ht h, dwtx d WHERE h.dwtxid = d.dwtxid) c
WHERE  a.wlxqjhid = b.wlxqjhid AND b.htid = c.htid(+)
--根据物料需求明细货物ID查询物料需求计划信息;

prompt
prompt Creating view VW_BEAN_PERSON
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PERSON AS
SELECT a.personid, a.deptid, b.dm, a.bm, a.xm, a.lb, a.zw, a.isdelete,
  decode(a.isdelete, 0, 1, 1, 0, 9, 0, a.isshow) isshow --离职人员在列表是否显示
FROM emp a, bm b
WHERE a.deptid = b.deptid AND b.ismember=0
--根据人员id查询人员信息视图;

prompt
prompt Creating view VW_BEAN_PRODUCE_PROCESS_GOODS
prompt ===========================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PRODUCE_PROCESS_GOODS AS
SELECT b.jgdmxid, a.jgdh
FROM   sc_jgdmx b, sc_jgd a
WHERE  a.jgdid= b.jgdid
--根据加工单明细货物ID查询加工单信息;

prompt
prompt Creating view VW_BEAN_PRODUCE_PROCESS_GOODS2
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PRODUCE_PROCESS_GOODS2 AS
SELECT b.jgdwlid, a.jgdh
FROM   sc_jgdwl b, sc_jgd a
WHERE  a.jgdid= b.jgdid
--根据加工单物料货物ID查询加工单信息;

prompt
prompt Creating view VW_BEAN_PRODUCE_TASK_GOODS
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PRODUCE_TASK_GOODS AS
SELECT b.rwdmxid, a.rwdh
FROM   sc_rwdmx b, sc_rwd a
WHERE  a.rwdid = b.rwdid
--根据生产任务单明细货物ID查询生产任务单信息;

prompt
prompt Creating view VW_BEAN_PRODUCT
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PRODUCT AS
SELECT cpid, cpbm, product, pm, gg, jldw, hsdw, hsbl, chxz, tqq, ztqq, isprops, storeid, isdelete,
  a.scydw, a.scdwgs, a.isbatchno, b.dygs, a.abc, b.chlbid,a.th
FROM vw_kc_dm a, kc_chlb b WHERE a.chlbid=b.chlbid
--是通过物资id得到物资信息视图;

prompt
prompt Creating view VW_BEAN_PRODUCT_STOCK
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_PRODUCT_STOCK AS
SELECT a.cpid, a.cpbm, a.product, a.jldw, a.hsdw, a.hsbl, a.chxz, a.tqq, a.ztqq, --a.jhkgl,
  SUM(nvl(b.kcsl,0)) kcl, SUM(nvl(b.kcsl,0))-SUM(nvl(c.sdl,0)) jhkgl,
  a.scydw, a.scdwgs, a.isprops, a.isbatchno
FROM vw_kc_dm a, kc_kchz b, vw_plan_lock c
WHERE a.cpid=b.cpid(+) AND a.cpid = c.cpid(+)
GROUP BY a.cpid, a.cpbm, a.product, a.jldw, a.hsdw, a.hsbl, a.chxz, a.tqq, a.ztqq,
a.scydw, a.scdwgs, a.isprops, a.isbatchno
 --a.jhkgl
--是通过物资id得到物资信息视图;

prompt
prompt Creating view VW_BEAN_SALE_LADING
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_SALE_LADING AS
SELECT t.tdid, t.tdbh, t.dwtxid, d.dwmc FROM xs_td t, dwtx d WHERE t.dwtxid=d.dwtxid
--通过销售提货单ID查询提单编号和销售合同编号信息;

prompt
prompt Creating view VW_BEAN_SALE_LADING_BILL
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_SALE_LADING_BILL AS
SELECT t1."TDID",t1."FGSID",t1."TDBH",t1."TDHWID",t1."WZDJID",t1."CPID",t1."HTHWID",t1."JJE",t1."SSJE", t2.htid, t2.htbh
FROM
  (SELECT a.tdid, a.fgsid, a.tdbh, b.tdhwid, b.wzdjid, b.cpid, b.hthwid, b.jje, b.ssje
   FROM   xs_td a, xs_tdhw b
   WHERE  a.tdid = b.tdid
  ) t1,
  (
   SELECT x.htid, x.htbh, y.hthwid
   FROM   xs_ht x, xs_hthw y
   WHERE  x.htid = y.htid
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--通过销售合同提货单ID查询提单编号和销售合同编号信息;

prompt
prompt Creating view VW_BEAN_SALE_LADING_OUTTPUT
prompt =========================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_SALE_LADING_OUTTPUT AS
SELECT a.sfdjid, a.fgsid, a.sfdjdh,a.sfrq, b.rkdmxid, b.dj, b.cpid,
          b.dmsxid,b.sl
   FROM   kc_sfdj a, kc_sfdjmx b
   WHERE  a.sfdjid = b.sfdjid
   AND a.djxz='2'
   AND a.zt='8'
--销售发票得到发货单编号;

prompt
prompt Creating view VW_BEAN_SALE_ORDER_GOODS
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_SALE_ORDER_GOODS AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,
       b.hthwid, b.wzdjid,b.stsl,--, b.sl, b.dj, b.jje, b.jhrq
       c.dwmc
FROM   xs_ht a, xs_hthw b, dwtx c
WHERE  a.htid = b.htid AND a.dwtxid=c.dwtxid
--根据销售合同货物ID查询销售合同信息;

prompt
prompt Creating view VW_PRODUCT_LOCK
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_PRODUCT_LOCK AS
SELECT a.fgsid, a.storeid, b.cpid,
  SUM(nvl(b.sl,0)-nvl(b.stsl,0)) sdsl, SUM(nvl(b.hssl,0)-nvl(b.sthssl,0)) sdhssl
FROM xs_td a, xs_tdhw b
WHERE a.tdid = b.tdid AND a.isrefer = 1 AND a.zt <> 4
GROUP BY a.fgsid, a.storeid, b.cpid
--产品的锁定量;

prompt
prompt Creating view VW_BEAN_SALE_PRICE
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_SALE_PRICE AS
SELECT t."WZDJID",t."XSJZJ",t."XSTCL",t."HKTS",t."HKTCL",t."FGSID",t."CPID",t."CPBM",t."PM",t."GG",t."PRODUCT",t."JLDW",t."HSDW",t."TH",t."HSBL",t."ZTQQ",t."WZLBID",t."STOREID",t."ISPROPS", nvl(h.kcsl,0) kcsl, (nvl(h.kcsl,0)-nvl(h.sdsl,0)) kckgl FROM
(
  SELECT k.wzdjid, k.xsjzj, k.xstcl, k.hkts, k.hktcl, k.fgsid, --nvl(k.xsj, k.xsjzj) xsj, k.xsdj
       w.cpid, w.cpbm, w.pm, w.gg, w.product,  --品名规格
       w.jldw, w.hsdw, w.th, w.hsbl, w.ztqq, w.wzlbid, w.storeid, w.isprops
  FROM   xs_wzdj k, vw_kc_dm w
  WHERE  k.cpid = w.cpid
) t,
(
  SELECT h.cpid, h.fgsid, SUM(nvl(h.kcsl,0)) kcsl, SUM(nvl(b.sdsl,0)) sdsl
  FROM kc_kchz h, vw_product_lock b
  WHERE  h.fgsid=b.fgsid(+) AND h.storeid=b.storeid(+) AND h.cpid=b.cpid(+)
  GROUP BY h.cpid, h.fgsid
) h
WHERE t.fgsid=h.fgsid(+) AND t.cpid=h.cpid(+)
--根据wzdjid得到销售物资信息视图;

prompt
prompt Creating view VW_BEAN_STORE
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_BEAN_STORE AS
SELECT DISTINCT a.storeid,a.ckbm, a.ckmc, COUNT(b.kwid) childcount
FROM kc_ck a, kc_kw b
WHERE a.storeid = b.storeid(+)
GROUP BY a.storeid, a.ckmc,a.ckbm
--通过storeid得到仓库信息;

prompt
prompt Creating view VW_BEAN_STORE_AREA
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_STORE_AREA AS
SELECT b.kwid, b.dm, b.mc, a.ckmc, a.storeid
FROM kc_ck a, kc_kw b WHERE a.storeid=b.storeid
--根据库位id查询库位信息视图;

prompt
prompt Creating view VW_BEAN_TECHNICS_ROUTE
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_BEAN_TECHNICS_ROUTE AS
SELECT a.gylxid, a.gylxlxid, a.cpid, b.gylxlxmc
FROM   sc_gylx a, sc_gylxlx b
WHERE  a.gylxlxid = b.gylxlxid
ORDER BY b.gylxlxbh
--是通过工艺路线id工艺路线信息视图;

prompt
prompt Creating view VW_KC_CGRY
prompt ========================
prompt
create or replace view vw_kc_cgry as
select a.sfdjid,a.sfdjdh,a.sfrq
       ,b.cpid,b.sl,b.dj,b.je,a.storeid,a.deptid,a.djxz
from kc_sfdj a,kc_sfdjmx b
where a.sfdjid=b.sfdjid
and a.djxz=1
and a.zt IN(2,8)
union all
select a.sfdjid,a.sfdjdh,a.sfrq
       ,b.cpid,b.sl,b.dj,b.je,a.storeid,a.deptid,a.djxz
from kc_sfdj a,kc_sfdjmx b
where a.sfdjid=b.sfdjid
and a.djxz=7
and a.zt IN(2,8);

prompt
prompt Creating view VW_KC_SYD
prompt =======================
prompt
create or replace view vw_kc_syd as
select a.sfdjid,a.sfdjdh,a.sfrq
       ,b.cpid,b.sl,b.dj,b.je,a.storeid,a.deptid
from kc_sfdj a,kc_sfdjmx b
where a.sfdjid=b.sfdjid
and a.djxz=7
and a.zt=2
--损溢单(已记帐);

prompt
prompt Creating view VW_BM_KC_SY_FC
prompt ============================
prompt
create or replace view vw_bm_kc_sy_fc as
select x.SFDJID,x.SFDJDH,x.SFRQ,x.CPID,x.SL,x.DJ,x.JE,x.DJLB,
       c.product,c.jldw,x.storeid,x.deptid,d.mc,c.cpbm
from
(
select a.sfdjid,a.sfdjdh,a.sfrq,a.cpid,a.sl,a.dj,a.je,1 djlb,a.storeid,a.deptid
from vw_kc_cgry a
union all
select b.drawid sfdjid,b.drawcode sfdjdh,b.drawdate sfrq,b.cpid,b.drawnum*(-1) sl,
b.drawprice dj,b.drawsum*(-1) je,-1 djlb,b.storeid,b.deptid
from sc_draw_jz b
union all
select c.sfdjid,c.sfdjdh,c.sfrq,c.cpid,c.sl,c.dj,c.je,1 djlb,c.storeid,c.deptid
from vw_kc_syd c
)x,vw_kc_dm c,bm d
where x.cpid=c.cpid --and c.chlbid=142
and x.deptid=d.deptid
order by x.sfrq,x.sfdjid;

prompt
prompt Creating view VW_BUYPRIC_QUERY
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_BUYPRIC_QUERY AS
SELECT a.cgbjid, b.pm, b.gg, b.product, b.cpbm, a.cpid, c.sxz
FROM cg_bj a, vw_kc_dm b, kc_dmsx c
WHERE a.cpid = b.cpid AND a.cpid = c.cpid(+) AND a.dmsxid = c.dmsxid(+)
--采购报价;

prompt
prompt Creating view VW_BUY_APPLY
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_BUY_APPLY AS
SELECT a.cgsqdid, b.pm, b.gg, b.cpbm, b.product
FROM cg_sqdhw a, vw_kc_dm_exist b
WHERE a.cpid = b.cpid
--提取采购申请单货物及其产品名称和规格的视图
--用于:采购申请单查询;

prompt
prompt Creating view VW_BUY_BALANCE
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_BUY_BALANCE AS
SELECT a.personid,a.deptid,a.jhdbm,a.jhrq,a.dwtxid,a.storeid,a.dwt_dwtxid
       ,a.zsl,a.fgsid,a.khlx,a.jsfsid,b.dmsxid
       ,b.jhdhwid,b.cpid,nvl(b.je,0)zje,(nvl(b.je,0)-nvl(b.sfje,0))wjsje
FROM cg_htjhd a,cg_htjhdhw b
WHERE a.jhdid=b.jhdid
AND (nvl(b.je,0)-nvl(b.sfje,0))>0
AND a.zt=2
/*
select a.personid,a.deptid,a.dwtxid,a.tdbh,a.tdrq,
b.tdhwid,b.cpid,nvl(b.jje,0)zje,nvl(b.jje,0)-nvl(ssje,0)wjsje,a.tdrq+nvl(c.hkts,0) yhrq,c.hktcl
from xs_td a,xs_tdhw b,xs_wzdj c
where a.tdid=b.tdid and nvl(b.jje,0)-nvl(ssje,0)>0 and b.cpid=c.cpid
ORDER BY a.tdrq
*/
--采购结算
--自动核销
--2004-4-1 只有出库确认后的单据才能核销;

prompt
prompt Creating view VW_BUY_CHECK_COUNT_REPORT
prompt =======================================
prompt
create or replace view vw_buy_check_count_report as
select "DWMC","GET_DATE","CPBM","PM","GG","SXZ","CHECK_NUM","PERSONID_0","CHECK_VERDICT_0","BUYCHECKDATE","REMARK","FILIALEID","CPID","DWTXID","DMSXID","PERSONID","CHECK_VERDICT" from
(select c.dwmc,a.get_date,d.cpbm,d.pm,d.gg,f.sxz,a.check_num,
(select g.xm from emp g where a.personid=g.personid)  personid_0,
decode(a.check_verdict, '1', '合格', '0', '不合格') check_verdict_0,-- a.check_verdict,
a.buycheckdate,a.remark,a.filialeid,
a.cpid,
a.dwtxid,
a.dmsxid,
a.personid,
a.check_verdict
from zl_buycheck a,dwtx c,kc_dm d,kc_dmsx f
where a.dwtxid=c.dwtxid and a.cpid=d.cpid  and a.dmsxid=f.dmsxid(+)
union
select c.dwmc,b.goods_date,d.cpbm,d.pm,d.gg,f.sxz,b.sample_INTEGER,null,
decode(b.check_verdict, '1', '合格', '0', '不合格') check_verdict_0,--b.check_verdict,
b.tryout_date,b.remark,b.filialeid,
b.cpid,
b.dwtxid,
b.dmsxid,
null,
b.check_verdict
from zl_adminiclecheck b,dwtx c,kc_dm d,kc_dmsx f
where b.dwtxid=c.dwtxid and b.cpid=d.cpid and b.dmsxid=f.dmsxid(+))
order by get_date desc
--供应商名称
--供货日期
--产品编码
--品名规格
--规格属性
--抽样数量
--检验员
--检验结论
--检验日期
--备注
--供应商合格率统计表;

prompt
prompt Creating view VW_BUY_INVOICE_DETAIL
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_BUY_INVOICE_DETAIL AS
SELECT t1."JHDID",t1."FGSID",t1."JHDBM",t1."DWTXID",t1."JHRQ",t1."DEPTID",t1."PERSONID",t1."JHDHWID",t1."HTHWID",t1."GYSZYH",t1."ZSL",t1."SL",t1."JE",t1."DJ",t1."SJRKL",t1."CPID",t1."ADDR",t1."NSRDJH",t1."KHH",t1."ZH",t1."XSJ",t1."DMSXID",t1."HSSL",t1."SKPHSL", t2.htid, t2.htbh
FROM
  (
  SELECT a.jhdID, a.fgsid, a.jhdbm,a.dwtxid,a.jhrq,a.deptid,a.personid,b.jhdhwid,b.hthwid,
   b.gyszyh,nvl(b.sl,0)zsl,(nvl(b.sl,0)-nvl(b.skpsl,0)) sl,(nvl(b.sl,0)-nvl(b.skpsl,0))*b.dj je,b.dj,b.sjrkl,b.cpid,
   c.addr,c.nsrdjh,c.khh,c.zh,b.dj xsj,b.dmsxid,b.hssl,b.skphsl
   FROM   cg_htjhd a, cg_htjhdhw b,dwtx c
   WHERE  a.jhdID = b.jhdID and a.dwtxid=c.dwtxid AND a.zt=2 AND (nvl(b.sl,0)-nvl(b.skpsl,0))>0
  ) t1,
  (
   SELECT x.htId, x.htbh, y.hthwid
   FROM   cg_ht x, cg_hthw y
   WHERE  x.htId = y.htId
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--采购发票和提单视图(发票单选择采购提单页面)addr,nsrdjh,khh,zh
--采购发票,采购结算
--引入进货单货物;

prompt
prompt Creating view VW_BUY_INVOICE_SEL_JHD
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_BUY_INVOICE_SEL_JHD AS
SELECT t."JHDID",t."FGSID",t."JHDBM",t."DWTXID",t."JHRQ",t."DEPTID",t."PERSONID",t."DJLX",t."KHLX",t."SL",t."HSSL",t."SKPSL",t."SKPHSL"
FROM(
  SELECT a.jhdID, a.fgsid, a.jhdbm,a.dwtxid,a.jhrq,a.deptid,a.personid,a.djlx,a.khlx,
    nvl(SUM(nvl(b.sl,0)),0) sl, nvl(SUM(nvl(b.hssl,0)),0) hssl,
    nvl(SUM(nvl(b.skpsl,0)),0) skpsl, nvl(SUM(nvl(b.skphsl,0)),0) skphsl --已开票数量和换算数量
  FROM   cg_htjhd a, cg_htjhdhw b
  WHERE  a.jhdID = b.jhdID AND a.zt = 2 AND (nvl(b.je,0)-nvl(b.sfje,0))>0
  GROUP BY a.jhdID, a.fgsid, a.jhdbm,a.dwtxid,a.jhrq,a.deptid,a.personid,a.djlx,a.khlx
) t
WHERE t.sl <> t.skpsl OR t.hssl <> t.skphsl
--采购发票发票选择采购进货单页面;

prompt
prompt Creating view VW_BUY_INVOICE_SEL_STOCK
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_BUY_INVOICE_SEL_STOCK AS
SELECT t1."JHDID",t1."FGSID",t1."JHDBM",t1."DWTXID",t1."JHRQ",t1."DEPTID",t1."PERSONID",t1."JHDHWID",t1."HTHWID",t1."KHLX",t1."GYSZYH",t1."ZSL",t1."SL",t1."JE",t1."DJ",t1."SJRKL",t1."CPID",t1."ADDR",t1."NSRDJH",t1."KHH",t1."ZH",t1."XSJ",t1."DMSXID",t1."HSSL",t1."SKPHSL", t2.htid, t2.htbh
FROM
  (
  SELECT a.jhdID, a.fgsid, a.jhdbm,a.dwtxid,a.jhrq,a.deptid,a.personid,b.jhdhwid,b.hthwid,a.khlx,
   b.gyszyh,nvl(b.sl,0)zsl,(nvl(b.sl,0)-nvl(b.skpsl,0)) sl,(nvl(b.sl,0)-nvl(b.skpsl,0))*b.dj je,b.dj,b.sjrkl,b.cpid,
   c.addr,c.nsrdjh,c.khh,c.zh,b.dj xsj,b.dmsxid,b.hssl,b.skphsl
   FROM   cg_htjhd a, cg_htjhdhw b,dwtx c
   WHERE  a.jhdID = b.jhdID and a.dwtxid=c.dwtxid AND a.zt=2 AND (nvl(b.je,0)-nvl(b.sfje,0))>0 AND (nvl(b.sl,0)-nvl(b.skpsl,0))>0
  ) t1,
  (
   SELECT x.htId, x.htbh, y.hthwid
   FROM   cg_ht x, cg_hthw y
   WHERE  x.htId = y.htId
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--采购发票和提单视图(发票单选择采购提单页面)addr,nsrdjh,khh,zh
--采购发票,采购结算
--引入进货单货物;

prompt
prompt Creating view VW_CG_HT
prompt ======================
prompt
CREATE OR REPLACE VIEW VW_CG_HT AS
SELECT htid, wbid, personid, deptid, czyid, fgsid, isxn, dwtxid, htbh, zsl, hl, htrq, ksrq, jsrq, qddd, ztms, zt, czrq, czy, zje
FROM cg_ht a WHERE nvl(a.isxn,0)=0
--剔除虚拟的采购合同;

prompt
prompt Creating view VW_BUY_NUMBER_REPORT
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_BUY_NUMBER_REPORT AS
SELECT a.fgsid, a.deptid, m.mc, a.dwtxid AS dwt_dwtxid2/*供方单位ID*/, d.dwmc, a.dwtxid AS dwt_dwtxid, a.dwtxid,
       a.personid AS emp_personid/*业务员*/, e.xm, a.czy, a.htbh AS bh, a.htrq,
       1 AS htxz, '其他' htxz_res,
       1 AS htlb, '进口' htlb_res,
       '1' AS gfhth,
       '1' AS pch, b.sl AS zl, b.jhrq, b.dj AS hsdj, b.je,
       1 wzggid, 1 wzcdid, 1 wzpmid, 1 wzczid, k.pm wzpm, 'cd' wzcd, k.gg wzgg, 'cz' wzcz, k.jldw cpdw
FROM vw_cg_ht a, cg_hthw b, dwtx d, emp e, bm m, vw_kc_dm k
WHERE a.htid=b.htid
AND a.dwtxid=d.dwtxid AND a.personid=e.personid AND b.cpid = k.cpid
AND a.deptid = m.deptid
--采购量分析;

prompt
prompt Creating view VW_BUY_ORDER
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_BUY_ORDER AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq, a.zt,
  b.hthwid,b.cpid, b.sl, b.dj, b.je, b.jhrq, b.gyszyh, b.bz,nvl(b.sl,0)-nvl(b.sjjhl,0) wjhl,
  b.sjjhl,b.dmsxid,
  c.product, c.cpbm, c.jldw, c.hsdw, c.hsbl, c.storeid
FROM cg_ht a, cg_hthw b, vw_kc_dm c
WHERE nvl(b.sl,0)-nvl(b.sjjhl,0) > 0 AND a.htid = b.htid AND b.cpid = c.cpid
AND (a.zt=1 OR (a.isrefer=1 AND  a.zt<>8 AND a.zt<>4))
ORDER BY a.htbh DESC
--采购合同和货物视图(交货单选择采购购合同的网页）;

prompt
prompt Creating view VW_BUY_ORDERGOODS
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_BUY_ORDERGOODS AS
SELECT a.jhdid, a.dwtxid, a.fgsid, a.jhdbm, a.jhrq, a.zt, a.storeid, a.djlx,
  b.jhdhwid,b.cpid, b.sl, b.dj, b.je, b.bz, (nvl(b.sl,0)-nvl(b.sjrkl,0)) wrksl, b.sjrkl,
  c.product, c.cpbm, c.jldw, c.hsdw,c.hsbl, (nvl(b.hssl,0)-nvl(b.sjrkhsl,0)) wrkhsl, b.hssl,
  b.sjrkhsl
--, (nvl(b.hssl,0)-nvl(b.sjrkhsl,0)) wrkhssl
FROM cg_htjhd a, cg_htjhdhw b, vw_kc_dm c
WHERE --(nvl(b.sl,0)-nvl(b.sjrkl,0))>0 AND (nvl(b.hssl,0)-nvl(b.sjrkhsl,0))>0 AND
a.jhdid = b.jhdid AND b.cpid = c.cpid AND a.isrefer=1 AND  a.zt<>8 AND a.zt<>4
ORDER BY a.jhdbm
--采购进货单和货物视图(入库单选择采购合同货物管理);

prompt
prompt Creating view VW_BUY_PRICE
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_BUY_PRICE AS
SELECT a."CGBJID",a."CPID",a."DWTXID",a."BJ",a."YHTJ",a."KSRQ",a."JSRQ",a."GYSLH",a."BZ",a."CZRQ",a."CZYID",a."FGSID",a."CZY",a."SFHSSL",a."DMSXID",a."HL",a."WBBJ",a."WBID",a."SFLSBJ", b.pm, b.gg, b.product, b.cpbm
FROM cg_bj a, vw_kc_dm_exist b
WHERE a.cpid = b.cpid
--用于:采购报价查询;

prompt
prompt Creating view VW_CBCP
prompt =====================
prompt
CREATE OR REPLACE VIEW VW_CBCP AS
SELECT a.cpid,b.about_num
FROM cb_assign a, cb_making_about b
WHERE a.cpid = b.cpid(+);

prompt
prompt Creating view VW_CBPRODUCT
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_CBPRODUCT AS
SELECT a.cpid,a.cpbm,a.product,a.jldw,b.tot_assign
FROM vw_kc_dm_exist a, cb_assign b
WHERE a.cpid = b.cpid(+) and a.issale=1;

prompt
prompt Creating view VW_CG_CGHT
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_CG_CGHT AS
SELECT a.jhdid,c.hthwid,c.htid FROM cg_htjhd a,cg_htjhdhw b,cg_hthw c,cg_ht d
WHERE a.jhdid=b.jhdid
AND a.djlx in(1,-1)
AND b.hthwid=c.hthwid
AND d.htid=c.htid
-------采购进(退)货单引用采购合同后采购合同不能取消审批的视图;

prompt
prompt Creating view VW_CG_HTHW
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_CG_HTHW AS
SELECT a.hthwid, a.htid, b.pm, b.gg, b.product, b.cpbm
FROM cg_hthw a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取采购合同货物及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_CG_HTJHDHW
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_CG_HTJHDHW AS
SELECT a.jhdhwid, a.jhdid, b.pm, b.gg, b.product, b.cpbm
FROM cg_htjhdhw a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取采购进货单货物及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_CG_SQD
prompt =======================
prompt
CREATE OR REPLACE VIEW VW_CG_SQD AS
SELECT a.cgsqdid, a.deptid, a.fgsid, a.sqbh, a.sqrq, a.zt,a.czy,
  b.cgsqdhwid, b.dwtxid, b.cpid, b.sl, b.dj, b.je, b.xqrq, b.skhtl,b.dmsxid,d.dwdm, d.dwmc,
  (c.pm || '' || c.gg) product, c.cpbm, c.jldw,c.hsdw, (nvl(b.sl,0)-nvl(b.skhtl,0)) wkhtl
FROM cg_sqd a, cg_sqdhw b, kc_dm c, dwtx d
WHERE a.cgsqdid = b.cgsqdid AND b.cpid= c.cpid AND b.dwtxid=d.dwtxid(+) AND a.isrefer=1 AND a.zt<>8 AND a.zt<>4
AND nvl(b.sl,0)>nvl(b.skhtl,0)
ORDER BY a.sqbh DESC
--采购申请单视图(用于采购合同引入采购申请单);

prompt
prompt Creating view VW_CG_SQDHW
prompt =========================
prompt
CREATE OR REPLACE VIEW VW_CG_SQDHW AS
SELECT a.cgsqdhwid, a.cgsqdid, b.pm, b.gg, b.product,b.cpbm
FROM cg_sqdhw a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取采购合同货物及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_CG_SQD_MASTER
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_CG_SQD_MASTER AS
SELECT a."CGSQDID",a."DEPTID",a."SQBH",a."SQRQ",a."CGYY",a."CZRQ",a."ZSL",a."ZJE",a."CZYID",a."CZY",a."ZT",a."ZTMS",a."FGSID",a."SPRID",a."HL",a."WBID",a."ISREFER", b.dwtxid, c.mc
FROM cg_sqd a, cg_sqdhw b, bm c
WHERE a.cgsqdid = b.cgsqdid AND a.deptid = c.deptid(+)
      AND a.isrefer=1 AND a.zt<>8 AND a.zt<>4
      AND nvl(b.sl,0)>nvl(b.skhtl,0)
ORDER BY a.sqbh DESC;

prompt
prompt Creating view VW_COME_SALE_PRODUCT_PRICE
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_COME_SALE_PRODUCT_PRICE AS
SELECT d.pm,d.gg,d.cpid, d.cpbm,d.product,d.jldw,c.jjbl,c.xsj,c.xsdj,c.hkts,c.hktcl,c.xsjzj, c.xstcl, c.wzdjid, c.fgsid,c.czrq,c.czy,c.czyid,c.isnet FROM
(SELECT a.cpid, a.cpbm, a.product, a.jldw,b.jjbl, b.xsj, b.xsdj, b.hkts,b.hktcl,a.pm,a.gg,
b.xsjzj, b.xstcl, b.wzdjid, b.fgsid,b.czrq,b.czy,b.czyid,b.isnet
FROM (SELECT * FROM vw_kc_dm_exist a WHERE a.issale=1) a, xs_wzdj b
WHERE a.cpid = b.cpid(+) AND (b.Isnet=1 OR b.Isnet IS  NULL)
) c, ((SELECT * FROM vw_kc_dm_exist a WHERE a.issale=1)) d
WHERE d.cpid = c.cpid(+)
--来料加工定价;

prompt
prompt Creating view VW_CUSTER_DAYINCOME
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_CUSTER_DAYINCOME AS
SELECT a.rq,a.dwtxid,a.je,a.zt,c.dwmc,c.dwdm ,a.fgsid ,a.xsjsid ,a.hxje,a.whxje,d.areacode,d.dqmc
FROM cw_xsjs a,dwtx c ,dwdq d
WHERE  a.dwtxid=c.dwtxid and c.dqh=d.dqh
GROUP BY a.rq,a.dwtxid,a.je,a.zt,c.dwmc,c.dwdm ,a.fgsid ,a.xsjsid ,a.hxje,a.whxje,d.areacode,d.dqmc
ORDER BY a.rq,c.dwdm ----收入日报表---按客户汇总   --zt:0=未审核;1=已审核;

prompt
prompt Creating view VW_CUST_ACCOUNT_RECEIVABLE
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_CUST_ACCOUNT_RECEIVABLE AS
SELECT fgsid, dwtxid, SUM(je) ACCOUNT
FROM
(
  SELECT t.dwtxid, SUM(decode(t.djlx, -1, -1, 6, -1, 1)*nvl(w.jje,0)) je, t.fgsid
  FROM xs_td t, xs_tdhw w WHERE t.tdid=w.tdid AND t.zt IN (2,3,8)--已出库,初始化完成,出库确认
  GROUP BY t.dwtxid, t.fgsid
  UNION ALL
  SELECT j.dwtxid, -1*nvl(j.je,0), j.fgsid FROM cw_xsjs j WHERE j.zt IN (1, 8)--审批通过或通过
)
GROUP BY fgsid, dwtxid
--客户信誉度锁定量(应收款);

prompt
prompt Creating view VW_DRAWMATERAIL_QUERY
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_DRAWMATERAIL_QUERY AS
SELECT a.drawid, a.drawdetailid, b.pm, b.gg, b.product, b.cpbm, a.cpid
FROM sc_drawmaterialdetail a, vw_kc_dm b
WHERE a.cpid = b.cpid
--生产领料单查询;

prompt
prompt Creating view VW_DRAW_SELECTMATERAIL
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_DRAW_SELECTMATERAIL AS
SELECT DISTINCT a.jgdid, a.deptid, a.jgdh, a.rq,a.zt,a.zdr, a.jglx, a.sfwjg,
       a.zdrq, a.zdrid, a.fgsid, a.scjhid, a.rwdid, a.zsl, a.describe
FROM sc_jgd a, sc_jgdwl b
WHERE nvl(b.sl,0)>nvl(b.ylsl,0) AND a.jgdid=b.jgdid AND  a.zt<>8 AND a.sfwjg<>1
ORDER BY a.jgdh DESC
--生产领料单选择单选加工单试图,加工单物料中每行至少有一行没有被领完;

prompt
prompt Creating view VW_EMPLOYEE
prompt =========================
prompt
CREATE OR REPLACE VIEW VW_EMPLOYEE AS
SELECT a.gh,a.personid,a.deptid,a.bm,a.xm,a.username,a.Isdeformity,
       a.lb,a.sex,a.date_born,a.zw,a.study,a.date_in,
       b.personid id,b.bxrq,a.isdelete,a.email,a.phone
FROM emp a,rl_zgbxqk b
WHERE a.personid=b.personid(+)
---员工档案卡关连查询;

prompt
prompt Creating view VW_EMPLOYEE_HT
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_EMPLOYEE_HT AS
SELECT a.personid,a.deptid,a.bm,a.xm,a.username,a.Isdeformity,
       a.lb,a.sex,a.date_born,a.zw,a.study,a.date_in,
       c.hth
FROM emp a,rl_zgqtxx c
WHERE  a.personid=c.personid(+);

prompt
prompt Creating view VW_EMPLOY_WAGE_SEARCH
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_EMPLOY_WAGE_SEARCH AS
SELECT b."GZKXID",b."PERSONID",b."DEPTID",b."GZKXZBID",b."GZ000401",b."GZ000408",b."GZ000409",b."GZ000410",b."GZ000411",b."GZ000412",b."GZ000413",b."GZ000414",b."GZ000415",b."GZ000416",b."GZ000417",b."GZ000418",b."GZ000419",b."GZ000420",b."GZ000421",b."GZ000422",b."GZ000423",b."GZ000441",b."GZ000442",b."GZ000461",b."GZ000481",b."GZ000482",b."GZ000501",a.nf,a.yf,c.Isdeformity,C.XM
FROM rl_gzkxzb a,rl_gzkx b ,emp c
WHERE a.gzkxzbid=b.gzkxzbid
AND b.personid=c.personid
--员工工资查询;

prompt
prompt Creating view VW_EMP_SEARCH
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_EMP_SEARCH AS
SELECT a."PERSONID",a."DEPTID",a."BM",a."XM",a."USERNAME",a."USERPASS",a."LASTLOGIN",a."LB",a."SEX",a."DATE_BORN",a."ZW",a."STUDY",a."ADDR",a."PHONE",a."EMAIL",a."DATE_IN",a."SFZHM",a."BZ",a."JG",a."MZ",a."ZC",a."ZZMM",a."ISUSE",a."ISDELETE",a."MOBILE",a."ISSHOW",a."ISDEFORMITY",a."GH",a."LOAN",a."MONTHWAGE",a."FAITH",a."LIVING",a."INTRODUCE",a."FILEFORMAT",a."PHOTO",b.mc
FROM emp a,bm b
WHERE a.deptid=b.deptid and a.isDelete<>1  and a.isDelete<>9
order by a.deptid,a.bm,a.gh,a.isDelete
---员工档案卡关连查询;

prompt
prompt Creating view VW_EM_SEARCH
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_EM_SEARCH AS
SELECT a."PERSONID",a."DEPTID",a."BM",a."XM",a."USERNAME",a."USERPASS",a."LASTLOGIN",a."LB",a."SEX",a."DATE_BORN",a."ZW",a."STUDY",a."ADDR",a."PHONE",a."EMAIL",a."DATE_IN",a."SFZHM",a."BZ",a."JG",a."MZ",a."ZC",a."ZZMM",a."ISUSE",a."ISDELETE",a."MOBILE",a."ISSHOW",a."ISDEFORMITY",a."GH",a."LOAN",a."MONTHWAGE",a."FAITH",a."LIVING",a."INTRODUCE",a."FILEFORMAT",a."PHOTO",b.mc
FROM emp a,bm b
WHERE a.deptid=b.deptid and a.isDelete<>1  and a.isDelete<>9
order by a.deptid,a.bm,a.gh,a.isDelete
---员工档案卡关连查询;

prompt
prompt Creating view VW_KC_CGDD
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_KC_CGDD AS
SELECT a.htid,c.cgsqdhwid,c.cgsqdid FROM cg_ht a,cg_hthw b,cg_sqdhw c
WHERE a.htid=b.htid
AND b.cgsqdhwid=c.cgsqdhwid
-----采购申请单被采购合同引用后不能取消审批所用到的视图;

prompt
prompt Creating view VW_KC_CGRK
prompt ========================
prompt
create or replace view vw_kc_cgrk as
select a.sfdjid,a.sfdjdh,a.sfrq
       ,b.cpid,b.sl,b.dj,b.je,a.storeid,a.deptid,a.djxz,c.jhdj
from kc_sfdj a,kc_sfdjmx b,kc_dm c
where a.sfdjid=b.sfdjid
AND b.cpid=c.cpid
and a.djxz=1
and a.zt IN(2,8);

prompt
prompt Creating view VW_KC_CGSFDJ
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_KC_CGSFDJ AS
SELECT a.sfdjid,c.jhdhwid,c.jhdid FROM kc_sfdj a,kc_sfdjmx b,cg_htjhdhw c
WHERE a.sfdjid=b.sfdjid
AND a.djxz=1
AND b.wjid=c.jhdhwid
---采购进货单被采购入库单引用之后不能取消审批的视图;

prompt
prompt Creating view VW_KC_CKQK
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_KC_CKQK AS
SELECT "FGSID","CPID","CPBM","PM","GG","JLDW","WZLBID","MC","SL","ZSL" FROM (
SELECT a.fgsid,b.cpid,c.cpbm,c.pm,c.gg,c.jldw,d.wzlbid,d.mc,sum(nvl(b.sl,0))sl,
        sum(nvl(b.sl,0))/(SELECT SUM(nvl(f.sl,0)) FROM kc_sfdj e, kc_sfdjmx f WHERE  e.sfdjid=f.sfdjid AND e.djxz=2)zsl
FROM   kc_sfdj a, kc_sfdjmx b,kc_dm c,kc_dmlb d
WHERE  a.sfdjid=b.sfdjid
AND b.cpid=c.cpid
AND c.wzlbid=d.wzlbid
AND a.djxz = 2
GROUP BY a.fgsid,b.cpid,c.cpbm,c.pm,c.gg,c.jldw,d.mc,d.wzlbid
)t ORDER BY t.sl DESC
---出库情况
--销售排行榜;

prompt
prompt Creating view VW_KC_DMSX_EXIST
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_KC_DMSX_EXIST AS
SELECT a.dmsxid, a.cpid, a.sxz, a.isdelete
FROM kc_dmsx a WHERE a.isdelete = 0
--剔除已经删除记录的物资;

prompt
prompt Creating view VW_KC_PACKAGE
prompt ===========================
prompt
create or replace view vw_kc_package as
select distinct  d.jldw,b.package_code||' '||b.package_name packagename ,
                sum(g.drawnum) drawnum,f.drawcode,a1.receivedate,f.drawdate,a1.receivecode,c.sl
                ,c.cpid,c.dmsxid,(d.pm||' '||d.gg) product,e.sxz
                from sc_receiveprod a1, sc_receiveproddetail a,kc_package b,kc_package_detail c ,
                kc_dm d,kc_dmsx e,sc_drawmaterial f , sc_drawmaterialdetail g
                where a1.receiveid=a.receiveid and a.package_id=b.package_id
                and b.package_id=c.package_id and c.cpid=d.cpid and c.dmsxid=e.dmsxid(+)
                and g.cpid=c.cpid and ((g.dmsxid IS NOT NULL AND g.dmsxid = c.dmsxid) OR
                (g.dmsxid IS NULL AND c.dmsxid IS NULL)) and f.drawid=g.drawid
                group by d.jldw,b.package_code||' '||b.package_name,a1.receivedate,f.drawcode,
                f.drawdate,a1.receivecode,c.sl ,c.cpid,c.dmsxid,d.pm||' '||d.gg ,e.sxz
--包装用料情况表;

prompt
prompt Creating view VW_KC_PRODUCT_COLLECT
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_KC_PRODUCT_COLLECT AS
SELECT t1.cpid, t1.fgsid, t1.kcsl, nvl(t2.sdsl, 0) sdsl
FROM
(
  SELECT h.cpid, h.fgsid, SUM(h.zl) kcsl
  FROM  kc_wzmx h GROUP BY h.cpid, h.fgsid
) t1,
(
  SELECT b.cpid, a.fgsid, SUM(nvl(b.sl,0)-nvl(b.stsl,0)) sdsl
  FROM xs_td a, xs_tdhw b
  WHERE a.tdid = b.tdid AND a.isrefer = 1 AND a.zt <> 4
  GROUP BY b.cpid, a.fgsid
) t2
WHERE t1.cpid = t2.cpid(+) AND t1.fgsid=t2.fgsid(+)
--各个分公司库存物资汇总视图
--销售选择产品用到;

prompt
prompt Creating view VW_KC_SCLL
prompt ========================
prompt
create or replace view vw_kc_scll as
select a.drawid,a.drawcode,a.drawdate
       ,b.cpid,b.drawnum,b.drawprice,b.drawsum,a.storeid
from sc_drawmaterial a,sc_drawmaterialdetail b
where a.drawid=b.drawid
and a.isout=0
and a.state=2
--生产领料单(已记帐);

prompt
prompt Creating view VW_KC_SCRK
prompt ========================
prompt
create or replace view vw_kc_scrk as
select a.receiveid,a.receivecode,a.receivedate
       ,b.cpid,b.drawnum,b.drawprice,b.drawsum,a.storeid
from sc_receiveprod a,sc_receiveproddetail b
where a.receiveid=b.receiveid
and a.isout=0
and a.state=2
--生产入库单;

prompt
prompt Creating view VW_KC_SFDJQUERY
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_KC_SFDJQUERY AS
SELECT a.rkdmxid, a.sfdjid, b.pm, b.gg, b.product, b.cpbm, b.cpid --2004-4-28 16:51 新增 b.cpid
FROM kc_sfdjmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取库存收发单据及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_KC_STOREBILL_MAST
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_KC_STOREBILL_MAST AS
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     a.djxz, a.isrefer, a.zt,     a.fgsid
       --decode(a.djxz, 8, '移库单', 2,'销售出库单', 1,'采购入库单', 7,'损益单', '其他入库单') djmc
FROM   kc_sfdj a
WHERE  a.djxz IN(8,2,1,7,9,10)--2=销售出库单, 1=合同入库单, 7=损溢单, 9=其他入库单
--(3=自制收货单5=外加工入库单)
UNION ALL
SELECT a1.receiveid,   a1.sfdjlbid, a1.ytid, a1.storeid, a1.deptid, a1.dwtxid,
       a1.receivecode, a1.receivedate, decode(a1.isout, 1, 5 ,3), a1.isrefer, a1.state,  a1.filialeid
       --decode(a1.isout, 1, '外加工入库单', '自制收货单') djmc
FROM   sc_receiveprod a1
--4=生产领料单, 6=外加工发料单
UNION ALL
SELECT a2.drawid,   a2.sfdjlbid, a2.ytid, a2.storeid, a2.deptid, a2.dwtxid,
       a2.drawcode, a2.drawdate, decode(a2.isout, 1, 6 ,4), a2.isrefer, a2.state,  a2.filialeid
       --decode(a2.isout, 1, '外加工发料单', '生产领料单') djmc
FROM   sc_drawmaterial a2
--(-1 调入)
/*--得到该段时间移库单调入数量--kc__storeid 调入仓库, kc__kwid 调入库位id
UNION ALL
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.kc__storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     -1, a.isrefer, a.zt,   a.fgsid, '移库单' djmc
FROM   kc_sfdj a
WHERE  a.djxz = 8
--得到该段时间移库单调出数量 (8 调出)
UNION ALL
SELECT a.sfdjid, a.sfdjlbid, a.ytid, a.storeid, a.deptid, a.dwtxid,
       a.sfdjdh, a.sfrq,     8, a.isrefer, a.zt,     a.fgsid, '移库单' djmc
FROM   kc_sfdj a
WHERE  a.djxz = 8*/;

prompt
prompt Creating view VW_KC_SY_FC
prompt =========================
prompt
create or replace view vw_kc_sy_fc as
select x.SFDJID,x.SFDJDH,x.SFRQ,x.CPID,x.SL,x.DJ,x.JE,x.DJLB,c.CPBM,c.product,c.jldw,x.storeid,x.mc ,x.deptid,x.ckmc
from
(
select a.sfdjid,d.ckmc||'--'||a.sfdjdh||'--入库:'||c.mc as sfdjdh,a.sfrq,a.cpid,a.sl,a.dj,a.je,1 djlb,a.storeid,c.mc,a.deptid,d.ckmc
from vw_kc_cgry a,bm c,kc_ck d where a.deptid=c.deptid and a.storeid=d.storeid and a.djxz=1
union all
select a.sfdjid,d.ckmc||'--'||a.sfdjdh||'--损益:'||c.mc as sfdjdh,a.sfrq,a.cpid,a.sl,a.dj,a.je,2 djlb,a.storeid,c.mc,a.deptid,d.ckmc
from vw_kc_cgry a,bm c,kc_ck d where a.deptid=c.deptid and a.storeid=d.storeid and a.djxz=7
union all
select b.drawid sfdjid,d.ckmc||'--'||b.drawcode||'--领用部门:'||m.mc sfdjdh,b.drawdate sfrq,b.cpid,b.drawnum sl,b.drawprice dj,
      b.drawsum je,-1 djlb,b.storeid,m.mc,b.deptid,d.ckmc
from sc_draw_jz b,bm m,kc_ck d where b.deptid=m.deptid and b.storeid=d.storeid
)x,vw_kc_dm c
where x.cpid=c.cpid --and c.chlbid=142
order by x.sfrq,x.sfdjid
--采购入库与生产领料;

prompt
prompt Creating view VW_KC_SY_FC2
prompt ==========================
prompt
create or replace view vw_kc_sy_fc2 as
select x.SFDJID,x.SFDJDH,x.SFRQ,x.CPID,x.SL,x.DJ,x.JE,x.DJLB,c.CPBM,c.product,c.jldw,x.storeid,x.mc ,x.deptid,x.ckmc
from
(
select a.sfdjid,d.ckmc||'--'||a.sfdjdh||'--入库:'||c.mc as sfdjdh,a.sfrq,a.cpid,a.sl,a.dj,a.je,1 djlb,a.storeid,c.mc,a.deptid,d.ckmc
from vw_kc_cgry a,bm c,kc_ck d where a.deptid=c.deptid and a.storeid=d.storeid
union all
select b.drawid sfdjid,d.ckmc||'--'||b.drawcode||'--领用部门:'||m.mc sfdjdh,b.drawdate sfrq,b.cpid,b.drawnum sl,b.drawprice dj,
      b.drawsum je,-1 djlb,b.storeid,m.mc,b.deptid,d.ckmc
from sc_draw_jz b,bm m,kc_ck d where b.deptid=m.deptid and b.storeid=d.storeid
)x,vw_kc_dm c
where x.cpid=c.cpid --and c.chlbid=142
order by x.sfrq,x.sfdjid
--采购入库与生产领料;

prompt
prompt Creating view VW_KC_WZMX
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_KC_WZMX AS
SELECT a.wzmxid, a.cpid, a.dmsxid, a.kwid, a.storeid, a.ph, a.zl, a.fgsid, d.sxz, --2004-5-5 17:19 新增 sxz yjg
       b.product, b.cpbm, b.jldw, b.hsbl,a.hszl, --2004-06-09 15:40新增 换算重量
       c.ckmc
FROM kc_wzmx a, vw_kc_dm_exist b, kc_ck c, kc_dmsx d
WHERE a.cpid = b.cpid AND a.storeid = c.storeid
      AND a.cpid = d.cpid(+) AND a.dmsxid = d.dmsxid(+) --2004-5-5 17:19 新增 sxz条件 yjg
--移库单选择物资明细视图;

prompt
prompt Creating view VW_KC_YK
prompt ======================
prompt
create or replace view vw_kc_yk as
select a.sfdjid,a.sfdjdh,a.sfrq
       ,b.cpid,b.sl,b.dj,b.je,a.storeid,a.kc__storeid
from kc_sfdj a,kc_sfdjmx b
where a.sfdjid=b.sfdjid
and a.djxz=8
and a.zt=2
--移库单(已记帐);

prompt
prompt Creating view VW_KHBOM_REPLACE
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_KHBOM_REPLACE AS
SELECT a.cpid, a.sl, a.kc__cpid, a.shl
FROM   sc_bomthj a, vw_kc_dm_exist b
WHERE  a.cpid = b.cpid AND b.isdelete=0
--生产计划中制定客户BOM表替换可选件试图;

prompt
prompt Creating view VW_LADING_SEL_PRODUCT
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_LADING_SEL_PRODUCT AS
SELECT t."WZDJID",t."XSJZJ",t."XSTCL",t."HKTS",t."HKTCL",t."FGSID",t."XSJ",t."XSDJ",t."ISNET",t."CPID",t."CPBM",t."PM",t."GG",t."PRODUCT",t."JLDW",t."ZJM",t."TH",t."JHDJ",t."HSBL",t."TXM", nvl(h.kcsl,0) kcsl, (nvl(h.kcsl,0)-nvl(h.sdsl,0)) kckgl, h.storeid
FROM
(
  SELECT k.wzdjid, k.xsjzj, k.xstcl, k.hkts, k.hktcl, k.fgsid, k.xsj, k.xsdj, nvl(k.isnet,0) isnet,
        w.cpid, w.cpbm, w.pm, w.gg, w.product,  --品名规格
        w.jldw, w.zjm, w.th, w.jhdj, w.hsbl, w.txm
  FROM   xs_wzdj k, vw_kc_dm_exist w
  WHERE  k.cpid = w.cpid AND w.issale=1
) t,
(
  SELECT a.fgsid, a.storeid, a.cpid, a.kcsl, nvl(b.sdsl,0) sdsl
  FROM kc_kchz a, vw_product_lock b
  WHERE a.fgsid = b.fgsid(+) AND a.storeid = b.storeid(+) AND a.cpid = b.cpid(+)
) h
WHERE t.fgsid=h.fgsid(+) AND t.cpid=h.cpid(+)
--k.isnet=1 OR (nvl(k.isnet,0)=0 AND nvl(k.shbj,0) = 1)--已经审批
--AND    k.cpid = kd.cpid
--销售合同选择物资视图;

prompt
prompt Creating view VW_LAD_CUSTCREDIT_LOCK
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_LAD_CUSTCREDIT_LOCK AS
SELECT fgsid, dwtxid, SUM(je) locknum
FROM
(
  SELECT t.dwtxid, nvl(t.zje,0) je, t.fgsid FROM xs_ht t WHERE t.zt IN (1,8)
  UNION ALL
  SELECT j.dwtxid, -1*nvl(j.je,0), j.fgsid FROM cw_xsjs j WHERE j.zt IN (1, 8)--审批通过或通过
)
GROUP BY fgsid, dwtxid
--客户信誉度锁定量__提单;

prompt
prompt Creating view VW_MRP_QUERY
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_MRP_QUERY AS
SELECT a.wlxqjhid, a.wlxqjhmxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_wlxqjhmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取物料需求计划及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_NODE_LIMITS
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_NODE_LIMITS AS
SELECT a."LIMITID",a."NODEID",a."PRIVILIGEID",a."ISDELETE", n.parentnodeid, n.nodecode, n.nodename, n.url, n.intercode, n.nodetype,n.isjit,
         p.priviligecode, p.priviligename
  FROM limitlist a, nodeinfo n, nodeprivilige p
  WHERE n.Isdelete=0
  AND n.isexecute=1--没有删除的和可执行
  AND   a.nodeid = n.nodeid
  AND a.priviligeid = p.priviligeid
  AND nvl(a.Isdelete,0)=0
  --提取结点信息及其权限的视图;

prompt
prompt Creating view VW_ORDERGOODS_SINGLE_ORDER
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_ORDERGOODS_SINGLE_ORDER AS
SELECT DISTINCT a.htid, a.deptid, a.dwtxid, a.personid, a.khlx,a.wbid, a.hl,
       a.htbh, a.htrq, a.fgsid, a.zt,a.zsl, a.zje, c.storeid
FROM cg_ht a, cg_hthw b, kc_dm c
WHERE nvl(b.sl,0)>nvl(b.sjjhl,0) AND a.htid=b.htid AND b.cpid=c.cpid
AND (a.zt=1 OR (a.isrefer=1 AND a.zt<>8 AND a.zt<>4))
ORDER BY a.htbh DESC
--进货单单选采购合同视图;

prompt
prompt Creating view VW_ORDER_CUSTCREDIT_LOCK
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_ORDER_CUSTCREDIT_LOCK AS
SELECT fgsid, dwtxid, SUM(je) locknum
FROM
(
  SELECT y.dwtxid, nvl(y.ysk,0) je, y.fgsid FROM xs_ysk y
  UNION ALL
  --未完成的合同
  SELECT h.dwtxid, nvl(h.zje,0) je, h.fgsid FROM xs_ht h WHERE h.zt IN (1,9)
  UNION ALL
  --已完成的合同
  SELECT h.dwtxid, SUM(nvl(w.jje,0)) je, h.fgsid
  FROM   xs_ht h, xs_hthw t, xs_tdhw w
  WHERE  h.htid = t.htid AND t.hthwid = w.hthwid AND h.zt=8
  GROUP BY h.dwtxid, h.fgsid
  UNION ALL
  --没有订单的提单
  SELECT t.dwtxid, SUM(nvl(w.jje,0)) je, t.fgsid
  FROM xs_td t, xs_tdhw w WHERE t.tdid=w.tdid AND t.zt IN (1,8) AND w.hthwid IS NULL
  GROUP BY t.dwtxid, t.fgsid
  UNION ALL
  SELECT j.dwtxid, -1*nvl(j.je,0), j.fgsid FROM cw_xsjs j WHERE j.zt IN (1, 8)--审批通过或通过
)
GROUP BY fgsid, dwtxid
--客户信誉度锁定量__订单;

prompt
prompt Creating view VW_OTHEROUTSTORE_WRAPPER
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_OTHEROUTSTORE_WRAPPER AS
SELECT DISTINCT
       a.sfdjdh,
       a.sfdjid,
       a.fgsid,
       d.cpbm,
       c.ckmc,
       c.storeid,
       d.pm,
       d.gg,
       e.dwmc,
       g.sxz,
       g.dmsxid,
       sum(b.hssl) hssl,  --换算数量.只有当可销售的纸品的时候才派上用场
       h.ckdgs , --ckdgs .用来确定是不是纸品0=不套打,1=膜格式套打,2=纸格式套打
       d.issale, --销售是否.用来判断须不须要取此数量的hssl
       a.jsr,
       a.sprid,
       f.xm AS spr,
       a.zdr,
       a.zdrid,
       a.sfrq
FROM
     kc_sfdj a,
     kc_sfdjmx b,
     kc_ck c,
     kc_dm d,
     dwtx e,
     emp f,
     kc_dmsx g,
     kc_chlb h-- 存货类别 (
WHERE
     a.sfdjid = b.sfdjid
AND  b.cpid = d.cpid
AND  a.storeid = c.storeid
AND  a.dwtxid = e.dwtxid
AND  a.djxz = 10
AND  b.dmsxid = g.dmsxid(+)
AND  a.sprid = f.personid(+)
AND  d.chlbid = h.chlbid(+)
AND  a.fgsid = b.fgsid
GROUP BY
      a.sfdjdh,
       a.sfdjid,
       a.fgsid,
       d.cpbm,
       c.ckmc,
       c.storeid,
       d.pm,
       d.gg,
       e.dwmc,
       g.sxz,
       g.dmsxid,
       h.ckdgs , --ckdgs .用来确定是不是纸品0=不套打,1=膜格式套打,2=纸格式套打
       d.issale, --销售是否.用来判断须不须要取此数量的hssl
       a.jsr,
       a.sprid,
       f.xm,
       a.zdr,
       a.zdrid,
       a.sfrq
ORDER BY sfdjdh
--销售出库单套打主表sql;

prompt
prompt Creating view VW_OUTPUTLIST_DTL_BILL_WRAPPER
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_OUTPUTLIST_DTL_BILL_WRAPPER AS
SELECT
       a.sfdjid,
       a.fgsid,
       b.cpbm,
       b.gg,
       a.dmsxid,
       a.ph,
       a.sl,
       a.hssl,
       c.sxz,
       d.ckdgs
FROM kc_sfdjmx a,
     kc_dm b,
     kc_dmsx c,
     kc_chlb d-- 存货类别 (
WHERE
      a.cpid = b.cpid
      AND a.djxz = 2
      AND a.dmsxid = c.dmsxid(+)
      AND b.chlbid = d.chlbid(+)
--销售出库单套打从表sql;

prompt
prompt Creating view VW_OUTPUTLIST_MST_BILL_WRAPPER
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_OUTPUTLIST_MST_BILL_WRAPPER AS
SELECT DISTINCT
       a.sfdjdh,
       a.sfdjid,
       a.fgsid,
       d.cpbm,
       c.ckmc,
       c.storeid,
       d.pm,
       d.gg,
       e.dwmc,
       g.sxz,
       g.dmsxid,
       sum(b.hssl) hssl,  --换算数量.只有当可销售的纸品的时候才派上用场
       h.ckdgs , --ckdgs .用来确定是不是纸品0=不套打,1=膜格式套打,2=纸格式套打
       d.issale, --销售是否.用来判断须不须要取此数量的hssl
       a.jsr,
       a.sprid,
       f.xm AS spr,
       a.zdr,
       a.zdrid,
       a.sfrq
FROM
     kc_sfdj a,
     kc_sfdjmx b,
     kc_ck c,
     kc_dm d,
     dwtx e,
     emp f,
     kc_dmsx g,
     kc_chlb h-- 存货类别 (
WHERE
     a.sfdjid = b.sfdjid
AND  b.cpid = d.cpid
AND  a.storeid = c.storeid
AND  a.dwtxid = e.dwtxid
AND  a.djxz = 2
AND  b.dmsxid = g.dmsxid(+)
AND  a.sprid = f.personid(+)
AND  d.chlbid = h.chlbid(+)
AND  a.fgsid = b.fgsid
GROUP BY
      a.sfdjdh,
       a.sfdjid,
       a.fgsid,
       d.cpbm,
       c.ckmc,
       c.storeid,
       d.pm,
       d.gg,
       e.dwmc,
       g.sxz,
       g.dmsxid,
       h.ckdgs , --ckdgs .用来确定是不是纸品0=不套打,1=膜格式套打,2=纸格式套打
       d.issale, --销售是否.用来判断须不须要取此数量的hssl
       a.jsr,
       a.sprid,
       f.xm,
       a.zdr,
       a.zdrid,
       a.sfrq
ORDER BY sfdjdh
--销售出库单套打主表sql;

prompt
prompt Creating view VW_OUTSTORE_DTL_WRAPPER
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_OUTSTORE_DTL_WRAPPER AS
SELECT
       a.sfdjid,
       a.fgsid,
       b.cpbm,
       b.gg,
       a.dmsxid,
       a.ph,
       a.sl,
       a.hssl,
       c.sxz,
       d.ckdgs
FROM kc_sfdjmx a,
     kc_dm b,
     kc_dmsx c,
     kc_chlb d-- 存货类别 (
WHERE
      a.cpid = b.cpid
      AND a.djxz = 10
      AND a.dmsxid = c.dmsxid(+)
      AND b.chlbid = d.chlbid(+)
--销售出库单套打从表sql;

prompt
prompt Creating view VW_PERSON_CCSQ
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_PERSON_CCSQ AS
SELECT c.xm,c.bm,c.username,c.personid,b.rout_ID,a.evection_ID
FROM rl_evection_rout b,emp c,rl_evection_apply a
WHERE  a.personid=c.personid
ORDER BY c.personid
--出差申请查询;

prompt
prompt Creating view VW_PERSON_CREDITCARD
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_PERSON_CREDITCARD AS
SELECT c.deptid, c.dm, c.mc, a.personid, a.bm, a.xm, a.lb, b.ygxykhid, b.xykid, b.ygxykh
FROM emp a, rl_ygxykh b, bm c
WHERE a.personid = b.personid(+) AND a.deptid = c.deptid AND a.isdelete=0
--所有人员信用卡号（用于员工信用卡号设置模块）;

prompt
prompt Creating view VW_PERSON_PXFK
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_PERSON_PXFK AS
SELECT c.xm,c.bm,c.username,c.personid,a.back_ID
FROM emp c,rl_train_back a
WHERE  a.personid=c.personid
ORDER BY c.personid
--员工培训反馈信息表查询;

prompt
prompt Creating view VW_PERSON_ZGXXBD
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_PERSON_ZGXXBD AS
SELECT a.zt,c.xm,c.bm,c.username,c.personid,b.zgxxid,a.bdrq,a.czrq,a.bdlx,a.czy,a.lsh
FROM rl_zgxxbdmx b,emp c,rl_zgxxbd a
WHERE  b.personid=c.personid
AND b.zgxxid=a.zgxxid(+)
ORDER BY c.personid
--用于员工信息变动查询;

prompt
prompt Creating view VW_PLAN_SALEDETAIL
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_PLAN_SALEDETAIL AS
SELECT a."HTHWID",a."HTID",a."HSSL",a."WZDJID",a."SL",a."XSJ",a."JHRQ",a."BZ",a."STSL",a."DMSXID",a."ZT",a."YJHSL",a."CPID",a."JSRQ",a."HTBH", nvl(k.kcl,0)-nvl(b.sdl,0) jhkgl
FROM(
  SELECT a.hthwid, a.htid, a.hssl, a.wzdjid, a.sl,
      a.xsj, a.jhrq, a.bz, a.stsl, a.dmsxid, a.zt, a.yjhsl,
      b.cpid, c.jsrq, c.htbh
  FROM xs_hthw a, xs_wzdj b, xs_ht c
  WHERE nvl(a.sl,0)>nvl(a.yjhsl,0) AND a.wzdjid=b.wzdjid AND a.htid=c.htid AND c.Isproduce<>0
) a, vw_plan_lock b,
(SELECT k.cpid, nvl(k.dmsxid,-100) dmsxid, SUM(k.zl) kcl FROM kc_wzmx k GROUP BY k.cpid, k.dmsxid) k
WHERE  a.cpid =b.cpid(+) AND nvl(a.dmsxid,-100)=b.dmsxid(+)
AND    a.cpid =k.cpid(+) AND nvl(a.dmsxid,-100)=k.dmsxid(+)
ORDER BY a.htbh DESC
--生产计划引入销售合同主表时，得到从表信息(试图);

prompt
prompt Creating view VW_PLAN_SINGLE_SALEORDER
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_PLAN_SINGLE_SALEORDER AS
SELECT DISTINCT a.htid, a.dwtxid, a.personid, a.khlx,a.qtxx,
       a.htbh, a.htrq, a.fgsid, a.zt, a.zsl, a.zje, a.ksrq, a.jsrq
FROM xs_ht a, xs_hthw b
WHERE nvl(b.sl,0)>nvl(b.yjhsl,0) AND a.htid=b.htid AND a.isrefer=1 AND a.zt<>8 AND a.zt<>4 AND a.Isproduce<>0
ORDER BY a.htbh DESC
--生产计划单选销售合同主表视图;

prompt
prompt Creating view VW_PROCESS_SINGLESEL_TASK
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_PROCESS_SINGLESEL_TASK AS
SELECT DISTINCT a.rwdh, a.rwdid, a.deptid, a.rq, a.fgsid, a.scjhid,a.wlxqjhid, a.rwlx
FROM sc_rwd a, sc_rwdmx b
WHERE nvl(b.sl,0)>nvl(b.yjgl,0) AND a.rwdid=b.rwdid AND (a.isrefer=1 AND a.zt<>8)
ORDER BY a.rwdh DESC
--生产加工单引入任务单主表信息;

prompt
prompt Creating view VW_PROCESS_SINGLESEL_WLXQ
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_PROCESS_SINGLESEL_WLXQ AS
SELECT DISTINCT a.wlxqjhid, a.wlxqh, a.deptid, a.rq, a.fgsid, a.zsl, a.zdr, a.jhlx,c.deptid scdeptid,a.scjhid
FROM sc_wlxqjh a, sc_wlxqjhmx b, kc_dm c
WHERE nvl(b.jlxql,0)>nvl(b.yprwl,0) AND  (b.chxz IS NULL OR b.chxz=1) AND a.wlxqjhid=b.wlxqjhid AND b.cpid = c.cpid
AND a.isrefer=1 AND a.zt<>8 AND a.zt<>4
ORDER BY a.wlxqh DESC
--生产加工单引入物料需求主表;

prompt
prompt Creating view VW_PRODUCEPLAN_SEL_SALE
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_PRODUCEPLAN_SEL_SALE AS
SELECT a."HTID",a."FGSID",a."HTBH",a."ZT",a."JSRQ",a."DWTXID",a."HTHWID",a."WZDJID",a."SL",a."JHRQ",a."DMSXID",a."BZ",a."YJHSL",a."WJHSL",a."SXZ",a."PRODUCT",a."CPBM",a."JLDW",a."CPID",a."MINSL",a."ZTQQ",a."SCYDW",a."SCDWGS",a."WZLBID", nvl(k.kcl,0)-nvl(b.sdl,0) jhkgl, c.dwmc, c.dwdm, NULL scsl FROM
(
  SELECT a.htid, a.fgsid, a.htbh, a.zt, a.jsrq, a.dwtxid,
    b.hthwid, b.wzdjid, b.sl, b.jhrq, b.dmsxid, b.bz, b.yjhsl, (nvl(b.sl,0)-nvl(b.yjhsl,0)) wjhsl, e.sxz,
    c.product, c.cpbm, c.jldw, c.cpid,
    d.minsl, d.ztqq, d.scydw, d.scdwgs,d.wzlbid
  FROM xs_ht a, xs_hthw b, vw_xs_wzdj c, kc_dm d, kc_dmsx e
  WHERE a.htid = b.htid AND b.wzdjid = c.wzdjid AND c.cpid = d.cpid AND b.dmsxid=e.dmsxid(+)
  AND nvl(b.sl,0)>nvl(b.yjhsl,0) AND a.isrefer=1 AND a.zt<>4 AND a.Isproduce<>0
) a, vw_plan_lock b, dwtx c,
(SELECT k.cpid, nvl(k.dmsxid,-100) dmsxid, SUM(k.zl) kcl FROM kc_wzmx k GROUP BY k.cpid, k.dmsxid) k
WHERE a.cpid = b.cpid(+) AND nvl(a.dmsxid,-100) = b.dmsxid(+)
AND   a.cpid = k.cpid(+) AND nvl(a.dmsxid,-100) = k.dmsxid(+)
AND   a.dwtxid=c.dwtxid
ORDER BY a.htbh DESC
--销售合同视图(生产计划选择销售合同);

prompt
prompt Creating view VW_PRODUCEPLAN_SEL_STORE
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_PRODUCEPLAN_SEL_STORE AS
SELECT a.cpid, a.cpbm, a.product, a.jldw, a.maxsl, a.tqq, NULL dmsxid, NULL sxz,
  SUM(b.zl) kcsl, (nvl(a.maxsl,0)-SUM(b.zl)) cesl
FROM vw_kc_dm_exist a, kc_wzmx b
WHERE a.cpid = b.cpid
GROUP BY a.cpid, a.cpbm, a.product, a.jldw, a.maxsl, a.tqq, a.maxsl
ORDER BY a.cpbm
--:1需要根据fgsid再过滤
--当前库存量视图(生产计划引入库存量差额);

prompt
prompt Creating view VW_PRODUCEPROCESS_SEL_TASK
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_PRODUCEPROCESS_SEL_TASK AS
SELECT x."RWDID",x."RWDH",x."DEPTID",x."FGSID",x."ZT",x."CPID",x."SL",x."SCSL",x."YJGL",x."WJGL",x."RWDMXID",x."GYLXID",x."DMSXID",x."PRODUCT",x."CPBM",x."JLDW",x."WJGSCL"
FROM
(
SELECT a.rwdid, a.rwdh, a.deptid, a.fgsid,a.zt,
  b.cpid, b.sl,b.scsl, b.yjgl, (nvl(b.sl,0)-nvl(b.yjgl,0)) wjgl,b.rwdmxid,b.gylxid,b.dmsxid,
  c.product, c.cpbm, c.jldw, (nvl(b.scsl,0)-nvl(b.yjgscl,0)) wjgscl
FROM sc_rwd a, sc_rwdmx b, vw_kc_dm_exist c
WHERE a.rwdid = b.rwdid AND b.cpid = c.cpid AND a.zt=1
) x
WHERE x.wjgl>0
ORDER BY x.rwdh Desc
--生产任务单视图(生产加工单引入任务单);

prompt
prompt Creating view VW_PRODUCETASK_SEL_MRP
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_PRODUCETASK_SEL_MRP AS
SELECT x."WLXQJHID",x."WLXQH",x."FGSID",x."SCJHID",x."RQ",x."WLXQJHMXID",x."CPID",x."XQL",x."SCJHMXID",x."CHXZ",x."XQRQ",x."YPRWL",x."WPRWL",x."GYLXID",x."DMSXID",x."JLXQL",x."WPRWSCL",x."PRODUCT",x."CPBM",x."JLDW",x."DEPTID",x."SCYDW", y.ksrq, y.jgyq
FROM
(
  SELECT a.wlxqjhid, a.wlxqh, a.fgsid, a.scjhid, a.rq,
    b.wlxqjhmxid, b.cpid,b.xql, b.scjhmxid, b.chxz, b.xqrq, b.yprwl, (nvl(b.jlxql,0)-nvl(b.yprwl,0)) wprwl,
    b.gylxid, b.dmsxid, b.jlxql, (nvl(b.xql,0)-nvl(b.yprwcsl,0)) wprwscl,
    c.product, c.cpbm, c.jldw, c.deptid, c.scydw
  FROM sc_wlxqjh a, sc_wlxqjhmx b, vw_kc_dm_exist c
  WHERE a.wlxqjhid = b.wlxqjhid AND b.cpid = c.cpid AND a.zt = 1
) x, sc_jhmx y
WHERE x.scjhmxid = y.scjhmxid(+) and x.wprwl>0 AND (x.chxz IS NULL OR x.chxz<>2)
ORDER BY x.wlxqh DESC
--物料需求计划视图(生产任务单选择物料需求计划合同);

prompt
prompt Creating view VW_QUALITY_ORDER
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_QUALITY_ORDER AS
SELECT a."CARDID",a."DMSXID",a."CPID",a."CARDDATE",a."QUALITYER",a."SALENUM",a."OTHERNUM",a."PRODUCENUM",a."BATNO",a."MEMO",a."CREATEDATE",a."CREATORID",a."CREATOR",a."PRODUCEGRADE",a."DISPARTNUM",a."PRODUCEAREA",a."LINENUM",a."DEPTID",a."PAGENUM",a."GROSSNUM",b.cpbm,c.sxz,b.pm||b.gg product FROM zl_certifiedcard a,kc_dm b,kc_dmsx c WHERE a.cpid=b.cpid AND a.dmsxid=c.dmsxid;

prompt
prompt Creating view VW_RECEIVE_SEL_PROCESS
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_RECEIVE_SEL_PROCESS AS
SELECT a.jgdid, a.jgdh, a.deptid, a.rq, a.fgsid, b.cpid sjcpid,
       b.sl, b.jgdmxid, c.cpid, (c.sl) fsl, d.wzmxid, d.dmsxid, d.kwid
FROM sc_jgd a, sc_jgdmx b, sc_bom c, kc_wzmx d
WHERE a.jgdid = b.jgdid AND b.cpid = c.sjcpid AND c.cpid=d.cpid
ORDER BY a.jgdh Desc
--生产加工单视图(生产领料单引入加工单以及BOM表);

prompt
prompt Creating view VW_REJECT_REPORT_FILM
prompt ===================================
prompt
create or replace view vw_reject_report_film as
select
a.cpid,
a.dmsxid,
a.personid,
a.productcheckno,
b.cpbm,b.pm,b.gg,
c.sxz,
a.buycheckdate,
(select d.xm  from emp d where a.personid=d.personid) personid_0,
(select e.standardname from zl_checkstandard e where a.standardid=e.standardid) standardid_0,
a.check_num,
a.reject_num,
a.filialeid
from zl_prodcheck a,kc_dm b,kc_dmsx c
where a.cpid=b.cpid and a.dmsxid=c.dmsxid(+) and a.billtype='1' order by buycheckdate desc;

prompt
prompt Creating view VW_REJECT_REPORT_WRAPPER
prompt ======================================
prompt
create or replace view vw_reject_report_wrapper as
select
a.cpid,
a.dmsxid,
a.personid,
a.productcheckno,
b.cpbm,b.pm,b.gg,
c.sxz,
a.buycheckdate,
(select d.xm  from emp d where a.personid=d.personid) personid_0,
(select e.standardname from zl_checkstandard e where a.standardid=e.standardid) standardid_0,
a.check_num,
a.reject_num,
a.filialeid
from zl_prodcheck a,kc_dm b,kc_dmsx c
where a.cpid=b.cpid and a.dmsxid=c.dmsxid(+) and a.billtype='2' order by buycheckdate desc;

prompt
prompt Creating view VW_SALEOUTSTORE_SINGLE_LADDING
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_SALEOUTSTORE_SINGLE_LADDING AS
SELECT DISTINCT a.tdid, a.deptid, a.dwtxid, a.personid, a.storeid,
       a.tdbh, a.tdrq, a.jsfsid, a.fgsid, a.zt,  --03:26 15:21 新增 a.jsfsid
       a.khlx --2004-4-22 10:45 新增客户类型
FROM xs_td a, xs_tdhw b
WHERE abs(nvl(b.sl,0))>abs(nvl(b.stsl,0)) AND a.tdid=b.tdid
--AND a.zt=1  2004-4-23 17:37 去掉
      AND a.isRefer=1 AND a.zt IN (1,2) --2004-05-28 18:01 修改原来的zt<>4 <>8 <>2 为现在的这样
      AND a.isinit=0  --2004-4-28 20:02 新增
ORDER BY a.tdbh DESC
--销售出库单单选销售提单视图;

prompt
prompt Creating view VW_SALER
prompt ======================
prompt
create or replace view vw_saler as
select distinct a.personid,a.deptid,a.tdrq rq,a.fgsid
from xs_td a
where  a.zt IN(3,8)
--业务员奖金
/*
select distinct a.xsjsid,a.deptid,a.jsfsid,a.personid,a.dwtxid,a.djxz,a.djh,a.rq,a.jsdh,a.je
                ,a.zh,a.yh,a.czrq,a.ztms,a.fgsid,a.czyid,a.czy,a.zt,a.bz,a.sprid,a.khlx,a.hxje,a.whxje
from cw_xsjs a,cw_xsjshx b
where a.xsjsid= b.xsjsid(+)
AND a.zt IN(1,2,8)
2004-4-17改为依据提单为基础
*/;

prompt
prompt Creating view VW_SALER_CJJ
prompt ==========================
prompt
create or replace view vw_saler_cjj as
select a.deptid,a.personid,a.tdrq rq,a.yf,a.dwtxid,
       a.tdbh,a.khlx,
       b.dj,b.jje,b.sl,b.tdhwid,
       (nvl(b.cjtcl,0)*0.01*abs((nvl(b.dj,0)-nvl(b.jzj,0)))*nvl(b.sl,0))cjj,
       ((nvl(b.dj,0)-nvl(b.jzj,0))*nvl(b.sl,0))xscj,
        b.jzj,f.sfws,b.hlts
        ,g.pm,g.gg,g.cpbm,g.jldw,b.hltcl,b.jxts,b.cjtcl,(nvl(b.hlts,0)*nvl(b.jje,0))yxtslx,e.gls
from xs_td a,xs_tdhw b,dwtx e,dwdq f,kc_dm g
where  a.tdid=b.tdid
and a.dwtxid=e.dwtxid(+)
AND b.cpid=g.cpid(+)
and e.dqh=f.dqh(+)
AND a.zt=8
--业务员差价奖
--销售价:提单单价
--2004-4-17只有出库确认后的提单才计算差价奖
--初始完成不计差价奖
--2004-4-30 d.cjtcl---b.cjtcl
--cjtcl jxts  hltcl jzj hlts;

prompt
prompt Creating view VW_SALER_CJJ_TWO
prompt ==============================
prompt
create or replace view vw_saler_cjj_two as
select a.deptid,a.personid,a.tdrq rq,a.yf,a.dwtxid,
       a.tdbh,a.khlx,
       b.dj,b.jje*nvl(g.fundxs,0) jje,b.sl,b.tdhwid,
       (nvl(b.cjtcl,0)*0.01*abs((nvl(b.dj,0)-nvl(b.jzj,0)))*nvl(b.sl,0))cjj,
       ((nvl(b.dj,0)-nvl(b.jzj,0))*nvl(b.sl,0))xscj,
        b.jzj,d.sfws,b.hlts
        ,e.pm,e.gg,e.cpbm,e.jldw,b.hltcl,b.jxts,b.cjtcl,(nvl(b.hlts,0)*nvl(b.jje,0))yxtslx,c.gls
from xs_td a,xs_tdhw b,dwtx c,dwdq d,kc_dm e,xs_khxyed f,xs_khdjxs g
where  a.tdid=b.tdid
and a.dwtxid=c.dwtxid(+)
AND b.cpid=e.cpid(+)
and c.dqh=d.dqh(+)
AND a.dwtxid=f.dwtxid(+)
AND f.xydj=g.xydj
AND a.zt=8
--业务员差价奖
--销售价:提单单价
--2004-4-17只有出库确认后的提单才计算差价奖
--初始完成不计差价奖
--2004-4-30 d.cjtcl---b.cjtcl
--cjtcl jxts  hltcl jzj hlts;

prompt
prompt Creating view VW_SALER_DAYINCOME
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_SALER_DAYINCOME AS
SELECT a.rq,a.je,a.zt,c.xm,a.personid,d.mc ,a.fgsid,a.xsjsid  ,a.hxje,a.whxje
FROM cw_xsjs a,emp c,bm d
WHERE a.personid=c.personid(+) AND a.deptid=d.deptid(+)
GROUP BY a.rq,a.je,a.zt,c.xm,a.personid,d.mc ,a.fgsid,a.xsjsid  ,a.hxje,a.whxje
ORDER BY a.personid
--收入日报表---按业务员汇总   --zt:0=未审核;1=已审核;9=审批中(未审);

prompt
prompt Creating view VW_SALER_JJDETAIL
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_SALER_JJDETAIL AS
SELECT a.nf,a.yf,a.sfjz,a.lx,b."JJID",b."PERSONID",b."DEPTID",b."JJZBID",b."SWBT",b."CGJ",b."GZ000266",b."TCJ",b."GZ000271",b."GZ000272",b."GZ000273",b."GZ000274",b."GZ000275",b."GZ000276",b."GZ000277",b."GZ000278",b."GZ000279",b."GZ000280",b."AVGCJTCL",b."SL",b."XSA",b."XSB",b."XSC",b."XSD",b."RLL",b."JJ",b."XSJE",b."GZ000290",b."GZ000302"
FROM xs_jjzb a ,xs_jj b
WHERE a.jjzbid=b.jjzbid
--奖金明细;

prompt
prompt Creating view VW_SALER_TCJ
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SALER_TCJ AS
select a.personid,a.djh,a.rq,a.jsdh,b.jsje je,a.zh,a.yh,a.bz,a.khlx,a.dwtxid,a.jsfsid,
       b.tdhwid,b.tcl,b.tcj,
       c.dwdm,d.dqmc,e.jsfs,c.dwmc
from cw_xsjs a,cw_xsjshx b,dwtx c,dwdq d,jsfs e
where  a.xsjsid=b.xsjsid
AND a.dwtxid=c.dwtxid
AND c.dqh=d.dqh
AND a.jsfsid=e.jsfsid
AND a.zt =8
--业务员提成奖
--SELECT SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01)tcj FROM xs_td a,xs_tdhw b WHERE a.tdid=b.tdid AND a.Isinit=1;

prompt
prompt Creating view VW_SALER_TCJ_INIT
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_SALER_TCJ_INIT AS
select a.personid,a.tdbh djh,a.tdrq rq, '初始提单' jsdh,a.zje je,NULL zh,NULL yh,'' bz,a.khlx,a.dwtxid,a.jsfsid,
       b.hltcl tcl,SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01)tcj,
       c.dwdm,d.dqmc,e.jsfs,c.dwmc
from xs_td a,xs_tdhw b,dwtx c,dwdq d,jsfs e
where  a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
AND c.dqh=d.dqh
AND a.jsfsid=e.jsfsid
AND a.isinit=1
GROUP BY
a.personid,a.tdbh,a.tdrq, a.zje,a.khlx,a.dwtxid,a.jsfsid,
c.dwdm,d.dqmc,e.jsfs,c.dwdm,d.dqmc,e.jsfs,b.hltcl,c.dwmc
--业务员提成奖
--初始化提单的提成奖
--SELECT SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01)tcj FROM xs_td a,xs_tdhw b WHERE a.tdid=b.tdid AND a.Isinit=1;

prompt
prompt Creating view VW_SALER_TCJ_INIT2
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_SALER_TCJ_INIT2 AS
select a.personid,a.tdbh djh,a.tdrq rq, '初始提单' jsdh,a.zje je,NULL zh,NULL yh,'' bz,a.khlx,a.dwtxid,a.jsfsid,
       b.hltcl tcl,SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01*nvl(g.adjustxs,0)*0.01)tcj,
       c.dwdm,d.dqmc,e.jsfs,c.dwmc
from xs_td a,xs_tdhw b,dwtx c,dwdq d,jsfs e,xs_khxyed f,xs_khdjxs g
where  a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
AND c.dqh=d.dqh
AND a.jsfsid=e.jsfsid
AND a.dwtxid=f.dwtxid(+)
AND f.xydj=g.xydj
AND a.isinit=1
GROUP BY
a.personid,a.tdbh,a.tdrq, a.zje,a.khlx,a.dwtxid,a.jsfsid,
c.dwdm,d.dqmc,e.jsfs,c.dwdm,d.dqmc,e.jsfs,b.hltcl,c.dwmc
--业务员提成奖
--初始化提单的提成奖
--SELECT SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01)tcj FROM xs_td a,xs_tdhw b WHERE a.tdid=b.tdid AND a.Isinit=1;

prompt
prompt Creating view VW_SALER_TCJ_TWO
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_SALER_TCJ_TWO AS
select a.personid,a.djh,a.rq,a.jsdh,nvl(b.jsje,0)*g.fundxs*0.01 je,a.zh,a.yh,a.bz,a.khlx,a.dwtxid,a.jsfsid,
       b.tdhwid,b.tcl,b.tcj*nvl(g.adjustxs,0)*0.01 tcj,
       c.dwdm,d.dqmc,e.jsfs,c.dwmc
from cw_xsjs a,cw_xsjshx b,dwtx c,dwdq d,jsfs e,xs_khxyed f,xs_khdjxs g
where  a.xsjsid=b.xsjsid
AND a.dwtxid=c.dwtxid
AND c.dqh=d.dqh
AND a.jsfsid=e.jsfsid
AND a.dwtxid=f.dwtxid(+)
AND f.xydj=g.xydj
AND a.zt =8
--业务员提成奖
--SELECT SUM(nvl(b.jje,0)*nvl(b.hltcl,0)*0.01)tcj FROM xs_td a,xs_tdhw b WHERE a.tdid=b.tdid AND a.Isinit=1;

prompt
prompt Creating view VW_SALER_TEST
prompt ===========================
prompt
create or replace view vw_saler_test as
select a.deptid,a.personid,a.tdrq rq,a.yf,a.dwtxid,
       a.tdbh,a.khlx,
       b.dj,b.jje,b.sl,
       (nvl(d.cjtcl,0)*0.01*abs((nvl(b.dj,0)-nvl(d.jzj,0)))*nvl(b.sl,0))cjj,
       ((nvl(b.dj,0)-nvl(d.jzj,0))*nvl(b.sl,0))xscj,
        d.jzj,d.hltcl,d.jxts,d.cjtcl,(nvl(d.hlts,0)*nvl(b.jje,0))yxtslx,d.hlts
        --,f.sfws
        --,g.pm,g.gg,g.cpbm,g.jldw
from xs_td a,xs_tdhw b,xs_hthw d--,dwtx e,dwdq f,kc_dm g
where  a.tdid=b.tdid
and b.hthwid=d.hthwid
--and a.dwtxid=e.dwtxid(+)
--AND b.cpid=g.cpid(+)
--and e.dqh=f.dqh(+)
AND a.zt=8;

prompt
prompt Creating view VW_SALE_AUTOBALANCE
prompt =================================
prompt
create or replace view vw_sale_autobalance as
select a.personid,a.deptid,a.dwtxid,a.tdbh,a.tdrq,b.ssje,a.khlx,a.fgsid,a.isnet,
      b.tdhwid,b.cpid,nvl(b.jje,0)zje,nvl(b.jje,0)-nvl(b.ssje,0)wjsje,
       a.tdrq+nvl(c.hkts,0) yhrq,b.hltcl hktcl,-1 px
from xs_td a,xs_tdhw b,xs_wzdj c--,xs_hthw d
where a.tdid=b.tdid
and nvl(b.jje,0)-nvl(ssje,0)<>0
and b.wzdjid=c.wzdjid
--AND b.hthwid=d.hthwid
and a.zt IN(8,3)
--and c.isnet=0
--ORDER BY a.tdrq
/*
UNION ALL
select a.personid,a.deptid,a.dwtxid,a.tdbh,a.tdrq,b.ssje,a.khlx,a.fgsid,a.isnet,
b.tdhwid,b.cpid,nvl(b.jje,0)zje,nvl(b.jje,0)-nvl(b.ssje,0)wjsje,a.tdrq+nvl(c.hkts,0) yhrq,b.hltcl hktcl,1 px
from xs_td a,xs_tdhw b,xs_wzdj c--,xs_hthw d
where a.tdid=b.tdid
and nvl(b.jje,0)-nvl(ssje,0)>0
and b.cpid=c.cpid
--AND b.hthwid=d.hthwid
and a.zt IN(8,3)
*/
--销售结算
--自动核销;

prompt
prompt Creating view VW_SALE_BALANCE
prompt =============================
prompt
create or replace view vw_sale_balance as
select a.personid,a.deptid,a.dwtxid,a.tdbh,a.tdrq,b.ssje,a.khlx,
b.tdhwid,b.cpid,nvl(b.jje,0)zje,nvl(b.jje,0)-nvl(b.ssje,0)wjsje,a.tdrq+nvl(c.hkts,0) yhrq,b.hltcl hktcl
from xs_td a,xs_tdhw b,xs_wzdj c--,xs_hthw d
where a.tdid=b.tdid
and nvl(b.jje,0)-nvl(ssje,0)<>0
and b.wzdjid=c.wzdjid
--AND b.hthwid=d.hthwid
and a.zt IN(8,3)
ORDER BY a.tdrq
--销售结算
--自动核销;

prompt
prompt Creating view VW_SALE_BALANCE_IMPORT_TD
prompt =======================================
prompt
create or replace view vw_sale_balance_import_td as
select   a.dwtxid,a.tdid,a.personid,a.deptid,a.hkrq,a.zsl,a.ddfy,a.zt,a.jsfsid,
         a.zje,a.fgsid,a.tdbh,a.tdrq,a.djlx,a.Isrefer,
         sum(nvl(b.jje,0))zsje,sum(nvl(b.jje,0)-nvl(b.ssje,0))zwje
from xs_td a,xs_tdhw b
where a.tdid=b.tdid and nvl(b.ssje,0)<>nvl(b.jje,0) and a.zt IN(8,3)
group by a.dwtxid,a.tdid,a.personid,a.deptid,a.hkrq,a.zsl,a.ddfy,a.zt,a.jsfsid,a.zje,a.fgsid,a.tdbh,a.tdrq,a.djlx,a.Isrefer
order by a.dwtxid
--销售结算引入提单;

prompt
prompt Creating view VW_SALE_BALANCE_IMPORT_TDDETAL
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_SALE_BALANCE_IMPORT_TDDETAL AS
SELECT t1."TDID",t1."FGSID",t1."TDBH",t1."TDRQ",t1."DJLX",t1."TDHWID",t1."JSFSID",t1."ZT",t1."CPID",t1."HTHWID",t1."SSJE",t1."JJE",t1."ISREFER",t1."ISNET",t1."DWTXID",t1."HKRQ",t1."DEPTID",t1."PERSONID",t1."DJ",t1."JE",t1."KHLX",t1."KHH",t1."ZH",t1."ZSJE",t1."HKTCL", t2.htid, t2.htbh,t1.tdrq+nvl(t2.hkts,0) yhrq
FROM
  (
  SELECT a.tdid, a.fgsid, a.tdbh, a.tdrq,a.djlx,b.tdhwid,a.jsfsid,a.zt, b.cpid, b.hthwid,
          b.ssje,b.jje,a.Isrefer,a.isnet, a.dwtxid,a.hkrq,a.deptid,a.personid,
          b.dj,(nvl(b.jje,0)-nvl(b.ssje,0)) je,a.khlx,c.khh,c.zh,nvl(b.jje,0)zsje,b.hltcl hktcl
   FROM   xs_td a, xs_tdhw b,dwtx c,xs_wzdj d
   WHERE  a.tdid = b.tdid  and abs(nvl(b.ssje,0))<>abs(nvl(b.jje,0))
          and a.zt IN(8,3)  and a.dwtxid=c.dwtxid AND b.wzdjid=d.wzdjid
  ) t1,
  (
   SELECT x.htid, x.htbh, y.hthwid,z.hkts
   FROM   xs_ht x, xs_hthw y,xs_wzdj z
   WHERE  x.htid = y.htid AND y.wzdjid=z.wzdjid
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--销售结算引入提单明细
--zt==2 出库 zt==3 初始数据出库;

prompt
prompt Creating view VW_SALE_COME_PRODUCT_PRICE
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_SALE_COME_PRODUCT_PRICE AS
SELECT d.pm,d.gg,d.cpid, d.cpbm,d.product,d.jldw,c.jjbl,c.xsj,c.xsdj,c.hkts,c.hktcl,c.xsjzj, c.xstcl, c.wzdjid, c.fgsid,c.czrq,c.czy,c.czyid,c.isnet FROM
(SELECT a.cpid, a.cpbm, a.product, a.jldw,b.jjbl, b.xsj, b.xsdj, b.hkts,b.hktcl,a.pm,a.gg,
b.xsjzj, b.xstcl, b.wzdjid, b.fgsid,b.czrq,b.czy,b.czyid,b.isnet
FROM (SELECT * FROM vw_kc_dm_exist a WHERE a.issale=1) a, xs_wzdj b
WHERE a.cpid = b.cpid(+) AND b.Isnet=1
) c, ((SELECT * FROM vw_kc_dm_exist a WHERE a.issale=1)) d
WHERE d.cpid = c.cpid(+)
--来料产品定价;

prompt
prompt Creating view VW_SALE_FLZ
prompt =========================
prompt
CREATE OR REPLACE VIEW VW_SALE_FLZ AS
SELECT a.cpbm,a.pm,a.gg,b.parentid,b.bm,b.mc,b.isdelete,a.cpid,(a.pm||' '||a.gg)roduct,a.wzlbid
FROM kc_dm a,kc_dmlb b
WHERE a.wzlbid=b.wzlbid
AND b.Isdelete=0
--销售分栏帐
--bm 大类编码
--mc 大类名称
--cpbm 小类产品编(具体产品)
--product 具体产品名称;

prompt
prompt Creating view VW_SALE_FLZ_MX
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SALE_FLZ_MX AS
SELECT a.flzid,a.mc,a.bz,b.cpid,b.flzmxid,b.wzlbid
FROM XS_FLZ a,xs_flzmx b
WHERE a.flzid=b.flzid
--销售分栏帐明细;

prompt
prompt Creating view VW_SALE_HTHW
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SALE_HTHW AS
SELECT a.hthwid,a.htid,a.wzdjid,a.hssl,a.sl,a.xsj,a.xsje,
       a.zk,a.dj,a.jje,a.jhrq,a.bz,a.stsl,a.dmsxid,a.yjhsl,a.jzj,
       a.cjtcl,a.jxts,a.hlts,a.hltcl,a.skdsl,a.sthssl,a.skdhssl,a.wbje,
       d.sendmodeid,d.yfdj,d.czy,d.czyid,d.zje,d.zsl,
       b.storeid, b.cpid,
       d.dwtxid, d.personid, d.fgsid,d.khlx,d.deptid,d.jsfsid,d.zt,d.ksrq,d.jsrq, d.htrq, d.htbh, d.Isrefer,
       d.isnet,e.dwmc,e.dwdm,f.xm,f.bm,f.username
FROM xs_hthw a, vw_xs_wzdj b, xs_ht d,dwtx e,emp f
WHERE  a.wzdjid=b.wzdjid
AND d.dwtxid=e.dwtxid
AND d.personid=f.personid(+)
AND a.htid=d.htid
AND d.isnet=b.isnet
--未完成的合同详细清单
--AND d.zt=1
--销售合同货物
--skdsl 提单后回填
-- stsl 出库后回填
/*使用情况*/
--销售提货单引入合同
--销售退货单引入合同
--销售合同未完成情况表表;

prompt
prompt Creating view VW_SALE_HTLIST
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SALE_HTLIST AS
SELECT distinct t."HTID",t."DWTXID",t."PERSONID",t."HTBH",t."HTRQ",t."KSRQ",t."JSRQ",t."QDDD",t."QTXX",t."ZSL",t."ZJE",t."CZRQ",t."CZY",t."CZYID",t."FGSID",t."ISNET",t."ZT",t."ZTMS",t."SPRID",t."KHLX",t."HL",t."WBID",t."DEPTID",t."JSFSID",t."SENDMODEID",t."ORDERTYPEID",t."ISREFER",t."YFDJ",t."ISPRODUCE",t."KHHLTS"
from xs_ht t,xs_hthw b
WHERE t.htid=b.htid
AND abs(nvl(b.skdsl,0))<abs(nvl(b.sl,0))
AND t.isrefer=1
AND t.zt<>4
AND t.zt<>8
ORDER BY t.htbh DESC
--未完成的合同列表
--销售提货单引入合同;

prompt
prompt Creating view VW_SALE_IMPORT_ORDER
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_ORDER AS
SELECT DISTINCT a.htid, a.htbh, a.htrq, a.fgsid,a.dwtxid,a.personid,a.zt,
                a.ksrq,a.jsrq,a.qtxx bz,a.jsfsid
FROM xs_ht a, xs_hthw b , vw_xs_wzdj c,vw_kc_dm d
WHERE nvl(b.sl,0)>nvl(b.skdsl,0) AND a.zt=1 and a.htid=b.htid  AND b.wzdjid = c.wzdjid AND c.cpid=d.cpid
--提货单引入销售合同;

prompt
prompt Creating view VW_SALE_IMPORT_ORDER_DETAIL
prompt =========================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_ORDER_DETAIL AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,a.isnet,
  b.hthwid, b.wzdjid, nvl(b.sl,0)-nvl(b.skdsl,0)sl, b.xsj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.xsj xsje,
   b.zk, b.dj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.dj jje,b.hssl,d.storeid,
   b.jhrq, b.bz,d.product, d.cpbm, d.jldw, d.hsdw,d.cpid,b.sthssl,b.stsl,a.khlx,a.personid,e.deptid,a.sendmodeid
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,vw_kc_dm d,emp e
WHERE a.htid = b.htid AND b.wzdjid = c.wzdjid AND c.cpid=d.cpid
AND   a.zt=1 and nvl(b.sl,0)>nvl(b.skdsl,0) and a.personid=e.personid
ORDER BY a.htrq
--提单选择销售合同货物;

prompt
prompt Creating view VW_SALE_IMPORT_TD_ORDER
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_TD_ORDER AS
SELECT  a.htid,a.dwtxid,a.personid,a.htbh,a.htrq,a.ksrq,a.jsrq,a.qddd,a.qtxx,a.zsl,a.jsfsid,
        a.zje,a.czrq,a.czy,a.czyid,a.fgsid,a.isnet,a.zt,a.ztms,a.sprid,a.khlx,a.deptid
   ,d.storeid,a.wbid
FROM xs_ht a, xs_hthw b , vw_xs_wzdj c,vw_kc_dm d
WHERE nvl(b.sl,0)>nvl(b.skdsl,0)
AND a.zt=1
AND a.htid=b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
--提货单引入合同
---没用上;

prompt
prompt Creating view VW_SALE_IMPORT_TDORDER
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_TDORDER AS
SELECT DISTINCT a.htid,a.dwtxid,a.personid,a.htbh,a.htrq,a.ksrq,
                a.jsrq,a.qddd,a.qtxx,a.zsl,a.zje,a.czrq,a.czy,a.czyid,a.fgsid,
                a.isnet,a.zt,a.ztms,a.sprid,a.khlx,a.hl,a.wbid,a.deptid,a.jsfsid
FROM xs_ht a,VW_SALE_IMPORT_TD_ORDER b
WHERE a.htid=b.htid
--没用上;

prompt
prompt Creating view VW_SALE_IMPORT_TD_ORDER_DETAIL
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_TD_ORDER_DETAIL AS
SELECT
       htid,dwtxid,fgsid,htbh,htrq,hthwid,dmsxid,wzdjid,zsl,sl,xsj,hlts,
       xsje,skdsl,zt,zk,dj,jje,hsbl,hssl,storeid,jhrq,bz,product,
       cpbm,jldw,hsdw,cpid,sthssl,stsl,khlx,personid,deptid,lb ,jsfsid,
       isrefer,sendmodeid,cjtcl,jzj,jxts,hltcl,yfdj,skdhssl,isnet
FROM
(
SELECT a.isnet,a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,b.hssl,a.sendmodeid,a.yfdj,b.hlts,
       b.hthwid,b.dmsxid, b.wzdjid,nvl(b.sl,0)zsl,(nvl(b.sl,0)-nvl(b.skdsl,0))sl,
       b.xsj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.xsj xsje,nvl(b.skdsl,0)skdsl,a.zt,b.cjtcl,
       b.zk, b.dj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.dj jje,d.hsbl,d.storeid,b.jzj,b.jxts,b.hltcl,
       b.jhrq, b.bz,d.product, d.cpbm, d.jldw, d.hsdw,d.cpid,b.sthssl,b.stsl
       ,a.khlx,a.personid,a.deptid,1 lb,a.jsfsid,a.isrefer,b.skdhssl
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,vw_kc_dm d,emp e
WHERE a.htid = b.htid
AND a.personid=e.personid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
AND  ( a.zt=1 OR a.zt=8)
AND abs(nvl(b.skdsl,0))<abs(nvl(b.sl,0))
--AND a.personid=e.personid
UNION ALL
SELECT a.isnet,a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,b.hssl,a.sendmodeid,a.yfdj,b.hlts,
       b.hthwid,b.dmsxid, b.wzdjid,nvl(b.sl,0)zsl,(nvl(b.sl,0)-nvl(b.skdsl,0))sl,
       b.xsj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.xsj xsje,nvl(b.skdsl,0)skdsl,a.zt,b.cjtcl,
       b.zk, b.dj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.dj jje,d.hsbl,d.storeid,b.jzj,b.jxts,b.hltcl,
       b.jhrq, b.bz,d.product, d.cpbm, d.jldw, d.hsdw,d.cpid,b.sthssl,b.stsl,a.khlx,a.personid,
       a.deptid,2 lb,a.jsfsid,a.isrefer,b.skdhssl
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,vw_kc_dm d,emp e
WHERE a.htid = b.htid
AND a.personid=e.personid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
AND a.zt=1
AND abs(nvl(b.skdsl,0))<abs(nvl(b.sl,0))
)
ORDER BY htrq
--提单选择销售合同货物
--SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,
--       b.hthwid,b.dmsxid, b.wzdjid,nvl(b.sl,0)zsl,(nvl(b.sl,0)-nvl(b.skdsl,0))sl,
--       b.xsj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.xsj xsje,
--       b.zk, b.dj, (nvl(b.sl,0)-nvl(b.skdsl,0))*b.dj jje,d.hsbl,d.storeid,
--       b.jhrq, b.bz,d.product, d.cpbm, d.jldw, d.hsdw,d.cpid,b.sthssl,b.stsl,a.khlx,a.personid,e.deptid
--FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,vw_kc_dm d,emp e
--WHERE a.htid = b.htid
--AND b.wzdjid = c.wzdjid
--AND c.cpid=d.cpid
--AND   a.zt=1
--AND nvl(b.sl,0)>nvl(b.skdsl,0)
--AND a.personid=e.personid
--ORDER BY a.htrq
--lb=1开提货单
--lb=2开退货单;

prompt
prompt Creating view VW_SALE_IMPORT_TH_ORDER
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_TH_ORDER AS
SELECT a.htid,a.dwtxid,a.personid,a.htbh,a.htrq,a.ksrq,a.jsrq,a.qddd,a.qtxx,a.zsl
       ,a.zje,a.czrq,a.czyid,a.fgsid,a.jsfsid,a.deptid,a.wbid,a.hl,a.khlx,a.sprid,a.ztms
       ,a.zt,a.isnet,a.czy
      ,d.storeid
FROM xs_ht a, xs_hthw b , vw_xs_wzdj c,vw_kc_dm d
WHERE (a.zt=1 OR a.zt=8)
AND a.htid=b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
--退货单引入合同;

prompt
prompt Creating view VW_SALE_IMPORT_TH_ORDER_DETAIL
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_SALE_IMPORT_TH_ORDER_DETAIL AS
SELECT a.htid, a.dwtxid, a.fgsid, a.htbh, a.htrq,
       b.hthwid,b.dmsxid, b.wzdjid,nvl(b.sl,0)zsl,nvl(b.sl,0)sl, b.xsj, nvl(b.sl,0)*b.xsj xsje,
       b.zk, b.dj, nvl(b.sl,0)*b.dj jje,d.hsbl,d.storeid,
       b.jhrq, b.bz,d.product, d.cpbm, d.jldw, d.hsdw,d.cpid,b.sthssl,b.stsl,a.khlx,a.personid,e.deptid,a.zt,a.jsfsid
FROM xs_ht a, xs_hthw b, vw_xs_wzdj c,vw_kc_dm d,emp e
WHERE a.htid = b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid
AND   (a.zt=1 OR a.zt=8)
AND a.personid=e.personid
ORDER BY a.htrq
--退货单选择销售合同货物;

prompt
prompt Creating view VW_SALE_INVOICE_IMPORT_TD
prompt =======================================
prompt
create or replace view vw_sale_invoice_import_td as
select   a.dwtxid,a.tdid,a.personid,a.deptid,a.hkrq,a.ddfy,a.zt,a.jsfsid,
a.zje,a.fgsid,a.tdbh,a.tdrq,a.djlx,
sum(nvl(b.sl,0))zsl,sum(nvl(b.sl,0)-nvl(b.skpsl,0))sl,a.khlx
from xs_td a,xs_tdhw b
where a.tdid=b.tdid and nvl(b.skpsl,0)<nvl(b.sl,0) and a.zt IN(8,3)
group by a.dwtxid,a.tdid,a.personid,a.deptid,a.hkrq,a.zsl,a.ddfy,a.zt,a.jsfsid,a.zje,a.fgsid,a.tdbh,a.tdrq,a.djlx,a.khlx
order by a.dwtxid
--销售发票引入提货单;

prompt
prompt Creating view VW_SALE_INVOICE_IMPORT_TDDETAL
prompt ============================================
prompt
CREATE OR REPLACE VIEW VW_SALE_INVOICE_IMPORT_TDDETAL AS
SELECT t1."TDID",t1."FGSID",t1."TDBH",t1."TDRQ",t1."DJLX",t1."TDHWID",t1."WZDJID",t1."JSFSID",t1."CPID",t1."HTHWID",t1."DMSXID",t1."DWTXID",t1."HKRQ",t1."DEPTID",t1."PERSONID",t1."ZSL",t1."SL",t1."DJ",t1."JE",t1."ZH",t1."KHH",t1."ADDR",t1."NSRDJH",t1."KHLX", t2.htid, t2.htbh,t2.hktcl,t1.tdrq+nvl(t2.hkts,0) yhrq
FROM
  (SELECT a.tdid, a.fgsid, a.tdbh, a.tdrq,a.djlx,b.tdhwid, b.wzdjid,a.jsfsid, b.cpid, b.hthwid,b.dmsxid,
    a.dwtxid,a.hkrq,a.deptid,a.personid,(nvl(b.sl,0))zsl,(nvl(b.sl,0)-nvl(b.skpsl,0))sl,b.dj,(nvl(b.sl,0)-nvl(b.skpsl,0))*b.dj je,
    c.zh,c.khh,c.addr,c.nsrdjh,a.khlx
   FROM   xs_td a, xs_tdhw b,dwtx c
   WHERE  a.tdid = b.tdid  and nvl(b.skpsl,0)<nvl(b.sl,0) and a.zt IN(8,3) and a.dwtxid=c.dwtxid
  ) t1,
  (
   SELECT x.htid, x.htbh, y.hthwid,nvl(z.hktcl,0)hktcl,z.hkts
   FROM   xs_ht x, xs_hthw y,xs_wzdj z
   WHERE  x.htid = y.htid AND y.wzdjid=z.wzdjid
  ) t2
WHERE t1.hthwid = t2.hthwid(+)
--销售发票引入提单明细;

prompt
prompt Creating view VW_SALE_KHXYED
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SALE_KHXYED AS
SELECT a.dwtxid,b.dwdm
FROM xs_khxyed a,dwtx  b
WHERE a.dwtxid=b.dwtxid
ORDER BY b.dwdm
--促销产品管理拭量增加;

prompt
prompt Creating view VW_SALE_LADING_BILL
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_SALE_LADING_BILL AS
SELECT DISTINCT a.tdid,a.tdbh,a.zsl,a.zje, a.dwtxid,a.tdrq,a.storeid,a.czy,d.htbh,
                ('('||e.dwdm||')'||e.dwmc)dwmc,f.ckmc,g.jsfs
                ,(SELECT  k.dwmc FROM xs_td j,dwtx k WHERE j.dwt_dwtxid=k.dwtxid(+) AND j.tdid=a.tdid) shdw
                ,a.sendmodeid,s.sendmode
FROM xs_td a,xs_tdhw b,xs_hthw c,xs_ht d,dwtx e,kc_ck f,jsfs g,jc_sendmode s
WHERE a.tdid=b.tdid
AND b.hthwid=c.hthwid(+)
AND c.htid=d.htid(+)
AND a.dwtxid=e.dwtxid
AND a.storeid=f.storeid
AND a.jsfsid=g.jsfsid
AND a.sendmodeid=s.sendmodeid(+)
--提货单套打用到;

prompt
prompt Creating view VW_SALE_LADING_BILL_DETAIL
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_SALE_LADING_BILL_DETAIL AS
SELECT DISTINCT (b.pm||' '||b.gg||' '||'单价:'||a.dj||'元/'||b.jldw)product,a.sl,
                 a.tdhwid,a.tdid,d.sxz,b.pm,b.gg,a.dj,b.jldw,a.jje,a.dmsxid,e.ckdgs
FROM xs_tdhw a,VW_XS_WZDJ b,kc_dmsx d,kc_chlb e,kc_dm f
WHERE a.wzdjid=b.wzdjid
AND a.cpid=f.cpid
AND a.dmsxid=d.dmsxid(+)
AND f.chlbid=e.chlbid
--AND a.tdhwid=c.wjid
--AND c.djxz='2'
--AND c.dmsxid=d.dmsxid
ORDER BY a.tdhwid
--销售提货单套打从表
/**
SELECT DISTINCT (b.pm||' '||b.gg||' '||'单价:'||a.dj||'元/'||b.jldw)product,c.sl,
                 a.tdhwid,a.tdid,c.ph,c.rkdmxid,c.dmsxid,d.sxz,b.pm,b.gg,a.dj,b.jldw,a.jje
FROM xs_tdhw a,kc_dm b,kc_sfdjmx c,kc_dmsx d
WHERE a.cpid=b.cpid
AND a.tdhwid=c.wjid
AND c.djxz='2'
AND c.dmsxid=d.dmsxid
AND A.TDID=2382
ORDER BY a.tdhwid
--销售提货单套打从表
*/;

prompt
prompt Creating view VW_SALE_LADING_PRODUCT
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_SALE_LADING_PRODUCT AS
SELECT a.tdid,a.personid,a.deptid,a.dwt_dwtxid,a.hkrq,a.zsl,a.ddfy,a.yf,
       a.djlx,a.ztms,a.dwtxid,a.czyid,a.hkts,a.jsfsid,a.tdbh,a.tdrq,a.zt,a.czrq,a.czy,a.zje
       ,a.storeid,a.fgsid,
       a.sprid,a.khlx,a.sendmodeid,a.isrefer,a.Isinit
       ,b.tdhwid,b.cpid,b.hthwid,b.wzdjid,b.hssl,b.sl,b.xsj,b.xsje,b.zk,b.jje,b.bz,b.sthssl,b.stsl
       ,b.ssje,b.dj,b.skpsl,b.dmsxid,b.ckrq,c.dwdm,c.dwmc
FROM xs_td a,xs_tdhw b,dwtx c
WHERE a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
--销售提货单主从明细
--查询用;

prompt
prompt Creating view VW_SALE_NEW_PRODUCT
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_SALE_NEW_PRODUCT AS
SELECT a.tdid,a.personid,a.deptid,a.hkrq,a.zsl,
       a.djlx,a.ztms,a.dwtxid,a.czyid,a.hkts,a.jsfsid,a.tdbh,a.tdrq,a.zt,a.czrq,a.czy,a.zje
       ,a.storeid,a.fgsid,
       a.sprid,a.khlx,a.sendmodeid,a.isrefer,a.Isinit
       ,b.tdhwid,b.cpid,b.hthwid,b.wzdjid,b.hssl,b.sl,b.xsj,b.xsje,b.zk,b.jje,b.bz,b.sthssl,b.stsl
       ,b.ssje,b.dj,b.skpsl,b.dmsxid,b.ckrq,c.dwdm,c.dwmc
FROM xs_td a,xs_tdhw b,dwtx c
WHERE a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
AND a.djlx<>2
ORDER BY a.tdid DESC
--销售提货单新产品
--1=提货,-1=退货,2=广告促销单,3=销售赠送单,4=销售发货单,5=销售换货单;

prompt
prompt Creating view VW_SALE_OUTSTORE
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_SALE_OUTSTORE AS
SELECT a.tdid, a.dwtxid, a.fgsid, a.tdbh, a.tdrq, a.zt, a.storeid, a.djlx,a.deptid,
  b.tdhwid, b.cpid, b.sl, b.hssl, b.sthssl, b.dmsxid,a.khlx, a.jsfsid,
  b.stsl, b.bz, (nvl(b.sl,0)-nvl(b.stsl,0)) sjsl, (nvl(b.hssl,0)-nvl(b.sthssl,0)) sjhssl,
  c.product, c.cpbm, c.jldw, c.hsdw,c.hsbl, b.dj, b.jje --2004-3-31 18:17  新增单价, 金额 yjg
FROM xs_td a, xs_tdhw b, vw_kc_dm c
WHERE abs(nvl(b.sl,0))>abs(nvl(b.stsl,0)) AND a.tdid= b.tdid AND b.cpid = c.cpid --AND a.zt=1 2004-4-23 18:15 去掉
      AND a.isrefer = 1 AND a.zt IN (1, 2) --2004-4-23 18:15 新增
      AND a.isinit=0  --2004-4-28 20:02 新增
ORDER BY a.tdbh DESC
--销售提单和货物视图(销售出库单引入销售提单);

prompt
prompt Creating view VW_SALE_PRODUCT_PRICE
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_SALE_PRODUCT_PRICE AS
SELECT d.pm,d.gg,d.cpid, d.cpbm,d.product,d.jldw,c.jjbl,c.xsj,c.xsdj,c.hkts,c.hktcl,c.xsjzj, c.xstcl, c.wzdjid, c.fgsid,c.czrq,c.czy,c.czyid,c.isnet FROM
(
SELECT a.cpid, a.cpbm, a.product, a.jldw,b.jjbl, b.xsj, b.xsdj, b.hkts,b.hktcl,a.pm,a.gg,
b.xsjzj, b.xstcl, b.wzdjid, b.fgsid,b.czrq,b.czy,b.czyid,b.isnet
FROM
(
SELECT * FROM vw_kc_dm_exist a
WHERE a.issale=1) a, xs_wzdj b
WHERE a.cpid = b.cpid(+) AND b.Isnet=0
) c, ((SELECT * FROM vw_kc_dm_exist a WHERE a.issale=1)) d
WHERE d.cpid = c.cpid(+)
--产品定价;

prompt
prompt Creating view VW_SALE_STATISTIC_FIELD
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_SALE_STATISTIC_FIELD AS
SELECT c.mc,a.deptid
FROM xs_td a,xs_tdhw b,bm c
WHERE a.tdid=b.tdid
AND a.deptid=c.deptid
GROUP BY c.mc,a.deptid
--月销售统计字段;

prompt
prompt Creating view VW_SALE_TDHW
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SALE_TDHW AS
SELECT a.sfdjid,a.storeid,a.deptid,a.jsfsid,a.dwtxid,a.sfdjdh,a.jsr,
       b.dmsxid,b.wjid,b.cpid,b.ph,b.sl,c.tdid,d.sxz,e.pm,e.gg,f.tdbh,e.cpbm,(e.pm||''||e.gg)product
FROM kc_sfdj a ,kc_sfdjmx b,xs_tdhw c,kc_dmsx d,kc_dm e,xs_td f
WHERE a.sfdjid=b.sfdjid
AND a.djxz=2
AND b.wjid=c.tdhwid
AND b.dmsxid=d.dmsxid(+)
AND b.cpid=e.cpid
AND c.tdid=f.tdid
--销售货物管理查看出库情况;

prompt
prompt Creating view VW_SALE_TDYJ
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SALE_TDYJ AS
SELECT DISTINCT a.tdyjid, b.tdid tdid, b.personid beforeid,b.deptid beforedeptid, c.xm beforename, a.afterid, a.aftername,
       a.czrq, a.czy, a.czyid, a.fgsid, a.zt, a.ztms, a.sprid, b.deptid deptid, a.afterdeptid
       ,b.tdbh,d.dwmc
FROM xs_tdyj a,xs_td b,emp c,dwtx d,xs_tdhw e,cw_xsjshx f
WHERE b.tdid=a.tdid(+)
--AND a.beforedeptid = d.deptid --a.beforeid = d.deptid
AND b.personid=c.personid
AND b.dwtxid=d.dwtxid
AND b.tdid=e.tdid
AND e.tdhwid=f.tdhwid(+)
AND b.zt IN(0,1,2,3,9,8)
and nvl(e.jje,0)>nvl(e.ssje,0)
AND f.tdhwid IS NULL
and b.isinit=0
--kw;

prompt
prompt Creating view VW_SALE_TEST
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SALE_TEST AS
SELECT  a.htid, a.htbh, a.htrq, a.fgsid,a.dwtxid,a.personid,a.zt,
                a.ksrq,a.jsrq,a.qtxx bz,d.storeid
FROM xs_ht a, xs_hthw b , vw_xs_wzdj c,vw_kc_dm d
WHERE nvl(b.sl,0)>nvl(b.skdsl,0)
AND a.zt=1
AND a.htid=b.htid
AND b.wzdjid = c.wzdjid
AND c.cpid=d.cpid;

prompt
prompt Creating view VW_SALE_THLIST
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SALE_THLIST AS
SELECT a.hthwid,a.htid,a.wzdjid,a.hssl,a.sl,a.xsj,a.xsje,
       a.zk,a.dj,a.jje,a.jhrq,a.bz,a.stsl,a.dmsxid,a.yjhsl,a.jzj,
       a.cjtcl,a.jxts,a.hlts,a.hltcl,a.skdsl,a.sthssl,a.skdhssl,a.wbje,
       d.sendmodeid,d.yfdj,d.czy,d.czyid,d.zje,d.zsl,
       b.storeid, b.cpid,
       d.dwtxid, d.personid, d.fgsid,d.khlx,d.deptid,d.jsfsid,d.zt,d.ksrq,d.jsrq, d.htrq, d.htbh, d.Isrefer,
       d.isnet,e.dwmc,e.dwdm,f.xm,f.bm,f.username
FROM xs_hthw a, vw_xs_wzdj b, xs_ht d,dwtx e,emp f
WHERE  a.wzdjid=b.wzdjid
AND d.dwtxid=e.dwtxid
AND d.personid=f.personid
AND a.htid=d.htid
AND d.isnet=0
AND d.isrefer=1
--销售退货单引入合同;

prompt
prompt Creating view VW_SCBMGZL_QUERY
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_SCBMGZL_QUERY AS
SELECT a.bmgzlmxid, a.bmgzlid, b.pm, b.gg, b.product, b.cpbm
FROM sc_bmgzlmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产(按部门输入)工人工作量及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SCGRGZL_QUERY
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_SCGRGZL_QUERY AS
SELECT a.gzlid, a.gzlmxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_grgzlmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产工人工作量及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SCJGD_QUERY
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SCJGD_QUERY AS
SELECT a.jgdid, a.jgdmxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_jgdmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产加工单及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SCJH_QUERY
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_SCJH_QUERY AS
SELECT a.scjhid, a.scjhmxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_jhmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产计划及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SCRWD_QUERY
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SCRWD_QUERY AS
SELECT a.rwdid, a.rwdmxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_rwdmx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产任务单及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SC_BOM
prompt =======================
prompt
CREATE OR REPLACE VIEW VW_SC_BOM AS
SELECT a.bomid, a.cpid, a.sjcpid, a.sl, a.shl, a.zjlx, a.xgr, a.wgcl, b.cpbm
FROM sc_bom a, vw_kc_dm_exist b
WHERE a.cpid = b.cpid
--提取BOM数据,产品编码视图
--用于:BOM树;

prompt
prompt Creating view VW_SC_GRGZHZ
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_SC_GRGZHZ AS
SELECT a.personid, a.deptid, a.rq, a.fgsid,
        nvl(SUM(nvl(a.cq,0)),0) cqhz, nvl(SUM(nvl(a.rb,0)),0) rbhz, nvl(SUM(nvl(a.yb,0)),0) ybhz,
        nvl(SUM(nvl(a.qj,0)),0) qjhz, nvl(SUM(nvl(a.je,0)),0) jehz, nvl(SUM(nvl(a.zjjgz,0)),0) jjgzhz
FROM sc_grgzl a GROUP BY a.personid, a.deptid, a.rq, a.fgsid
--工人工资汇总视图;

prompt
prompt Creating view VW_SC_GYLXQUERY
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_SC_GYLXQUERY AS
SELECT a.gylxid, b.pm, b.gg, b.product, b.cpbm
FROM sc_gylx a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产路线及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SC_KHBOM
prompt =========================
prompt
CREATE OR REPLACE VIEW VW_SC_KHBOM AS
SELECT a.khbomid, a.cpid, a.hthwid, a.dwtxid, a.sjcpid, a.sl, a.shl, a.zjlx, b.cpbm,
       (b.cpbm||' '||b.pm||' '||b.gg) mc
FROM sc_khbom a, vw_kc_dm_exist b
WHERE a.cpid = b.cpid
--生产计划中提取客户BOM数据,显示产品编码视图
--用于:客户BOM树;

prompt
prompt Creating view VW_SC_SCNLQUERY
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_SC_SCNLQUERY AS
SELECT a.scnlid, b.pm, b.gg, (b.cpbm ||' '||b.product) product, b.cpbm
FROM sc_scnl a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产能力及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SC_WJGJGQUERY
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_SC_WJGJGQUERY AS
SELECT a.wjgjgid, b.pm, b.gg, b.product, b.cpbm
FROM sc_wjgjg a, vw_kc_dm b
WHERE a.cpid = b.cpid
--提取生产外加工价格及其产品名称和规格的视图(用于查询);

prompt
prompt Creating view VW_SC_WJG_BALANCE
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_SC_WJG_BALANCE AS
SELECT a.jgdid, a.deptid, a.jgdh, a.rq, a.zdrq, a.zdrid, a.zdr, a.fgsid, a.zsl, a.describe, a.rwdid, a.scjhid
       ,a.zt,a.dwtxid
       ,b.jgdmxid, b.cpid, b.rwdmxid, b.gylxid, b.sl, b.cpl, b.ypgzl, b.dmsxid, b.jgyq
       ,b.scsl, b.jgdj, b.jgje, b.yfjgje, b.yrkscsl,
        c.isrefer
FROM sc_jgd a,sc_jgdmx b, cw_wjgjs c
WHERE a.jgdid=b.jgdid
AND a.zt=8;

prompt
prompt Creating view VW_SC_WORKLOAD
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_SC_WORKLOAD AS
SELECT a1.deptid, a1.personid, a1.fgsid, nvl(a1.zjjgz,0) zjjgz, nvl(a1.je,0) je, --总金额
  a1.rq, nvl(a1.cq,0) cq, nvl(a1.rb,0) rb, nvl(a1.yb,0) yb, nvl(a1.qj,0) qj
FROM sc_grgzl a1
--部门工作量
UNION ALL
SELECT a2.deptid, b2.personid, a2.fgsid, nvl(b2.jjgz,0) jjgz, nvl(b2.jjgz,0) je,
  a2.rq, 0 , 0, 0, 0
FROM sc_bmgzl a2, sc_bmgzlmx b2
WHERE a2.bmgzlid = b2.bmgzlid
--工作组工作量
UNION ALL
SELECT a3.deptid, b3.personid, a3.fgsid, nvl(b3.jjgz,0) jjgz, nvl(b3.jjgz,0) je,
  a3.rq, 0, 0, 0, 0
FROM sc_gzzgzl a3, sc_gzzgzlry b3
WHERE a3.gzzgzlid = b3.gzzgzlid
--按工作组工作量,工人工作量,部门工作量的联合;

prompt
prompt Creating view VW_SC_WORKLOAD_DETAIL
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_SC_WORKLOAD_DETAIL AS
SELECT a1.deptid, a1.personid, a1.fgsid, a1.rq,
  b1.jgdmxid, b1.gylxid, b1.cpid, b1.gx, b1.sl, b1.desl, b1.jjgs, b1.de, b1.jjgz, 'gr' lx, b1.dmsxid
FROM sc_grgzl a1, sc_grgzlmx b1
WHERE a1.gzlid = b1.gzlid
--部门工作量
UNION ALL
SELECT a2.deptid, b2.personid, a2.fgsid, a2.rq,
  b2.jgdmxid, b2.gylxid, b2.cpid, b2.gx, b2.sl, b2.desl, b2.jjgs,  b2.jjdj, b2.jjgz, 'bm' lx, b2.dmsxid
FROM sc_bmgzl a2, sc_bmgzlmx b2
WHERE a2.bmgzlid = b2.bmgzlid
--工作组工作量, 以工作组织输入是不需要知道该人员生产的产品
UNION ALL
SELECT a3.deptid, b3.personid, a3.fgsid, a3.rq,
  c3.jgdmxid, c3.gylxid, c3.cpid, c3.gx, decode(a3.empCount, 0, 0, a3.sl/a3.empCount) sl,
  NULL desl, NULL jjgs, NULL jjdj, c3.jjgz*b3.bl, 'gzz' lx,
  c3.dmsxid
FROM
  (
    SELECT t.gzzgzlid, t.deptid, t.rq, t.sl, t.fgsid,
      (SELECT COUNT(*) FROM sc_gzzgzlry r WHERE r.gzzgzlid=t.gzzgzlid) empCount,
      (SELECT COUNT(*) FROM sc_gzzgzlmx d WHERE d.gzzgzlid=t.gzzgzlid) prodCount
    FROM sc_gzzgzl t
  ) a3, sc_gzzgzlry b3, sc_gzzgzlmx c3
WHERE a3.gzzgzlid = b3.gzzgzlid AND a3.gzzgzlid=c3.gzzgzlid
--按工作组工作量从表,工人工作量从表,部门工作量从表的联合;

prompt
prompt Creating view VW_SELECT_PROCESSMATERAIL
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_SELECT_PROCESSMATERAIL AS
SELECT a.jgdh,a.rq, a.deptid, a.fgsid, b.jgdwlid,b.jgdmxid,b.jgdid,b.cpid,b.dmsxid,b.sl,b.scsl,
       c.cpbm,c.pm,c.gg,(c.pm||''||c.gg) product,c.storeid, a.sfwjg,
       d.ckmc,c.jldw, c.scydw,c.hsdw, (nvl(b.sl,0)-nvl(b.ylsl,0)) wlsl,
       (nvl(b.scsl,0)-nvl(b.ylscsl,0)) wlscsl--, '1' drawtype
FROM sc_jgd a, sc_jgdwl b, kc_dm c, kc_ck d
WHERE nvl(b.sl,0)>nvl(b.ylsl,0) AND  a.jgdid=b.jgdid AND b.cpid=c.cpid AND c.storeid=d.storeid(+)
AND a.zt<>8
ORDER BY a.jgdh Desc, c.cpbm
--生产加工单视图(生产领料单引入加工单物料);

prompt
prompt Creating view VW_SELECT_PRODUCEPLAN
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_SELECT_PRODUCEPLAN AS
SELECT a.scjhid, a.deptid, a.jhh, a.jhrq,a.jhsm, a.fgsid, a.zsl, a.zt,
  b.hthwid, b.cpid, b.sl, b.gylxid, b.wcrq,
  c.product, c.cpbm, c.jldw, c.chxz
FROM sc_jh a, sc_jhmx b, vw_kc_dm_exist c
WHERE a.scjhid = b.scjhid AND b.cpid = c.cpid AND a.zt=1
ORDER BY a.jhh DESC
--生产计划视图(物料需求引入生产计划明细);

prompt
prompt Creating view VW_SELFGAIN_QUERY
prompt ===============================
prompt
CREATE OR REPLACE VIEW VW_SELFGAIN_QUERY AS
SELECT a.receiveid, a.receivedetailid, b.pm, b.gg, b.product, b.cpbm,b.cpid
FROM sc_receiveproddetail a, vw_kc_dm b
WHERE a.cpid = b.cpid
--自制收货查询;

prompt
prompt Creating view VW_STOCK_NUMBER_REPORT
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_STOCK_NUMBER_REPORT AS
SELECT a.cpid, a.kcsl, a.storeid, a.fgsid, --nvl(SUM(nvl(a.kcsl,0)), 0) kcslhz,
       b.jldw, b.cpbm, b.pm, b.gg, b.hsdw, b.chlbid,
       c.chmc
FROM kc_kchz a, vw_kc_dm_exist b, kc_chlb c
WHERE a.cpid=b.cpid AND b.chlbid = c.chlbid;

prompt
prompt Creating view VW_STOREBILL_SINGLE_ORDER
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_STOREBILL_SINGLE_ORDER AS
SELECT DISTINCT a.jhdid, a.storeid, a.deptid, a.dwtxid, a.personid, a.djlx, a.khlx,
       a.jhdbm, a.jhrq, a.fgsid, a.zt,a.zsl, a.zje, a.jsfsid  --03:26 16:07 新增结算方式id
       --b.dj, b.je --2004-3-31 19:22 新增 新增单价,金额
       --2004-4-9 13:02 去掉dj, je因为原来以为采购入库单也须要引进货单单价过来.所以加上dj,je,但是会造成.
       --进货单列表里一查就查出重复的主表记录.所以现在去掉.并且,似乎dj,je在采购这张单里不须要的
FROM cg_htjhd a, cg_htjhdhw b
WHERE nvl(b.sl,0)>nvl(b.sjrkl,0) AND a.jhdid=b.jhdid --AND a.zt=1 2004-4-23 16:41 去掉 zt=1用下面的isrefer代替
AND a.isrefer = 1 AND a.zt<>4 AND a.zt<>8  AND a.zt<>2
-- 2004-4-23 16:41 新增 isrefer状态.
ORDER BY a.jhdbm DESC
--采购入库单单选进货单主表视图;

prompt
prompt Creating view VW_STOREPROCESS_SEL_PROCESS
prompt =========================================
prompt
CREATE OR REPLACE VIEW VW_STOREPROCESS_SEL_PROCESS AS
SELECT a.jgdid, a.jgdh, a.deptid, a.rq, a.fgsid,b.jgdmxid,
  b.cpid, b.sl, (b.jgdmxid) wjid, b.dmsxid,b.yrksl,b.yrkscsl,nvl(b.sl,0)-nvl(b.yrksl,0) wrksl,
  nvl(b.scsl,0)-nvl(b.yrkscsl,0) wrkscsl    --04.03.10 22:30 新增 新增规格属性id
FROM sc_jgd a, sc_jgdmx b
WHERE nvl(b.yrksl,0)<nvl(b.sl,0) AND  a.jgdid = b.jgdid AND a.zt<>8
ORDER BY a.jgdh Desc
--生产加工单视图(自制收货单引入生产加工单);

prompt
prompt Creating view VW_STORE_COLLECT
prompt ==============================
prompt
CREATE OR REPLACE VIEW VW_STORE_COLLECT AS
SELECT a.cpbm, a.cpid, a.wzlbid, c.parentid, a.chlbid, b.dmsxid, b.ph, nvl(b.storeid,a.storeid) storeid,
       nvl(b.kcsl, 0)  kcsl, nvl(b.hszl, 0)  hszl, b.sxz
       --2004-3-29 23:43 新增 物资规格属性 yjg
FROM vw_kc_dm_exist a,
(
  SELECT * FROM
  (
   SELECT b.storeid, b.cpid, b.dmsxid, b.ph, SUM(nvl(b.zl,0)) kcsl, sum(nvl(b.hszl, 0)) hszl, c.sxz -- 04.05.10 新增 属性值
   FROM kc_wzmx b, vw_kc_dm_exist a, kc_dmsx c
   WHERE  b.cpid = a.cpid AND b.dmsxid = c.dmsxid(+) AND b.cpid = c.cpid(+)
   GROUP BY b.storeid, b.cpid, b.dmsxid, b.ph, c.sxz
  ) b
  WHERE b.kcsl <> 0 OR  b.hszl <> 0
) b, (SELECT * FROM kc_dmlb WHERE isdelete = 0 ) c
WHERE a.cpid = b.cpid(+) AND a.wzlbid = c.wzlbid(+)--2004-08-31  修改 加入了关联kc_dmlb , 取出parentid
--GROUP BY a.cpbm, b.ph, b.storeid, a.cpid, a.wzlbid, a.chlbid, b.dmsxid
ORDER BY a.cpbm
--盘点单视图;

prompt
prompt Creating view VW_STORE_SEL_PROCESS
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_STORE_SEL_PROCESS AS
SELECT a.jgdid, a.jgdh, a.deptid, a.rq, a.fgsid,
  b.cpid, b.sl, b.jgdmxid
FROM sc_jgd a, sc_jgdmx b
WHERE a.jgdid = b.jgdid
ORDER BY a.jgdh Desc
--生产加工单视图(工人工作量引入加工单);

prompt
prompt Creating view VW_SUBPLAN_SINGLE_SALE
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_SUBPLAN_SINGLE_SALE AS
SELECT DISTINCT a."HTID",a."DWTXID",a."PERSONID",a."KHLX",a."HTBH",a."HTRQ",a."FGSID",a."ZT",a."ZSL",a."ZJE",a."KSRQ",a."JSRQ"
FROM(
SELECT DISTINCT a.htid, a.dwtxid, a.personid, a.khlx,
       a.htbh, a.htrq, a.fgsid, a.zt, a.zsl, a.zje, a.ksrq, a.jsrq
FROM xs_ht a, xs_hthw b, kc_dmsx c
WHERE nvl(b.sl,0)>nvl(b.yjhsl,0) AND a.htid=b.htid AND a.zt=1 AND a.isproduce<>0
) a, xs_hthw b, kc_dmsx c
WHERE c.sxz LIKE '%宽度%' AND a.htid=b.htid AND b.dmsxid=c.dmsxid(+)
ORDER BY a.htbh DESC
--生产分切计划单选销售合同主表视图(合同货物中必须有一行纪录没有完全下达生产计划，并该行的规格属性有宽度);

prompt
prompt Creating view VW_TASK_SEL_MRPDETAIL
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_TASK_SEL_MRPDETAIL AS
SELECT x."WLXQJHMXID",x."CPID",x."GYLXID",x."WLXQJHID",x."SCJHMXID",x."HTID",x."XQL",x."XGL",x."XQRQ",x."BZ",x."CHXZ",x."YPRWL",x."CC",x."YGL",x."DMSXID",x."JLXQL",x."YPRWCSL",x."ISCOPY",x."SCJHID", y.ksrq, y.jgyq
FROM
(
  SELECT b.*,a.scjhid
  FROM sc_wlxqjh a, sc_wlxqjhmx b
  WHERE a.wlxqjhid = b.wlxqjhid AND a.zt = 1 AND nvl(b.xql,0)>nvl(b.yprwl,0) AND b.chxz<>2
) x, sc_jhmx y
WHERE x.scjhmxid = y.scjhmxid(+)
--生产任务单选择生产物料需求(物料需求计划从表信息);

prompt
prompt Creating view VW_TASK_SINGLESEL_MRP
prompt ===================================
prompt
CREATE OR REPLACE VIEW VW_TASK_SINGLESEL_MRP AS
SELECT DISTINCT a.wlxqjhid, a.wlxqh, a.deptid, a.rq, a.fgsid, a.zsl, a.zdr, a.jhlx,c.deptid scdeptid,a.scjhid
FROM sc_wlxqjh a, sc_wlxqjhmx b, kc_dm c
WHERE nvl(b.jlxql,0)>nvl(b.yprwl,0) AND  (b.chxz IS NULL OR b.chxz<>2) AND a.wlxqjhid=b.wlxqjhid AND b.cpid = c.cpid
AND a.isrefer=1 AND a.zt<>8 AND a.zt<>4
ORDER BY a.wlxqh DESC
--生产任务单单选生产物料需求;

prompt
prompt Creating view VW_TASK_SINGLESEL_MRPDETAIL
prompt =========================================
prompt
CREATE OR REPLACE VIEW VW_TASK_SINGLESEL_MRPDETAIL AS
SELECT a.scjhid, a.wlxqjhid,a.wlxqjhmxid,a.cpid,a.dmsxid,a.xqrq,a.wprwl,a.gylxid,
a.wprwscl,a.ztqq,a.deptid,a.scjhmxid, b.ksrq, b.jgyq
FROM(
SELECT a.scjhid, a.wlxqjhid, b.wlxqjhmxid, b.scjhmxid, b.cpid, b.dmsxid, b.xqrq,
       (nvl(b.jlxql,0)-nvl(b.yprwl,0)) wprwl, b.gylxid, (nvl(b.xql,0)-nvl(b.yprwcsl,0)) wprwscl,
       c.ztqq, c.deptid
FROM sc_wlxqjh a, sc_wlxqjhmx b, kc_dm c
WHERE nvl(b.jlxql,0)>nvl(b.yprwl,0) AND b.cpid=c.cpid  AND a.wlxqjhid=b.wlxqjhid AND (b.chxz IS NULL OR b.chxz<>2 )
ORDER BY b.wlxqjhmxid
) a, sc_jhmx b
WHERE a.scjhmxid =b.scjhmxid(+)
--生产任务单单选生产物料需求得到从表信息;

prompt
prompt Creating view VW_USER_LIMITS
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_USER_LIMITS AS
SELECT n."LIMITID",n."NODEID",n."PRIVILIGEID",n."ISDELETE",n."PARENTNODEID",n."NODECODE",n."NODENAME",n."URL",n."INTERCODE",n."NODETYPE",n."ISJIT",n."PRIVILIGECODE",n."PRIVILIGENAME", p.personid                  --提取特殊权限
FROM   VW_NODE_LIMITS n, personlimits p
WHERE  n.limitid = p.limitid
/*SELECT n.*, p.personid                 --提取角色权限
FROM   VW_NODE_LIMITS n, rolelimit r, personlimits p
WHERE  n.limitid = r.limitid AND p.roleid = r.roleid
UNION*/;

prompt
prompt Creating view VW_USER_LIMITS_NEW
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_USER_LIMITS_NEW AS
SELECT n."LIMITID",n."NODEID",n."PRIVILIGEID",n."ISDELETE",n."PARENTNODEID",n."NODECODE",n."NODENAME",n."URL",n."INTERCODE",n."NODETYPE",n."ISJIT",n."PRIVILIGECODE",n."PRIVILIGENAME", p.personid                  --提取特殊权限
FROM   VW_NODE_LIMITS n, personlimits p
WHERE  n.limitid = p.limitid AND N.isjit=1
/*SELECT n.*, p.personid                 --提取角色权限
FROM   VW_NODE_LIMITS n, rolelimit r, personlimits p
WHERE  n.limitid = r.limitid AND p.roleid = r.roleid
UNION*/;

prompt
prompt Creating view VW_USER_ROLES
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_USER_ROLES AS
SELECT DISTINCT a.personid, b.roleid, b.rolename----提取人员角色列表
  FROM   personlimits a, roleInfo b
  WHERE a.roleid = b.roleid;

prompt
prompt Creating view VW_WORKLOAD_SEL_PROCESS
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_WORKLOAD_SEL_PROCESS AS
SELECT a.jgdid, a.jgdh, a.deptid,
  b.cpid, b.sl, b.jgdmxid, b.gylxid,b.dmsxid,
  c.product, c.cpbm, c.jldw, c.hsbl
FROM sc_jgd a, sc_jgdmx b, vw_kc_dm_exist c
WHERE a.jgdid = b.jgdid AND b.cpid = c.cpid AND a.zt<>8
ORDER BY a.jgdh Desc
--生产加工单视图(工人工作量引入加工单);

prompt
prompt Creating view VW_WORKLOAD_SINGLESEL_PROCESS
prompt ===========================================
prompt
CREATE OR REPLACE VIEW VW_WORKLOAD_SINGLESEL_PROCESS AS
SELECT DISTINCT a.jgdid, a.jgdh, a.deptid, a.rq, a.fgsid
FROM sc_jgd a, sc_jgdmx b
WHERE nvl(b.sl,0)>nvl(b.ypgzl,0) AND a.jgdid = b.jgdid AND a.zt<>8
ORDER BY a.jgdh Desc
--工人工作量单选加工单主表视图;

prompt
prompt Creating view VW_WORK_GROUP
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_WORK_GROUP AS
SELECT a.personid, a.gzzid, t.gylxid, (t.gymc) gx, (a.ryjs) bl, (t.deje) jjdj
FROM sc_gzzry a,
    (SELECT b.gylxid, b.deje, b.gymcid, c.gymc FROM sc_gylxmx b, sc_gymc c WHERE b.gymcid = c.gymcid) t
WHERE a.gymcid = t.gymcid(+)
--按工作组输入工人工作量时选工作组时调用;

prompt
prompt Creating view VW_XS_XYED
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_XS_XYED AS
SELECT a.xyed,a.xydj,a.hkts,b.fgsid,a.xyedid,a.hlts,
       b.dwtxid,b.dwmc,b.dqh,c.dqmc,to_number(b.dwdm)dwdm,c.areacode,b.personid,e.xm
FROM xs_khxyed a,dwtx b,dwdq c,dwtx_lx d,emp e
WHERE b.dwtxid = a.dwtxid(+)
AND b.dwtxid=d.dwtxid
AND b.dqh=c.dqh
AND b.Isdelete=0
AND d.ywlx=2
AND b.personid=e.personid(+)
ORDER BY c.areacode,dwdm;

prompt
prompt Creating view VW_XS_NEW_XYED
prompt ============================
prompt
create or replace view vw_xs_new_xyed as
select a."XYED",a."XYDJ",a."HKTS",a."FGSID",a."XYEDID",a."HLTS",a."DWTXID",a."DWMC",a."DQH",a."DQMC",a."DWDM",a."AREACODE",a."PERSONID",a."XM",nvl(a.xyed,0)-nvl(b.locknum,0) kyxyed ,b.locknum xysdl,
nvl(b.locknum,0)-nvl(a.xyed,0) cxyed
from vw_xs_xyed a,VW_ORDER_CUSTCREDIT_LOCK b
WHERE a.dwtxid = b.dwtxid(+)
AND a.fgsid=b.fgsid(+);

prompt
prompt Creating view VW_XS_DQWHLJE
prompt ===========================
prompt
CREATE OR REPLACE VIEW VW_XS_DQWHLJE AS
SELECT a.dwtxid,c.dwdm,c.dwmc,c.dqh,sum(nvl(b.jje,0)-nvl(b.ssje,0))wfje,e.xyed,e.xydj,e.hkts,SUM(nvl(d.locknum,0)-nvl(e.xyed,0))cxyed,SUM(nvl(e.xyed,0)-nvl(d.locknum,0))kyxyed
FROM xs_td a,xs_tdhw b,dwtx c,VW_ORDER_CUSTCREDIT_LOCK d,vw_xs_new_xyed e
WHERE a.tdid=b.tdid
AND a.dwtxid=c.dwtxid
AND a.dwtxid=d.dwtxid
AND a.dwtxid=e.dwtxid
GROUP BY a.dwtxid,c.dwdm,c.dwmc,e.xyed,c.dqh,e.xydj,e.hkts
--到期未回笼金额;

prompt
prompt Creating view VW_XS_HITORY_PRODUCT
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_XS_HITORY_PRODUCT AS
SELECT dwtxid,deptid,personid,khlx,fgsid,wzdjid,cdmsxid,dmsxid,xsjzj,xstcl,hkts,hktcl,xsdj,xsj,cpid,cpbm,pm,gg,product,jldw,dj,zk
FROM(
SELECT  a.dwtxid,a.deptid,a.personid,a.khlx,a.fgsid,
       b.wzdjid,b.dmsxid,(w.wzdjid||'%'||b.dmsxid)cdmsxid,b.dj,b.zk
       ,w.xsjzj,w.xstcl,w.hkts,w.hktcl,w.xsdj,w.xsj,w.cpid,w.cpbm,w.pm,w.gg,w.product,w.jldw
FROM   xs_ht a,xs_hthw b, vw_xs_wzdj w
WHERE  a.htid=b.htid
AND b.wzdjid=w.wzdjid
AND nvl(b.stsl,0)>0
)
GROUP BY dwtxid,deptid,personid,khlx,fgsid,wzdjid,cdmsxid,dmsxid,xsjzj,xstcl,hkts,hktcl,xsdj,xsj,cpid,cpbm,pm,gg,product,jldw,dj,zk
--客户历史产品;

prompt
prompt Creating view VW_XS_HTHW
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_XS_HTHW AS
SELECT a.hthwid, a.htid, b.pm, b.gg, b.product,b.cpbm
FROM xs_hthw a, vw_xs_wzdj b
WHERE a.wzdjid = b.wzdjid
--提取销售合同货物及其产品名称和规格的视图
--用于:销售合同查询;

prompt
prompt Creating view VW_XS_HTHW_JHH
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_XS_HTHW_JHH AS
SELECT b.jhh,b.zt,d.wlxqh,d.wlxqjhid,c.htid,a.scjhid
FROM sc_jhmx a,sc_jh b,xs_hthw c,sc_wlxqjh d,sc_wlxqjhmx e
WHERE a.scjhid=b.scjhid
AND a.hthwid=c.hthwid
AND a.scjhid=d.scjhid(+)
AND d.wlxqjhid=e.wlxqjhid(+)
GROUP BY b.jhh,b.zt,d.wlxqh,d.wlxqjhid,c.htid,a.scjhid
--2=已生成需求
--3=已下达任务
--8=已完成
--销售合同货物计划号;

prompt
prompt Creating view VW_XS_HTHW_KCL
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_XS_HTHW_KCL AS
SELECT t1."HTID",t1."WZDJID",t1."DMSXID",t1."HTHWID",t1."SL",t1."CPID",t1."CPBM",t1."GG",t1."PM",t1."PRODUCT",t1."SXZ",t1."KCDMSXID",t1."ZL",t1."PH", (t1.zl-nvl(t2.sdl,0)) xskgl, (t1.sl-t1.zl+nvl(t2.sdl,0)) ce
FROM
(
  SELECT a.htid, b.wzdjid, nvl(b.dmsxid,-1) dmsxid, b.hthwid, SUM(nvl(b.sl,0)) sl,
        c.cpid, c.cpbm, c.gg, c.pm, c.product, d.sxz, nvl(e.dmsxid,-1) kcdmsxid,
        SUM(nvl(e.zl,0))zl, e.ph
        --(nvl(e.zl,0)-nvl(e.sdzl,0))xskgl, SUM(nvl(b.sl,0)-nvl(e.zl,0)+nvl(e.sdzl,0)) ce,
  FROM xs_ht a, xs_hthw b, vw_xs_wzdj c, kc_wzmx e, kc_dmsx d
  WHERE a.htid=b.htid
  AND b.wzdjid=c.wzdjid
  AND b.dmsxid=d.dmsxid(+)
  AND c.cpid=e.cpid(+)
  GROUP BY a.htid,b.wzdjid, b.dmsxid, b.hthwid,
  c.cpid, c.cpbm, c.gg, c.pm, c.product, d.sxz, e.dmsxid, e.ph
) t1,
(
  SELECT b.cpid, nvl(b.dmsxid,-1) dmsxid, SUM(nvl(b.sl,0)-nvl(b.stsl,0)) sdl
  FROM  xs_td a, xs_tdhw b WHERE a.tdid = b.tdid AND a.isrefer=1 AND a.zt<>4
  GROUP BY b.cpid, b.dmsxid
) t2
WHERE t1.cpid = t2.cpid(+) AND t1.dmsxid = t2.dmsxid(+)
--销售合同查看合同货物的库存量与可供量;

prompt
prompt Creating view VW_XS_HTHW_RWD
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_XS_HTHW_RWD AS
SELECT b.wlxqjhid,c.rwdid,d.rwdh,d.rq,d.sm,d.zt,d.zdr,d.zsl,e.jhh
FROM sc_wlxqjh a,sc_wlxqjhmx b,sc_rwdmx c,sc_rwd d,sc_jh e
WHERE a.wlxqjhid=b.wlxqjhid
AND b.wlxqjhmxid=c.wlxqjhmxid
AND c.rwdid=d.rwdid(+)
AND a.scjhid=e.scjhid
GROUP BY b.wlxqjhid,c.rwdid,d.rwdh,d.rq,d.sm,d.zt,d.zdr,d.zsl,e.jhh
--任务单
--sm 说明
--rwdh 任务单号
--zdr 制单人;

prompt
prompt Creating view VW_XS_HTHW_THD
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_XS_HTHW_THD AS
SELECT a.htid,c.tdrq,c.tdbh,c.djlx,c.tdid
FROM xs_hthw a,xs_tdhw b,xs_td c
WHERE a.hthwid=b.hthwid
AND b.tdid=c.tdid
GROUP BY a.htid,c.tdrq,c.tdbh,c.djlx,c.tdid
--销售合同货物提货单;

prompt
prompt Creating view VW_XS_KC_SFDJ
prompt ===========================
prompt
create or replace view vw_xs_kc_sfdj as
select a."SFDJID",a."SFDJLBID",a."YTID",a."STOREID",a."DEPTID",a."JSFSID",a."KC__STOREID",a."DWTXID",a."SFDJDH",a."YKDRDH",a."SFRQ",a."DJXZ",a."JFKM",a."BZ",a."JSR",a."ZSL",a."ZJE",a."ZT",a."ZTMS",a."ZDRQ",a."ZDRID",a."ZDR",a."FGSID",a."SPRID",a."KHLX",a."PDID",a."ISREFER",d.tdbh
from kc_sfdj a,kc_sfdjmx b ,xs_tdhw c,xs_td d
where a.sfdjid=b.sfdjid
and a.djxz=2
and b.wjid=c.tdhwid
and c.tdid=d.tdid;

prompt
prompt Creating view VW_XS_KHCPZK
prompt ==========================
prompt
CREATE OR REPLACE VIEW VW_XS_KHCPZK AS
SELECT w.wzdjid, a.cpid, a.fgsid, a.dwtxid, a.khcpdm, a.dj, a.zk, a.bj, a.jjbl, a.bz,a.dmsxid,
       w.cpbm, w.product, w.jldw, w.xsjzj, w.xstcl, w.hkts, w.hktcl,w.xsj, w.storeid,w.xsjzj jzj,
       (w.wzdjid||'%'||a.dmsxid)cdmsxid
FROM   xs_khcpzk a, vw_xs_wzdj w
WHERE  a.fgsid = w.fgsid AND a.cpid = w.cpid
--客户产品折扣的视？-
---2004-2-28 添加了规格属性的检索 kc_dmsx 供销售合同引入客户历史产品
--关联wzdjid 与dmsxid 到字段cdmsxid;

prompt
prompt Creating view VW_XS_TDHW
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_XS_TDHW AS
SELECT a.tdrq,a.dwtxid,
       b.cpid,b.sl,b.jje,
       c.wzlbid,c.cpbm,c.pm,c.gg,
       d.dwmc,d.dwdm,
       e.dqmc,e.areacode,
       1 lb,
       f.bm
FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,dwdq e,kc_dmlb f
WHERE a.tdid=b.tdid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND d.dqh=e.dqh
AND c.wzlbid=f.wzlbid
UNION ALL
--已记帐 lb=2
SELECT a.tdrq,a.dwtxid,
       b.cpid,b.sl,b.jje,
       c.wzlbid,c.cpbm,c.pm,c.gg,
       d.dwmc,d.dwdm,
       e.dqmc,e.areacode,
       2 lb,
       f.bm
FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,dwdq e,cw_xsjs f,cw_xsjshx g,kc_dmlb f
WHERE a.tdid=b.tdid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND d.dqh=e.dqh
AND b.tdhwid=g.tdhwid
AND f.xsjsid=g.xsjsid
AND f.zt=8
AND c.wzlbid=f.wzlbid
--分栏帐用
--包括记帐与未记帐的提货单
--2004-4-26;

prompt
prompt Creating view VW_XS_TDHW_STATISTIC
prompt ==================================
prompt
CREATE OR REPLACE VIEW VW_XS_TDHW_STATISTIC AS
SELECT t.deptid,t.yf,t.nf,sum(t.je)zsl,t.dm,t.mc
FROM(
SELECT a.tdid,b.tdhwid,a.deptid,a.djlx,b.sfth,to_char(a.tdrq,'mm')yf,to_char(a.tdrq,'yyyy')nf,
       (decode(a.djlx,-1,-1,1)*b.jje*decode(b.sfth,0,1,1,-1))je,c.dm,c.mc
FROM xs_td a,xs_tdhw b,bm c
WHERE a.tdid=b.tdid  AND a.zt=8 AND a.deptid=c.deptid AND a.djlx IN(1,-1,2)
UNION ALL
SELECT a.tdid,b.tdhwid,a.deptid,a.djlx,b.sfth,to_char(a.tdrq,'mm')yf,to_char(a.tdrq,'yyyy')nf,
       (decode(a.djlx,-1,-1,1)*b.jje*decode(b.sfth,0,1,1,-1))je,c.dm,c.mc
FROM xs_td a,xs_tdhw b,bm c
WHERE a.tdid=b.tdid  AND a.zt=1 AND a.deptid=c.deptid AND a.djlx IN(4,5)
)t
GROUP BY t.deptid,t.yf,t.nf,t.dm,t.mc
--销售计划统计
--1=提货,-1=退货,2=广告促销单,3=销售赠送单,4=销售发货单,5=销售换货单;

prompt
prompt Creating view VW_XS_TD_DETAIL
prompt =============================
prompt
CREATE OR REPLACE VIEW VW_XS_TD_DETAIL AS
SELECT a.tdid,a.tdrq,a.dwtxid,b.cpid,b.sl,b.jje,c.wzlbid,c.cpbm,c.pm,c.gg,d.dwmc,d.dwdm,e.dqmc,e.areacode
FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,dwdq e
WHERE a.tdid=b.tdid
AND b.cpid=c.cpid
AND a.dwtxid=d.dwtxid
AND d.dqh=e.dqh
--销售提单明细;

prompt
prompt Creating view VW_XS_TEST
prompt ========================
prompt
CREATE OR REPLACE VIEW VW_XS_TEST AS
SELECT a.htid,b.wzdjid,c.cpid,c.cpbm,c.gg,c.pm,c.product,b.dmsxid,d.sxz
FROM xs_ht a,xs_hthw b,vw_xs_wzdj c,kc_dmsx d
WHERE a.htid=b.htid AND b.wzdjid=c.wzdjid AND b.dmsxid=d.dmsxid(+);

prompt
prompt Creating view VW_XS_WZDJ_NEW
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_XS_WZDJ_NEW AS
SELECT k.wzdjid, r.xs_jzj xsjzj, k.xstcl, k.hkts, k.hktcl, k.fgsid, nvl(k.xsj, r.xs_jzj) xsj, k.xsdj, nvl(k.isnet,0) isnet,
       w.cpid, w.cpbm, w.pm, w.gg, w.product, w.isprops, --品名规格
       w.jldw, w.zjm, w.th, w.jhdj, w.hsbl, w.txm, w.ztqq, w.wzlbid, w.storeid, w.abc, w.chxz,w.hsdw,r.cjno
FROM   xs_wzdj k, vw_kc_dm_exist w,xs_areaprice r
WHERE  k.cpid = w.cpid AND w.issale=1 AND k.wzdjid=r.wzdjid(+)
--k.isnet=1 OR (nvl(k.isnet,0)=0 AND nvl(k.shbj,0) = 1)--已经审批
--AND    k.cpid = kd.cpid
--销售合同选择物资视图;

prompt
prompt Creating view VW_XS_YSK
prompt =======================
prompt
CREATE OR REPLACE VIEW VW_XS_YSK AS
SELECT a.dwtxid,a.dwmc,b.rq,b.ysk,b.fgsid,b.khlx,d.dqmc,
to_number(a.dwdm)dwdm,d.dqh,d.areacode,b.personid,e.xm,a.deptid
FROM dwtx a,xs_ysk b,dwtx_lx c,dwdq d,emp e
WHERE a.dwtxid=b.dwtxid
and a.dwtxid=c.dwtxid(+)
AND b.personid=e.personid(+)
AND a.dqh=d.dqh
--and c.ywlx=2
AND a.isdelete=0
order by d.areacode,dwdm
--销售模块的销售应收款
/**
CREATE OR REPLACE VIEW VW_XS_YSK A
SELECT a.dwtxid,a.dwmc,b.rq,b.ysk,a.fgsid,b.khlx,d.dqmc,to_number(a.dwdm)dwdm,d.dqh,d.areacode,b.personid,e.xm
FROM dwtx a,xs_ysk b,dwtx_lx c,dwdq d,emp e
WHERE a.dwtxid=b.dwtxid
and a.dwtxid=c.dwtxid
AND b.personid=e.personid(+)
AND a.dqh=d.dqh
and c.ywlx=2
AND a.isdelete=0
order by d.areacode,dwdm
*/
--销售模块的销售应收款;

prompt
prompt Creating view VW_ZL_ADMINICLECHECK_BILL
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_ZL_ADMINICLECHECK_BILL AS
SELECT
a."ADMINICLECHECKID",a."CPID",a."DEPTID",a."DWTXID",a."ADMINICLECHECKNO",a."GOODS_DATE",a."TOT_NUM",a."FACIES",a."SAMPLE_INTEGER",a."TRYOUT_DATE",a."STATE",a."APPROVERID",a."STATE_DESC",a."ESTIMATION",a."REMARK",a."CREATEDATE",a."CREATORID",a."CREATOR",a."FILIALEID",a."DMSXID",a."CHECK_VERDICT",decode(a.check_verdict, 1, '合格', '0', '不合格') check_verdict_0,
(select b.cpbm from kc_dm b where a.cpid=b.cpid) cpbm_0,      --产品编码
(select b.pm from kc_dm b where a.cpid=b.cpid)  pm_0,
(select b.gg from kc_dm b where a.cpid=b.cpid) gg_0,           --品名规格
(select c.dwdm from dwtx c where a.dwtxid=c.dwtxid) dwdm_0,    --单位代码
(select c.dwmc from dwtx c where a.dwtxid=c.dwtxid) dwmc_0,    --单位名称=供应商
(select e.xm from emp e where a.approverid=e.personid) xm_0,   --审批人
(select f.mc from bm f where a.deptid=f.deptid) mc_0         --检验部门
from
zl_adminicleCheck a
--辅料验收报告单;

prompt
prompt Creating view VW_ZL_BUYCHECK
prompt ============================
prompt
CREATE OR REPLACE VIEW VW_ZL_BUYCHECK AS
SELECT
a.buycheckid,
a.filialeid,
a.productcheckno,--检验单号
(select b.sfdjdh from kc_sfdj b,kc_sfdjmx c where a.rkdmxid=c.rkdmxid and c.sfdjid=b.sfdjid) sfdjdh_0,--入库单号
(select d.dwdm from dwtx d where a.dwtxid=d.dwtxid) dwdm_0,
(select d.dwmc from dwtx d where a.dwtxid=d.dwtxid) dwmc_0,--供应商
(select e.cpbm from kc_dm e where a.cpid=e.cpid) cpbm_0,
(select e.pm from kc_dm e where a.cpid=e.cpid) pm_0,
(select e.gg from kc_dm e where a.cpid=e.cpid) gg_0,--产品名称
(select f.sxz from kc_dmsx f where a.dmsxid=f.dmsxid(+)) sxz_0,--规格属性
(select e.jldw from kc_dm e where a.cpid=e.cpid) jldw_0,--单位
a.get_date,--到货日期
a.get_num,--到货数量
a.buycheckdate,--抽检日期
a.check_num,--抽检数量
(select g.standardname from zl_checkstandard g where a.standardid=g.standardid) standardname_0,--检验依据
(select h.mc from bm h where a.deptid=h.deptid) mc_0,--检验部门
(select i.xm from emp i where a.personid=i.personid) xm_0,--检验员
decode(a.check_verdict,'1','合格','0','不合格') check_verdict_0,--检验结论
----------技术指标
j.checkitem,--检验项目
j.unit,--单位
j.techrequest,--标准要求
j.checkresult,--检验结果
decode(j.check_verdict,'1','合格','0','不合格') check_verdict_1,--从表结论
a.remark,--备注
a.createdate,--制单日期
a.creator,--制单人
(select i.xm from emp i where a.approverid=i.personid(+)) approverid_0,--审批人
---------外观
(select m.checkitem from zl_checkitem m where k.checkitemid=m.checkitemid) checkitem_0,--检验项目
k.result,--结论
k.remark as remark_1,--备注
-------------------------主表备注
a.remark as remark_0
from
ZL_BUYCHECK a,zl_buycheckdetail j,zl_facies k
where a.billtype='2' and a.buycheckid=j.buycheckid and a.buycheckid=k.buycheckid(+)
----原纸检验报告单;

prompt
prompt Creating view VW_ZL_BUYCHECK_FILM_CHECK
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_ZL_BUYCHECK_FILM_CHECK AS
SELECT
a.buycheckid,
a.filialeid,
a.productcheckno,--检验单号
(select b.sfdjdh from kc_sfdj b,kc_sfdjmx c where a.rkdmxid=c.rkdmxid and c.sfdjid=b.sfdjid) sfdjdh_0,--入库单号
(select d.dwdm from dwtx d where a.dwtxid=d.dwtxid) dwdm_0,
(select d.dwmc from dwtx d where a.dwtxid=d.dwtxid) dwmc_0,--供应商
(select e.cpbm from kc_dm e where a.cpid=e.cpid) cpbm_0,
(select e.pm from kc_dm e where a.cpid=e.cpid) pm_0,
(select e.gg from kc_dm e where a.cpid=e.cpid) gg_0,--产品名称
(select f.sxz from kc_dmsx f where a.dmsxid=f.dmsxid(+)) sxz_0,--规格属性
(select e.jldw from kc_dm e where a.cpid=e.cpid) jldw_0,--单位
a.get_date,--到货日期
a.get_num,--到货数量
a.buycheckdate,--抽检日期
a.check_num,--抽检数量
(select g.standardname from zl_checkstandard g where a.standardid=g.standardid) standardname_0,--检验依据
(select h.mc from bm h where a.deptid=h.deptid) mc_0,--检验部门
(select i.xm from emp i where a.personid=i.personid) xm_0,--检验员
decode(a.check_verdict,'1','合格','0','不合格') check_verdict_0,--检验结论
----------技术指标
j.checkitem,--检验项目
j.unit,--单位
j.techrequest,--标准要求
j.checkresult,--检验结果
decode(j.check_verdict,'1','合格','0','不合格') check_verdict_1,--从表结论
a.remark,--备注
a.createdate,--制单日期
a.creator,--制单人
(select i.xm from emp i where a.approverid=i.personid(+)) approverid_0,--审批人
---------外观
--(select m.checkitem from zl_checkitem m where k.checkitemid=m.checkitemid) checkitem_0,--检验项目
--k.result,--结论
--k.remark as remark_1,--备注
-------------------------主表备注
a.checker_postscript,--检验员辅言
a.remark as remark_0
from
ZL_BUYCHECK a,zl_buycheckdetail j--,zl_facies k
where a.billtype='1' and a.buycheckid=j.buycheckid --and a.buycheckid=k.buycheckid(+)
-----原膜进货检验报告单;

prompt
prompt Creating view VW_ZL_BUYCHECK_FILM_FACIES
prompt ========================================
prompt
CREATE OR REPLACE VIEW VW_ZL_BUYCHECK_FILM_FACIES AS
SELECT
a.buycheckid,
a.filialeid,
a.productcheckno,--检验单号
---------外观
(select c.checkitem from zl_checkitem c where b.checkitemid=c.checkitemid) checkitem_0,--检验项目
b.result,--结论
b.remark --备注
from
ZL_BUYCHECK a,zl_facies b
where a.billtype='1' and a.buycheckid=b.buycheckid
--原膜进货检验;

prompt
prompt Creating view VW_ZL_CERTIFIEDCARD_ORDER
prompt =======================================
prompt
CREATE OR REPLACE VIEW VW_ZL_CERTIFIEDCARD_ORDER AS
SELECT a."CARDID",a."DMSXID",a."CPID",a."CARDDATE",a."QUALITYER",a."SALENUM",a."OTHERNUM",a."PRODUCENUM",a."BATNO",a."MEMO",a."CREATEDATE",a."CREATORID",a."CREATOR",a."PRODUCEGRADE",a."DISPARTNUM",a."PRODUCEAREA",a."LINENUM",a."DEPTID",a."PAGENUM",a."GROSSNUM",b.cpbm,c.sxz,b.pm||b.gg product FROM zl_certifiedcard a,kc_dm b,kc_dmsx c WHERE a.cpid=b.cpid AND a.dmsxid=c.dmsxid;

prompt
prompt Creating view VW_ZL_CHEMICAL_BILL
prompt =================================
prompt
CREATE OR REPLACE VIEW VW_ZL_CHEMICAL_BILL AS
SELECT
a."CHEMICALCHECKID",a."DEPTID",a."PERSONID",a."DWTXID",a."CHEMICALCHECKNO",a."GET_DATE",a."CHECK_NUM",a."SHAREOUT_DATE",a."HUMIDITY",a."TEMPERATURE",a."CHECK_DATE",a."STATE",a."APPROVERID",a."STATE_DESC",a."ESTIMATION",a."CREATEDATE",a."CREATORID",a."CREATOR",a."FILIALEID",a."DMSXID",
b.chemicaldetailid,
b.porduct_name,
b.content_request,
b.content_result,
b.adhibit_request,
b.adhibit_result,
b.beginboil_request,
b.beginboil_result,
b.endboil_request,
b.endboil_result,
(select c.dwdm from dwtx c where a.dwtxid=c.dwtxid) dwdm_0,    --单位代码
(select c.dwmc from dwtx c where a.dwtxid=c.dwtxid) dwmc_0,    --单位名称=供应商
(select d.xm from emp d where a.approverid=d.personid) xm_0,   --审批人
(select d.xm from  emp d where a.personid = d.personid) jyrxm, --检验员
(select e.mc from bm e where a.deptid=e.deptid) mc_0         --检验部门
from
zl_chemical a,
zl_chemicaldetail b
where a.chemicalcheckid=b.chemicalcheckid(+)
--化工原料检验报告单;

prompt
prompt Creating view VW_ZL_NEWPROVIDER_BILL
prompt ====================================
prompt
CREATE OR REPLACE VIEW VW_ZL_NEWPROVIDER_BILL AS
SELECT
a.newproviderid,
a.newproviderno,  --单据号
(select c.dwmc from dwtx c where a.dwtxid=c.dwtxid) dwmc_0,   --单位名称=供应商
(select b.cpbm from kc_dm b where a.cpid=b.cpid) cpbm_0,      --产品编码
(select b.pm   from kc_dm b where a.cpid=b.cpid) pm_0,
(select b.gg   from kc_dm b where a.cpid=b.cpid) gg_0,        --品名规格
(select g.sxz  from kc_dmsx g where a.dmsxid=g.dmsxid and a.cpid=g.cpid) sxz_0,   --规格属性
(select b.jldw from kc_dm b where a.cpid=b.cpid) jldw_0,           --计量单位
a.get_date,       --来货日期
a.get_num,        --来货数量
a.check_num,      --抽检数量
a.check_date,     --抽检日期
(select h.standardname from  zl_checkStandard h where a.standardid=h.standardid) standardname_0,   --检验依据
(select i.xm from emp i where a.qualityid=i.personid) qualityid_0,       --检验员
decode(a.check_verdict, 1, '合格', '0', '不合格') check_verdict0 --检验结论
from
zl_newprovider a
--新供方产品质量评定表;

prompt
prompt Creating view VW_ZL_PROCESSCHECK_BILL
prompt =====================================
prompt
CREATE OR REPLACE VIEW VW_ZL_PROCESSCHECK_BILL AS
SELECT
a.processcheckid,
b.processdetailid,
a.processcheckno,--单据号
(select c.cpbm from kc_dm c where a.cpid=c.cpid) cpbm_0,   --产品编码
(select c.pm  from kc_dm c where a.cpid=c.cpid)  pm_0,
(select c.gg from kc_dm c where a.cpid=c.cpid) gg_0,       --品名规格
(select d.sxz from kc_dmsx d where a.cpid=d.cpid and a.dmsxid=d.dmsxid) sxz_0,   --规格属性
(select f.mc from bm f where a.deptid=f.deptid) mc_0,--检验部门
(select f.mc from bm f where a.plantid=f.deptid and f.iswork='1') mc_plant_0,      --车间
a.checknum,       --检验数量
a.rejectnum,       --不合格数
decode(a.check_verdict, '1', '合格', '0', '不合格') check_verdict_0,        --检验结论
decode(b.procedurename,'1','底涂','2','镀铝','3','面涂','4','回潮','5','纵切','6','压纹','7','横切') procedurename_0,   --工序名称
b.serial_num,      --生产编号
(select g.checkitem from zl_checkitem g where b.checkitemid=g.checkitemid) checkitem_0,--检验项目
(select g.unit from zl_checkitem g where b.checkitemid=g.checkitemid) unit_0,   --单位
(select g.appeal from zl_checkitem g where b.checkitemid=g.checkitemid) appeal_0,  --标准要求
b.produce_date,  --生产日期
b.check_date,    --抽样日期
b.checkresult, --检测结果
decode(b.check_verdict, 1, '合格', 0, '不合格') check_verdict_1,--检验结论
(select h.xm from emp h where b.personid=h.personid) personid_0,--检验员
b.remark remark_0,--备注
a.remark remark_1,--主表备注
(select h.xm from emp h where a.approverid=h.personid) xm_0,--审批人
a.createdate, --制单日期
a.creator,  --制单人
a.filialeid
from
zl_processcheck a,
zl_processdetail b
where a.processcheckid=b.processcheckid
--镀铝纸生产过程检验;

prompt
prompt Creating view VW_ZL_PRODUCT_FILM_CHECK
prompt ======================================
prompt
CREATE OR REPLACE VIEW VW_ZL_PRODUCT_FILM_CHECK AS
SELECT
a.productcheckid,
a.filialeid,
a.productcheckno,--检验单号
(select b.receivecode from sc_receiveprod b,sc_receiveproddetail c
where a.receivedetailid=c.receivedetailid
and c.receiveid=b.receiveid) sfdjdh_0,--收货单号
(select e.cpbm from kc_dm e where a.cpid=e.cpid) cpbm_0,
(select e.pm from kc_dm e where a.cpid=e.cpid) pm_0,
(select e.gg from kc_dm e where a.cpid=e.cpid) gg_0,--产品名称
(select f.sxz from kc_dmsx f where a.dmsxid=f.dmsxid(+)) sxz_0,--规格属性
(select e.jldw from kc_dm e where a.cpid=e.cpid) jldw_0,--单位
a.productno, --生产编号
a.buycheckdate,--抽检日期
a.check_num,--抽检数量
(select g.standardname from zl_checkstandard g
where a.standardid=g.standardid) standardname_0,--检验依据
a.reject_num,--不合格数
(select h.mc from bm h where a.deptid=h.deptid) mc_0,--检验部门
(select i.xm from emp i where a.personid=i.personid) xm_0,--检验员
decode(a.check_verdict,'1','合格','0','不合格') check_verdict_0,--检验结论
j.checkitem,--检验项目
j.unit,--单位
j.techrequest,--标准要求
j.checkresult,--检验结果
decode(j.check_verdict,'1','合格','0','不合格') check_verdict_1,--从表结论
a.createdate,--制单日期
a.creator,--制单人
(select i.xm from emp i where a.approverid=i.personid(+)) approverid_0--审批人
--(select m.checkitem from zl_checkitem m where k.checkitemid=m.checkitemid) checkitem_0,--检验项目
--k.result,--结论
--k.remark as remark_1--备注
from
zl_prodcheck a,zl_prodcheckdetail j--,zl_facies k
where a.billtype='1' and a.productcheckid=j.productcheckid(+)-- and a.productcheckid=k.productcheckid(+)
----成品膜检验报告单;

prompt
prompt Creating view VW_ZL_PRODUCT_WRAPPER_CHECK
prompt =========================================
prompt
CREATE OR REPLACE VIEW VW_ZL_PRODUCT_WRAPPER_CHECK AS
SELECT
a.productcheckid,
a.filialeid,
a.productcheckno,--检验单号
(select b.receivecode from sc_receiveprod b,sc_receiveproddetail c
where a.receivedetailid=c.receivedetailid
and c.receiveid=b.receiveid) receivecode_0,--收货单号
(select e.cpbm from kc_dm e where a.cpid=e.cpid) cpbm_0,
(select e.pm from kc_dm e where a.cpid=e.cpid) pm_0,
(select e.gg from kc_dm e where a.cpid=e.cpid) gg_0,--产品名称
(select f.sxz from kc_dmsx f where a.dmsxid=f.dmsxid(+)) sxz_0,--规格属性
(select e.jldw from kc_dm e where a.cpid=e.cpid) jldw_0,--单位
a.productno, --生产编号
a.buycheckdate,--抽检日期
a.check_num,--抽检数量
(select g.standardname from zl_checkstandard g
where a.standardid=g.standardid) standardname_0,--检验依据
a.reject_num,--不合格数
(select h.mc from bm h where a.deptid=h.deptid) mc_0,--检验部门
(select i.xm from emp i where a.personid=i.personid) xm_0,--检验员
decode(a.check_verdict,'1','合格','0','不合格') check_verdict_0,--检验结论
j.checkitem,--检验项目
j.unit,--单位
j.techrequest,--标准要求
j.checkresult,--检验结果
decode(j.check_verdict,'1','合格','0','不合格') check_verdict_1,--从表结论
a.createdate,--制单日期
a.creator,--制单人
(select i.xm from emp i where a.approverid=i.personid(+)) approverid_0--审批人
--(select m.checkitem from zl_checkitem m where k.checkitemid=m.checkitemid) checkitem_0,--检验项目
--k.result,--结论
--k.remark as remark_1--备注
from
zl_prodcheck a,zl_prodcheckdetail j,zl_facies k
where a.billtype='2' and a.productcheckid=j.productcheckid(+) and a.productcheckid=k.productcheckid(+)
-----成品纸检验报告单;

prompt
prompt Creating view VW_ZL_RKDMX_SELECT
prompt ================================
prompt
CREATE OR REPLACE VIEW VW_ZL_RKDMX_SELECT AS
SELECT a.rkdmxid,a.sfdjid,c.sfdjdh FROM kc_sfdjmx a,kc_sfdj c
where a.sfdjid=c.sfdjid;

prompt
prompt Creating package PCK_APPROVE
prompt ============================
prompt
CREATE OR REPLACE PACKAGE PCK_APPROVE IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose :
  -- Public type declarations
  --TYPE  rc  IS  REF CURSOR;
  -- Public constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Public variable declarations
  --<VariableName> <Datatype>;
  TYPE  rc  IS  REF CURSOR;
  /**
   * 添加审批列表
   * @param p_data_out    返回的数据集
   * @param p_projectcode  项目编码
   * @param p_projectcode  审批内容
   * @param p_personid  提交人
   * @param p_deptid  提交部门
   * @param p_rowkey  主键id
   * @param p_specialids  特殊审批项目id字符串,(格式:1,2,3)
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE addApproveList(
    p_data_out    OUT rc,      --返回的数据集
    p_projectcode IN VARCHAR2,
    p_spnr        IN VARCHAR,
    p_personid    IN INTEGER,
    p_deptid      IN INTEGER,
    p_rowkey      IN INTEGER,
    p_specialids  IN VARCHAR2 DEFAULT NULL
  );
  /**
   * 取消审批
   * @param p_spjlmxid  审批项目明细id
   * @param p_personid  审批人
   * @param p_sftg  是否通过，审批结果
   * @param p_spyj  审批意见
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE cancelApprove(
    p_spxmcode   IN VARCHAR2,
    p_personid   IN INTEGER,
    p_zjid       IN INTEGER,
    p_spyj       IN VARCHAR2 DEFAULT NULL
  );
  /**
   * 提交审批审
   * @param p_spjlmxid  审批项目明细id
   * @param p_personid  审批人
   * @param p_sftg  是否通过，审批结果
   * @param p_spyj  审批意见
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE submitApprove(
    p_spjlmxid   IN INTEGER,
    p_personid   IN INTEGER,
    p_sftg       IN INTEGER,
    p_spyj       IN VARCHAR2
  );
  /**
   * 更新相关表记录
   * @param p_spjlid    审批项目id
   * @param p_spjlmxid  审批项目明细id
   * @param p_rowkey    主键值
   * @param p_personid  审批人id
   * @param p_isreturn  是否驳回
   * @param p_isok      是否通过
   * @return 返回是否成功
   */
  FUNCTION updateRelativeRecord(
    p_spjlid   IN INTEGER,
    p_spjlmxid IN INTEGER,
    p_rowkey   IN INTEGER,
    p_personid IN INTEGER,
    p_isreturn IN BOOLEAN,
    p_isok     IN BOOLEAN
  ) RETURN BOOLEAN;
  /**
   * 取消相关表记录
   * @param p_spmxid    审批项目id
   * @param p_rowkey    主键值
   * @param p_ztms      传递的状态描述，用于取消审批
   * @return 返回是否成功
   */
  FUNCTION cancelRelativeRecord(
    p_spmxid   IN INTEGER,
    p_rowkey   IN INTEGER,
    p_ztms     IN VARCHAR2 DEFAULT ''
  ) RETURN BOOLEAN;
  /**
   * 得到审批项目流程可审批的人员id列表,以逗号分割
   * @param p_spjlid    审批项目id
   * @return 人员id列表
   */
  FUNCTION getApprovePerson(
    p_spjlid   IN NUMBER
  ) RETURN VARCHAR2;
  /**
   * 提取审批列表
   * p_data_out   OUT --返回的数据集
   * p_personid   IN  --人员id
   */
  PROCEDURE getApproveList(
    p_data_out   OUT rc,      --返回的数据集
    p_personid   IN NUMBER
  );
  /**
   * 审批项目是否事后审批得
   * @param p_spmxbm    审批项目编码
   * @return 返回是否事后审批得
   */
  FUNCTION isAfterApprove(
    p_spmxbm   IN VARCHAR2
  ) RETURN BOOLEAN;
END  PCK_APPROVE;
/

prompt
prompt Creating package PCK_BASE
prompt =========================
prompt
CREATE OR REPLACE PACKAGE pck_base IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 登录模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
  -- Public constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Public variable declarations
  --<VariableName> <Datatype>;
  /**
   * 提取字段的下一个编码
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_prefix_in    前缀（父结点的编码）
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @param p_addlength_in 递增的长度
   * @param p_isAddPrefix  返回的编码是否含有前缀
   * @return 返回下一个编码的值
   */
  FUNCTION fieldNextCode(
    p_table_in     IN VARCHAR2,
    p_field_in     IN VARCHAR2,
    p_prefix_in    IN VARCHAR2 DEFAULT NULL,
    p_where_in     IN VARCHAR2 DEFAULT NULL,
    p_addlength_in IN INT DEFAULT 2,
    p_isAddPrefix  IN INT DEFAULT 1
  ) RETURN VARCHAR2;
  /**
   * 提取单据字段的编码信息
   * @param p_table_in     JC_CODERULE的主键
   * @param p_prefix_in    返回的前缀前缀（父结点的编码）
   * @param p_extend_in    表名的扩展名
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @param p_isAddPrefix  返回的编码是否含有前缀(1=是,2=否)
   * @return 返回下一个编码的值
   */
  FUNCTION billNextCode(
    p_coderule_in  IN VARCHAR2,
    p_field_in     IN VARCHAR2 DEFAULT NULL,
    p_extend_in    IN VARCHAR2 DEFAULT NULL,
    p_where_in     IN VARCHAR2 DEFAULT NULL,
    p_isAddPrefix  IN INT      DEFAULT 1
  ) RETURN VARCHAR2;
  /**
   * 更新子结点的编码(在父结点的编码被更改时)
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_oldprefix_in 旧的前缀（旧的父结点的编码）
   * @param p_newprefix_in 新的前缀（新的父结点的编码）
   * @param p_where_in     where子句的字符串（isdelete=0）
   */
  PROCEDURE updateChildCode(
    p_table_in     IN VARCHAR2,
    p_field_in     IN VARCHAR2,
    p_oldprefix_in IN VARCHAR2,
    p_newprefix_in IN VARCHAR2,
    p_where_in     IN VARCHAR2 DEFAULT NULL
  );
  /**
   * 判断某一个表的字段的值是否已经存在
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_value_in     字段值
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION fieldCodeCount(
    p_table_in   IN VARCHAR2,
    p_field_in   IN VARCHAR2,
    p_value_in   IN VARCHAR2,
    p_where_in   IN VARCHAR2 DEFAULT NULL
  ) RETURN INT;
  /**
   * 提取系统参数
   * @param p_paramCode_in     表名
   * @param p_filialeID_in     字段名
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION systemParam(
    p_paramCode_in IN VARCHAR2,
    p_filialeID_in IN INT DEFAULT 0
  ) RETURN VARCHAR2;
  /**
   * 给数字补零
   * @param p_number_in     数字
   * @param p_format_in     格式话
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION fillZero(
    p_number_in    IN VARCHAR2,
    p_format_in    IN VARCHAR2 DEFAULT '000'
  ) RETURN VARCHAR2;

  /**
   * 格式化数字,只格式化化小数位
   * p_number_in    IN INTEGER,
   * p_format_in    IN VARCHAR2 DEFAULT '#.00'
   * @return 返回格式化后的数字
   */
  FUNCTION formartNumber(
    p_number_in    IN INTEGER,
    p_format_in    IN VARCHAR2 DEFAULT '#.00'
  ) RETURN INTEGER;

END  pck_base;
/

prompt
prompt Creating package PCK_BUY_REP
prompt ============================
prompt
CREATE OR REPLACE PACKAGE PCK_BUY_REP IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 库存模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
   /**
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(进货单或发票)
   * @param p_provideid_in IN VARCHAR2    供应商id
   * @param p_providetype_in IN VARCHAR2  供应商类型
   * @param p_personid_in IN VARCHAR2   业务员id
   * @param p_jhdcheck_in IN VARCHAR2   进货单是否包括未记帐 1,0
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE buy_receivable_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_provideid_in    IN VARCHAR2,
    p_providetype_in  IN VARCHAR2,
    p_personid_in   IN VARCHAR2,
    p_jhdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 采购应付款汇总
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_dqdm_in IN VARCHAR2   地区代码
   * @param p_dwdm_in IN VARCHAR2 单位代码
   * @param p_dwmc_in IN VARCHAR2   单位名称
   * @param p_khlx_in IN VARCHAR2   客户类型
   * @param p_billtype_in IN VARCHAR2  单据类型(进货单或发票)
   * @param p_check_in IN VARCHAR2   进货单是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE buy_balance(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_dqdm_in IN VARCHAR2,
    p_dwdm_in   IN VARCHAR2,
    p_dwmc_in IN VARCHAR2,
    p_khlx_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_check_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  ------------------------------------------------------------------------------
END  PCK_BUY_REP;
/

prompt
prompt Creating package PCK_COMPILE
prompt ============================
prompt
CREATE OR REPLACE PACKAGE pck_compile IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose :
  -- Public type declarations
  --TYPE  rc  IS  REF CURSOR;
  -- Public constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Public variable declarations
  --<VariableName> <Datatype>;
  /**
   * 编译不可用对象
   */
  PROCEDURE CompileInvalid;
  /**
   * 编译不可用对象
   * @param p_level     递归调用级数
   * @param p_objectid  数据库对象
   * @return 出错信息
   */
  FUNCTION CompileInvalid(
    p_level    IN INTEGER DEFAULT 0,
    p_objectid IN INTEGER DEFAULT 0
  ) RETURN VARCHAR2;
  /**
   * 编译对象
   * @param p_object_type  对象类型
   * @param p_object_name  对象名称
   * @return 出错信息
   */
  PROCEDURE CompileObject(
    p_object_type IN VARCHAR2,
    p_object_name IN VARCHAR2
  );
  /**
   * 添加字段
   * @param p_table_in  表名
   * @param p_column_in  字段名称
   * @param p_type_in  字段类型 1=字符型,2=文本型,3=枚举型,4=数值型
   * @param p_leng_in  字段长度
   * @param p_precision_in  精度
   * @param p_isAdd  是:添加字段,否:修改字段
   */
  PROCEDURE tableColumn(
    p_table_in     IN VARCHAR2,
    p_column_in    IN VARCHAR2,
    p_type_in      IN INT,
    p_leng_in      IN INT,
    p_precision_in IN INT DEFAULT 0,
    p_isAdd        IN INT DEFAULT 1
  );
  /**
   * 删除表字段
   * @param p_table_in  表名
   * @param p_column_in  字段名称
   */
  PROCEDURE dropTableColumn(
    p_table_in     IN VARCHAR2,
    p_column_in    IN VARCHAR2
  );
END  pck_compile;
/

prompt
prompt Creating package PCK_DATATOOL
prompt =============================
prompt
CREATE OR REPLACE PACKAGE PCK_DATATOOL IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 库存模块
  -- Public type declarations
  --TYPE  rc  IS  REF CURSOR;
  /**
   * 通过库存单据同步库存明细信息
   */
  PROCEDURE syncBillToStore;
  /**
   * 通过物资明细表（kc_wzmx）同步库存汇总信息
   */
  PROCEDURE syncStoreCollect;
  /**
   * 同步提单的出库量
   */
  PROCEDURE syncLadingOutNum;
  /**
   * 同步提单的锁定量
   */
  PROCEDURE syncLadingLockNum;

  /**
   * 同步库存单据的物资明细ID
   */
  PROCEDURE syncStoreBillWzmxid;

  /**
   * 同步库存物资明细的换算数量
   */
  PROCEDURE syncStoreBigNum;
  ------------------------------------------------------------------------------
END  PCK_DATATOOL;
/

prompt
prompt Creating package PCK_LOGIN
prompt ==========================
prompt
CREATE OR REPLACE PACKAGE pck_login IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 登录模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
  -- Public constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Public variable declarations
  --<VariableName> <Datatype>;
  --提取菜单的数据
  PROCEDURE getMenuData(
    p_data_out   OUT rc,       --返回的数据集
    p_userid_in  IN  VARCHAR2, --用户ID
    p_sysType_in IN  VARCHAR2  --系统类型
  );
  PROCEDURE getMenuData_new(
    p_data_out   OUT rc,       --返回的数据集
    p_userid_in  IN  VARCHAR2, --用户ID
    p_sysType_in IN  VARCHAR2  --系统类型
  );
  --根据入参取得该人员所具有的角色
  PROCEDURE getRoleData(
    cursorData  OUT  rc, --返回的数据集
    p_userId_in VARCHAR2
  );
  --提取用户信息
  PROCEDURE getUserInfo(
    p_data_out OUT rc, --返回的数据集
    p_user_in  IN  VARCHAR2, --用户名
    p_pass_in  IN  VARCHAR2  --密码
  );
  --提取用户的角色用例权限信息
  PROCEDURE getUserLimits(
    p_data_out     OUT rc,  --返回的数据集
    p_userid_in    IN INT, --用户序号
    p_url_in       IN VARCHAR2, --网页URL
    p_limitCode_in IN VARCHAR2 --权限编号
  );
  --用户更改密码
  PROCEDURE changepass(
    p_userid_in  VARCHAR2, --行序号
    p_newpass_in VARCHAR2 --新密码
  );
  --记录操作日志。记录内容为 操作员序号(登录用户)、操作时间(系统时间)、客户端ip、url、操作描述
  PROCEDURE writeLog(
    p_userid_in VARCHAR2,  --操作员序号
    p_ip_in     VARCHAR2,  --客户端ip
    p_url_in    VARCHAR2,  --url
    p_option_in VARCHAR2   --操作描述
  );
  /**
   * 提取所有的分公司信息
   * @param p_data_out  出参 返回的数据集
   */
  PROCEDURE getFilialesInfo(
    p_data_out  OUT  rc  --返回的数据集
  );
    --校验菜单的数据
  PROCEDURE checkMenuData(
    p_data_out   OUT rc,       --返回的数据集
    p_personid_in  IN  VARCHAR2, --用户ID
    P_nodeid_in    IN  VARCHAR2
  );
  PROCEDURE getOtherUserInfo(
    p_data_out OUT rc, --返回的数据集
    p_dwdm_in  IN  VARCHAR2, --单位代码    
    p_user_in  IN  VARCHAR2, --用户名
    p_pass_in  IN  VARCHAR2  --密码
  );  
END  pck_login;
/

prompt
prompt Creating package PCK_PERSON_REP
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE PCK_PERSON_REP IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 人力资源模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
    /**
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
   --职工变动情况表
    PROCEDURE rl_change_person(
    p_data_out OUT rc,     --返回的数据集
    p_deptid_in IN INTEGER,     --部门编号
    P_bm_in IN VARCHAR2,       --职工编码
    P_bdlx_in IN INTEGER,       --变动类型
    P_xm_in IN VARCHAR2        --员工姓名
    /*
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
    */
  );
  ------------------------------------------------------------------------------
END  PCK_PERSON_REP;
/

prompt
prompt Creating package PCK_PRODUCE
prompt ============================
prompt
CREATE OR REPLACE PACKAGE PCK_PRODUCE IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 库存模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
 /**
   * 提取BOM表的数据
   * p_data_out   OUT rc,      --返回的数据集
   * p_parentid   IN  INT      --父节点ID
   */
  PROCEDURE getBomTreeData(
    p_data_out   OUT rc,      --返回的数据集
    p_parentid   IN INT       --p_isself=1:父节点ID. p_isself=0:当前节点ID.
  );
  /**
   * 提取复制配料的数据(BOM表模块)
   * @param p_data_out   OUT rc,      --返回的数据集
   * @param p_copyid   IN  INT        --复制节点ID
   * @param p_pasteid  IN  INT        --粘贴节点ID
   */
  PROCEDURE getBomCopyData(
    p_data_out   OUT rc,       --返回的数据集
    p_copyid     IN INT,
    p_pasteid    IN INT
  );
  /**
   * 提取BOM节点显示的名称
   * p_cpid   IN  INT      --产品ID
   */
  FUNCTION getBomNodeCaption(
    p_cpid IN INT
  ) RETURN VARCHAR2;
  /**
   * 提取客户BOM节点的各个父节点id(客户BOM表模块)
   * @param p_dwtxid IN  INTEGER      --单位ID
   * @param p_hthwid IN  INT      --合同货物ID
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_fatherpath  IN  VARCHAR2  --父节点路径
   */
  FUNCTION getCustBomNodePath(
    p_dwtxid IN INTEGER,
    p_hthwid IN INTEGER,
    p_cpid   IN INTEGER,
    p_level  IN INT DEFAULT 0,
    p_fatherpath IN VARCHAR2 DEFAULT ''
  ) RETURN VARCHAR2;
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   */
  FUNCTION getBomChildNodePath(
    p_cpid  IN INT
  ) RETURN VARCHAR2;
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_childspath IN OUT VARCHAR2  --所有子节点路径
   */
  PROCEDURE procBomChildNodePath(
    p_cpid  IN INT,
    p_level IN INT,
    p_childspath IN OUT VARCHAR2
  );
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_fatherpath  IN  VARCHAR2  --父节点路径
   */
  FUNCTION getBomNodePath(
    p_cpid  IN INT,
    p_level IN INT DEFAULT 0,
    p_fatherpath IN VARCHAR2 DEFAULT ''
  ) RETURN VARCHAR2;
  /**
   * 判断p_otherid是否是p_cpid的父节点(物料成批替换和BOM表模块用到)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_otherid  IN  VARCHAR2  --父节点ID
   */
  FUNCTION isBomFatherNode(
    p_cpid  IN INT,
    p_level IN INT,
    p_otherid IN INT
  ) RETURN INT;
  /**
   * 更新父物资的提前期
   * @param p_childid   IN  INT      --子节点ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   */
  PROCEDURE updateBomProduceTime(
    p_childid  IN INT,
    p_level    IN INT DEFAULT 0
  );
  /**
   * 提取物料需求计划明细的数据(MRP表模块)
   * p_data_out   OUT rc,      --返回的数据集
   * p_scjhid   IN  INTEGER     --生产计划id
   */
  PROCEDURE getMRPdata(
    p_data_out   OUT rc,       --返回的数据集
    p_scjhid     IN INTEGER     --生产计划id
  );
  /**
   * 生产计划明细实际BOM数据(生产计划模块)
   * p_scjhmxid IN  INTEGER     --生产计划明细id
   * p_xshthwid IN  VARCHAR2   --销售合同货物ID
   * p_cpid     IN  INTEGER     --产品ID
   * p_xql      IN  INTEGER     --需求量
   * p_ksrq     IN  VARCHAR2   --总开始日期
   * p_count    IN INTEGER      与该计划明细处于同一计划的该计划明细总记录数量
   */
  PROCEDURE buildFactBOMdata(
    p_scjhmxid   IN INTEGER,
    p_xshthwid   IN VARCHAR2,
    p_cpid       IN INTEGER,
    p_dmsxid     IN VARCHAR2,
    p_xql        IN INTEGER,
    p_ksrq       IN VARCHAR2,
    p_count      IN INT
  );
  /**
   * 生成物料需求计划明细的数据(MRP表模块)
   * p_scjhmxid   OUT rc,      --生产计划明细id
   * p_xshtid   IN  INTEGER     --销售合同ID
   * p_cpid     IN  INTEGER     --上级产品ID
   * p_sjbomid  IN  INTEGER     --上级实际BOMID
   * p_xql      IN  INTEGER     --需求量
   * p_ksrq     IN  DATE       --总开始日期
   * p_level    IN  INTEGER     --层次数
   * p_count    IN  INT        --与该计划明细处于同一计划的该计划明细总记录数量
   */
  PROCEDURE insertFactBOMdata(
    p_scjhmxid   IN INTEGER,
    p_xshtid     IN INTEGER,  --销售合同id
    p_cpid       IN INTEGER,
    p_sjbomid    IN INTEGER,
    p_xql        IN INTEGER,
    p_ksrq       IN DATE,
    p_level      IN INT,
    p_count      IN INT
  );
  /**
   * 分切物料BOM的数据
   * p_scjhid   in  INTEGER,    --生产计划id
   * p_cpid     IN  INTEGER     --下级产品ID
   * p_dmsxid   IN  INTEGER     --下级规格属性ID
   * p_jlsl     IN  INTEGER     --计量数量
   * p_scsl     IN  INTEGER     --生产数量
   * p_level    IN  INTEGER     --层次数
   */
  PROCEDURE insertDispartCutBOMdata(
    p_scjhid     IN INTEGER,
    p_cpid       IN INTEGER,
    p_dmsxid     IN INTEGER,
    p_jlsl       IN INTEGER,
    p_scsl       IN INTEGER,
    p_level      IN INT
  );
  /**
   * 提取基本BOM数据(制定客户BOM模块)
   * p_data_out   OUT rc,      --返回的数据集
   * p_sjcpid   IN  INTEGER     --上级物资id
   */
  PROCEDURE getBaseBomData(
    p_data_out   OUT rc,       --返回的数据集
    p_sjcpid     IN INTEGER     --上级物资id
  );
  /**
   * 生成基本BOM数据(制定客户BOM模块)
   * p_sjcpid   IN  INTEGER     --上级物资id
   * p_level    IN  INTEGER     --递归层次数
   */
  PROCEDURE buildBaseBomData(
    p_sjcpid     IN INTEGER,     --上级物资id
    p_level      IN INT     --
  );
  /**
   * 生产计划回填销售合同的计划量
   * p_scjhmxid IN INTEGER     --生产计划明细id
   * p_xshthwid IN  INTEGER    --销售合同货物ID
   * p_add_sl_in  IN INTEGER   --增加或减少的计划量
   */
  PROCEDURE updateSaleOrderPlanNum(
    p_scjhmxid   IN INTEGER,
    p_xshthwid   IN INTEGER,
    p_add_sl_in  IN NUMBER
  );
  /**
   * 生产加工单回填生产任务单已排任务量
   * p_rwdmxid_in IN INTEGER   --生产任务单明细id
   * p_add_sl_in  IN INTEGER   --增加或减少的加工量
   * p_add_scsl_in  IN INTEGER   --增加或减少的加工单的生产数量
   */
  PROCEDURE updateProduceTaskNum(
    p_rwdmxid_in IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_scsl_in IN NUMBER
  );
  /**
   * 工人工作量回填生产加工单已排任务量
   * p_jgdmxid_in IN INTEGER   --生产加工单明细id
   * p_gx_in      IN VARCHAR  --工序名称
   * p_add_sl_in  IN INTEGER   --增加或减少的加工量
   */
  PROCEDURE updateProduceProcessNum(
    p_jgdmxid_in IN INTEGER,
    p_gx_in      IN VARCHAR,
    p_add_sl_in  IN NUMBER
  );
  /**
   * 生产任务单回填物料需求计划的已排任务量,生产计划已完成量
   * p_wlxqjhmxid_in IN INTEGER   --物料需求计划明细id
   * p_add_sl_in  IN INTEGER      --增加或减少的加工量
   * p_add_scsl_in  IN INTEGER      --增加或减少的加工的生产数量
   * @return 返回生产计划id
   */
  PROCEDURE updatePlanOverNum(
    p_wlxqjhmxid_in IN INTEGER,
    p_add_sl_in     IN INTEGER,
    p_add_scsl_in   IN NUMBER
  );
  /**
   * 更新物料需求计划明细的已购量（sc_wlxqjhmx)
   * @param  p_cgsqdhwid_in  --采购申请单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实提数量或换算数量
   * @param  p_fgsid_in    --分公司id
   */
  PROCEDURE updateMRPBuyNum(
    p_cgsqdhwid_in IN INTEGER,
    p_cpid_in      IN INTEGER,
    p_add_sl_in    IN INTEGER,
    p_ishssl_in    IN BOOLEAN
  );
  ------------------------------------------------------------------------------
END  PCK_PRODUCE;
/

prompt
prompt Creating package PCK_SALE_REP
prompt =============================
prompt
CREATE OR REPLACE PACKAGE PCK_SALE_REP IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 销售模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
  /**
   * 应收帐款明细表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_areacode_in IN VARCHAR2    地区号
   * @param p_custid_in IN VARCHAR2    客户id
   * @param p_custtype_in IN VARCHAR2  客户类型
   * @param p_salerid_in IN VARCHAR2   业务员id
   * @param p_tdcheck_in IN VARCHAR2   提单是否包括未记帐 1,0
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_areacode_in    IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_custtype_in  IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_tdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  ------------------------------------------------------------------------------
  /**
   * 应收帐款余额表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_areacode_in IN VARCHAR2  地区编号
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_custid_in IN VARCHAR2    客户id
   * @param p_custtype_in IN VARCHAR2  客户类型
   * @param p_salerid_in IN VARCHAR2   业务员id
   * @param p_tdcheck_in IN VARCHAR2   提单是否包括未记帐 1,0
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0
   * @param p_condition_in IN VARCHAR2   不显示本月没发生,期未余额为0的客户
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_balance(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_areacode_in  IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_custtype_in  IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_tdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_condition_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 应收帐款分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_custid_in IN VARCHAR2    客户id
   * @param p_salerid_in IN VARCHAR2   业务员id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 业务员应收帐款统计
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_deptid_in IN VARCHAR2   部门ID
   * @param p_personid_in IN VARCHAR2   业务员ID
   * @param p_check_in IN VARCHAR2   单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_saler_receivable(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_deptid_in   IN VARCHAR2,
    p_check_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  -------------------------------------------------------------------------------------
  /**
   * 销售资金回笼表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_money(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 销售数量金额表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_acmoney(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 月销售统计
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_acpm(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 销售合同
   * @param p_htid_in IN INTEGER 收发单据id
   *  param p_htid_in IN INTEGER,
    * param p_dwtxid_in     IN INTEGER,
   *  param p_htbh_in     IN VARCHAR2,
   * param p_htrq_in     IN DATE,
   *  param p_dwtxid_in     IN INTEGER
   */
  PROCEDURE xs_ht_add(
     p_htid_in IN INTEGER,
     p_dwtxid_in     IN INTEGER,
     p_htrq_in     IN DATE
  );
  /**
   * 销售合同货物
   * @param p_htid_in IN INTEGER 收发单据id
   *  param p_htid_in IN INTEGER,
    * param p_dwtxid_in     IN INTEGER,
   * param p_htrq_in     IN DATE,
   */
  PROCEDURE xs_hthw_add(
     p_htid_in IN INTEGER,
     p_hthwid_in IN INTEGER,
     p_wzdjid_in     IN INTEGER,
     p_sl_in     IN INTEGER,
     p_price_in     IN NUMBER DEFAULT 0
  );
END  PCK_SALE_REP;
/

prompt
prompt Creating package PCK_STORE
prompt ==========================
prompt
CREATE OR REPLACE PACKAGE PCK_STORE IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 库存模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
    /**
   * 提取最低报价的报价ID
   * p_data_out   OUT rc,        --返回的数据集
   * p_cgsqdid_in IN  VARCHAR2   --采购申请单ID
   */
  PROCEDURE getMinBuyPriceData(
    p_data_out   OUT rc,      --返回的数据集
    p_cgsqdid_in IN VARCHAR2  --采购申请单ID
  );
  /**
   * 提取最低报价的报价ID
   * @param p_htid_in     合同ID
   */
  FUNCTION getMinBuyPriceID(
    p_cpid_in    IN  INTEGER  --产品ID
  ) RETURN NUMBER;
  /**
   * 保存物资明细
   * @param  p_operate_in  --操作类型：insert:插入一条数据，update:更新数据, delete:删除数据
   * @param  p_wzmdxid_in  --库存物资明细ID
   * @param  p_cpid_in     --交货单货物ID
   * @param  p_rkdmdid_in  --入库单码单ID
   * @param  p_dmsxid_in   --物资规格属性ID
   * @param  p_storeid_in  --仓库ID
   * @param  p_kwid_in     --库位ID
   * @param  p_wjid_in     --外键ID
   * @param  p_djxz_in     --单据性质
   * @param  p_ph_id       --批号
   * @param  p_zl_in       --重量(更新时表示增加或减少的)
   * @param  p_bz_in       --备注
   * @param  p_fgsid_in    --分公司ID
   *
  PROCEDURE saveGoods(
    p_operate_in  IN VARCHAR2,  --操作类型：insert:插入一条数据，update:更新数据, delete:删除数据
    p_wzmxid_in   IN INTEGER,  --库存物资明细ID
    p_cpid_in     IN INTEGER DEFAULT NULL, --商品ID
    p_rkdmxid_in  IN INTEGER DEFAULT NULL, --入库单明细ID
    p_dmsxid_in   IN INTEGER DEFAULT NULL, --物资规格属性ID
    p_storeid_in  IN INTEGER DEFAULT NULL, --仓库ID
    p_kwid_in     IN INTEGER DEFAULT NULL, --库位ID
    p_wjid_in     IN INTEGER DEFAULT NULL, --外键ID
    p_djxz_in     IN INTEGER DEFAULT NULL, --单据性质
    p_sl_in       IN INTEGER DEFAULT NULL, --重量
    p_fgsid_in    IN INTEGER DEFAULT NULL, --分公司id
    p_ph_id       IN VARCHAR2 DEFAULT NULL, --批号
    p_bz_in       IN VARCHAR2 DEFAULT NULL --备注
  );*/
  /**
   * 更新库存货物库存数量（kc_wzmx）,如果不存就添加一条新的物资
   * @param  p_sl_in       IN INTEGER,                --重量
   * @param  p_hssl_in     IN INTEGER,                --换算数量
   * @param  p_fgsid_in    IN INTEGER,                --分公司id
   * @param  p_cpid_in     IN INTEGER,                --商品ID
   * @param  p_storeid_in  IN INTEGER,                --仓库ID
   * @param  p_kwid_in     IN INTEGER   DEFAULT NULL, --库位ID
   * @param  p_dmsxid_in   IN INTEGER   DEFAULT NULL, --物资规格属性ID
   * @param  p_ph_id       IN VARCHAR2 DEFAULT NULL, --批号
   * @param  p_dwtxid_in   IN INTEGER   DEFAULT NULL, --单位通讯ID
   * @param  p_wjid_in     IN INTEGER   DEFAULT NULL, --外键ID
   * @param  p_djxz_in     IN INTEGER   DEFAULT NULL, --单据性质
   * @param  p_bz_in       IN VARCHAR2 DEFAULT NULL  --备注
   ×@return 返回库存物资明细ID
   *
  FUNCTION addGoodsNum(
    p_sl_in       IN INTEGER,  --重量
    p_hssl_in     IN INTEGER,  --换算数量
    p_fgsid_in    IN INTEGER,  --分公司id
    p_cpid_in     IN INTEGER,  --商品ID
    p_storeid_in  IN INTEGER,  --仓库ID
    p_kwid_in     IN INTEGER,  --库位ID
    p_dmsxid_in   IN INTEGER,  --物资规格属性ID
    p_ph_id       IN VARCHAR2,--批号
    p_dwtxid_in   IN INTEGER,  --单位通讯ID
    p_wjid_in     IN INTEGER,  --外键ID
    p_djxz_in     IN INTEGER,  --单据性质
    p_bz_in       IN VARCHAR2 --备注
  ) RETURN NUMBER;
  /**
   * 更新库存货物库存数量（kc_wzmx）
   * @param  p_wzmdxid_in  --库存物资明细ID
   * @param  p_add_sl_in   --重量(更新时表示增加或减少的)
   * @param  p_add_hssl_in --换算数量(更新时表示增加或减少的)
   *
  PROCEDURE updateGoodsNum(
    p_wzmxid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN NUMBER
  );
  /**
   * 通过物资明细表（kc_wzmx）同步库存汇总信息
   *
  PROCEDURE syncStoreCollect;
  */
  /**
   * 物资移库
   * @param  p_wzmxid_in  --物资明细ID
   * @param  p_sl_in  --增加或减少的数量
   * @param  p_hssl_in  --增加或减少的换算数量
   * @param  p_in_storeid_in  --移进仓库
   * @param  p_in_storeid_in  --移进库位
   *
  PROCEDURE goodsMoveStore(
    p_wzmxid_in     IN INTEGER,
    p_sl_in         IN INTEGER,
    p_hssl_in       IN INTEGER,
    p_in_storeid_in IN INTEGER,
    p_in_kwid_in    IN NUMBER
  );
  /**
   * 更新销售货物锁定数量（kc_kchz）。开提单时候增加锁定量,出库时候减少锁定量
   * @param  p_wzmxid_in  --物资明细ID
   * @param  p_add_sl_in  --增加或减少的锁定数量
   * @param  p_add_hssl_in  --增加或减少的锁定数量
   *
  PROCEDURE updateSaleGoodsLock(
    p_wzmxid_in  IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_hssl_in  IN NUMBER
  );
  /**
   * 更新销售货物锁定数量（kc_kchz）。开提单时候增加锁定量,出库时候减少锁定量
   * @param  p_cpid_in    --产品ID
   * @param  p_dmsxid_in  --规格属性ID
   * @param  p_storeid_in --仓库ID
   * @param  p_fgsid_in   --分公司ID
   * @param  p_add_sl_in  --增加或减少的锁定数量
   * @param  p_add_hssl_in  --增加或减少的锁定数量
   *
  PROCEDURE updateSaleGoodsLock(
    p_cpid_in    IN INTEGER,
    p_dmsxid_in  IN INTEGER,
    p_storeid_in IN INTEGER,
    p_fgsid_in   IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_hssl_in  IN NUMBER
  );
  /**
   * 2004.2.28 锁定计划可供量的条件：产品id和规格属性id
   * 更新计划可供量(kc_dm）。生成计划时候减少计划可供量,自制入库单时候增加计划可供量
   * @param  p_cpid_in    --物资ID
   * @param  p_dmsx_id    --规格属性ID
   * @param  p_add_sl_in  --增加或减少的计划可供量
   *
  PROCEDURE updatePlanUsableGoods(
    p_cpid_in    IN INTEGER,
    p_dmsx_id    IN INTEGER,
    p_add_sl_in  IN NUMBER
  );
  /**
   * 更新销售合同和提单的实出库量（xs_hthw, xs_tdhw）
   * @param  p_tdhwid_in  --提单货物ID
   * @param  p_cpid_in    --物资id
   * @param  p_add_sl_in  --增加或减少的实提数量
   * @param  p_add_hssl_in  --增加或减少的实提换算数量
   * @param  p_fgsid_in  --分公司id
   * @param  p_date_in  --出库日期
   */
  PROCEDURE updateSaleOutStoreNum(
    p_tdhwid_in   IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_fgsid_in    IN INTEGER,
    p_date_in     IN DATE
  );
  /**
   * 更新采购合同和进货单的实入库量（cg_hthw, cg_htjhdhw)
   * @param  p_jhdhwid_in  --提单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实提数量
   * @param  p_add_hssl_in --增加或减少的实提换算数量
   * @param  p_ishssl_in   --是否是以换算数量为基本单位
   */
  PROCEDURE updateBuyInStoreNum(
    p_jhdhwid_in  IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  );
  /**
   * 更新进货单的实开票数量（cg_htjhdhw)
   * @param  p_jhdhwid_in  --采购进货单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实开票数量
   * @param  p_ishssl_in   --采购的单位是否用换算单位
   */
  PROCEDURE updateBuyInvoiceNum(
    p_jhdhwid_in  IN INTEGER,
    p_cpid_in      IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  );
  /**
   * 更新销售提单的实开票数量（cg_htjhdhw)
   * @param  p_tdhwid_in  --采购进货单货物ID
   * @param  p_add_sl_in   --增加或减少的实开票数量
   */
  PROCEDURE updateLadingInvoiceNum(
    p_tdhwid_in  IN INTEGER,
    p_add_sl_in   IN NUMBER
  );
  /**
   * 更新销售合同的实提单数量（xs_httd)
   * @param  p_hthwid_in   --销售合同货物ID
   * @param  p_add_sl_in   --增加或减少的提单数量
   * @param  p_add_hssl_in --增加或减少的实提单换算数量
   * @param  p_isover_in   --是否结束
   */
  PROCEDURE updateSaleOrderLadingNum(
    p_hthwid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_isover_in   IN BOOLEAN DEFAULT FALSE
  );
  /**
   * 更新采购合同的实进货单单数量（cg_htjhdhw)
   * @param  p_tdhwid_in   --采购合同货物ID
   * @param  p_add_sl_in   --增加或减少的进货单数量
   * @param  p_add_hssl_in --增加或减少的进货单换算数量
   * @param  p_ishssl_in   --采购的单位是否用换算单位
   */
  PROCEDURE updateBuyOrderInNum(
    p_hthwid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  );
  /**
   * 更新客户的历史产品记录（xs_khcpzk) 2004.2.29 添加规格属性参数
   * @param  p_dwtxid_in --往来单位id
   * @param  p_cpid_in   --产品id
   * @param  p_dmsx_in   --规格属性id
   * @param  p_zk_in     --折扣
   * @param  p_dj_in     --单价
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE updateCustHistoryProd(
    p_dwtxid_in   IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_dmsx_in     IN INTEGER,
    p_zk_in       IN INTEGER,
    p_dj_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  );
  /**
   * 更新客户的信誉度（xs_khxyed)
   * @param  p_dwtxid_in --往来单位id
   * @param  p_je_in     --折扣
   * @param  p_fgsid_in  --分公司id
   *
  PROCEDURE updateCustCreditNum(
    p_dwtxid_in   IN INTEGER,
    p_je_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  );
  /**
   * 根据提单更新客户的应收款（xs_khxyed)
   * @param  p_dwtxid_in --往来单位id
   * @param  p_je_in     --金额
   * @param  p_fgsid_in  --分公司id
   *
  PROCEDURE updateCustReceivableAccount(
    p_dwtxid_in   IN INTEGER,
    p_je_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  );*/
  -----------------------------------------------------------------------------
  -- 月结有关
  -----------------------------------------------------------------------------
  /**
   * 库存年度月结
   * @param  p_year_in   --年份
   * @param  p_month_in  --月份
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE doMonthBalance(
    p_year_in   IN INTEGER,
    p_month_in  IN INTEGER,
    p_fgsid_in  IN NUMBER
  );
  /**
   * 计算制造成本
   * @param  p_year_in   --年份
   * @param  p_month_in  --月份
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE calculateCost(
    p_startDate_in IN DATE,
    p_endDate_in   IN DATE,
    p_fgsid_in     IN NUMBER
  );
  /**
   * 计算半成品,成品成本
   * @param  p_jgcpid_in   --加工材料id
   * @param  p_fgsid_in  --分公司id
   * @param  p_level_in    --递归级数
   */
  FUNCTION getProductCostPrice(
    p_jgcpid_in  IN INTEGER,
    p_fgsid_in   IN INTEGER,
    p_level_in   IN INT DEFAULT 0
  )  RETURN NUMBER;

  /**
   * 计算原材料单价(大发用)
   * @param  p_jgcpid_in   --加工材料id
   * @param  p_fgsid_in  --分公司id
   * @param  p_level_in    --递归级数
   */
  PROCEDURE calcMaterialPrice(

    p_year_in      IN INTEGER,
    p_month_in      IN INTEGER,
    p_startDate_in IN DATE,
    p_endDate_in   IN DATE,
    p_fgsid_in     IN NUMBER
  );
  PROCEDURE kc_year_checkout(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,  --日期
    p_fgsid_in   IN VARCHAR2     --分公司id
    );
  ------------------------------------------------------------------------------
END  PCK_STORE;
/

prompt
prompt Creating package PCK_STORE_BILL
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE PCK_STORE_BILL IS
  -- Author  : ADMINISTRATOR
  -- Created : 2004-3-12 20:43
  -- Purpose : 库存单据打印模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
  /**
   * 采购入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Contract_Instore_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 销售出库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Outputlist_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
   /**
   * 生产领料单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Receive_Material_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
   /**
   * 自制收货单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Self_Gain_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 外加工入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Process_Instore_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 外加工发料单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Process_Issue_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 移库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Move_Store_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 损溢单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Report_Destroy_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 库存盘点单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_pdid_in IN INTEGER 盘点单id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Store_Check_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_pdid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 其它入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Other_Instore_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
  );
  ------------------------------------------------------------------------------
END  PCK_STORE_BILL;
/

prompt
prompt Creating package PCK_STORE_REP
prompt ==============================
prompt
CREATE OR REPLACE PACKAGE PCK_STORE_REP IS
  -- Author  : ADMINISTRATOR
  -- Created : 2002-4-17 10:56:16
  -- Purpose : 库存模块
  -- Public type declarations
  TYPE  rc  IS  REF CURSOR;
  /**
   * 存货收发单据明细帐报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_sxz_in IN VARCHAR2 规格属性模糊查询
   * @param p_dmsxid_in IN VARCHAR2  代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_sxz_in     IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_dmsxid_in     IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  );
  /**
   * 存货收发单据明细帐报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_sxz_in IN VARCHAR2 规格属性模糊查询
   * @param p_dmsxid_in IN VARCHAR2  代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_detail_new(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_sxz_in     IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_dmsxid_in     IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  );
   /**
   * 存货收发汇总报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_dmsxid_in IN VARCHAR2   代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  );
   /**
   * 存货收发日报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_date_in IN VARCHAR2      日期
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_property_in IN VARCHAR2 规格属性id
   * @param p_sfdjcheck_in IN VARCHAR2   是否包括未记账
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_inout_day(    --库存日报表存储过程
    p_data_out     OUT rc,      --返回的数据集
    p_date_in IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_stocksort_in IN VARCHAR2,
    p_productid_in IN VARCHAR2,
    p_property_in IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  );
  /**
   * 存货单据分类查询
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2   规格属性
   * @param p_djxz_in IN VARCHAR2      单据类别
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_deptid_in IN VARCHAR2   部门id
   * @param p_dwtxid_in IN VARCHAR2   往来单位ID
   * @param p_checkin_in IN VARCHAR2   是否包括未记账
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE kc_bill_inout_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_djxz_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_deptid_in  IN VARCHAR2,
    p_dwtxid_in  IN VARCHAR2,
    p_checkin_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  );
  --2004.04.12 20:52 新增 为收发类别分类汇总表(物资类别分类汇总)而新增的存储过程. jac
   /**
   * 收发类别分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库ID
   * @param p_chlbid_in  in VARCHAR2   存货类别ID
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE AssortCollect(
    p_data_out      OUT rc,      --返回的数据集
    p_startdate_in  IN VARCHAR2,
    p_enddate_in    IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_chlbid_in     IN VARCHAR2,
    p_fgsid_in      IN VARCHAR2
  );
  --2004.03.23 22:38 新增 为收发类别分类汇总表（按产品汇总）而新增的存储过程. jac
   /**
   * 收发类别分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库ID
   * @param p_chlbid_in  in VARCHAR2   存货类别ID
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE AssortCollectDetail(
    p_data_out      OUT rc,      --返回的数据集
    p_startdate_in  IN VARCHAR2,
    p_enddate_in    IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_chlbid_in     IN VARCHAR2,
    p_fgsid_in      IN VARCHAR2
  );
    /**
   * 存货库存量报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_wztype_in IN VARCHAR2   物资类别id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_number(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    --p_wztype_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
  /**
   * 存货明细报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2 规格属性id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_ph_in IN VARCHAR2   批号
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_product_number(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    p_ph_in  IN VARCHAR2,
    --p_wztype_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );

  ------------------------------------------------------------------------------------
  /**
   * 存货明细报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2 规格属性id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_ph_in IN VARCHAR2   批号
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_product_number_new(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    --p_ph_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  );
--------------------------------------------------------------------
END  PCK_STORE_REP;
/

prompt
prompt Creating procedure ERP_DWTX_INSERT
prompt ==================================
prompt
create or replace procedure erp_dwtx_insert(
rtncode out number,
rtnmessage out varchar,
lxrID out number,
dwtxId out number,
xm in varchar,
dzyj in varchar,
yzbm in varchar,
sr in date,
sex in number,
xxdz in varchar,
bgdh in varchar,
yddh in varchar
) is
dwtx number;
lxr number;

begin
   select s_dwtx.nextval into dwtx from dual;
   select s_dwtx_lxr.nextval into lxr from dual;

   insert into dwtx(dwtxid,dwmc,isdelete,fgsid)values(dwtx,xm,0,0);
   insert into dwtx_lxr(lxrid, dwtxid, xm, sex, bgdh, yddh, sr, xxdz, dzyj, yzbm)values(
                        lxr,dwtx,xm,sex,bgdh,yddh,sr,xxdz,dzyj,yzbm);
   insert into dwtx_lx(dwtxlxid, dwtxid, ywlx)values(s_dwtx_lx.nextval,dwtx,1);
   insert into dwtx_lx(dwtxlxid, dwtxid, ywlx)values(s_dwtx_lx.nextval,dwtx,2);

rtncode :=0;
rtnmessage:='success';
lxrID := lxr;
dwtxId := dwtx;
end erp_dwtx_insert;
/

prompt
prompt Creating package body PCK_APPROVE
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_APPROVE IS
  -- Private type declarations
  --type <TypeName> is <Datatype>;
  -- Private constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Private variable declarations
  --<VariableName> <Datatype>;
  -- Function and procedure implementations
/*  function <FunctionName>(<Parameter> <Datatype>) return <Datatype> is
    <LocalVariable> <Datatype>;
  begin
    <Statement>;
    return(<Result>);
  end;*/
  FLOW_OPERATE_SUCCEED  CONSTANT INT := 1;    --成功
  FLOW_NO_EXIST         CONSTANT INT := -2001;    --所填的项目不存在
  FLOW_NO_DEFINE        CONSTANT INT := -2002;    --没有定义审批流程
  FLOW_NO_PERSON        CONSTANT INT := -2003;    --审批流程没有定义审批人
  FLOW_ALREADY_EXECUTE  CONSTANT INT := -2004;    --已经在审批之中
  /**
   * 添加审批列表，2004.02.26添加,若没审批流程,则审批人为提交人
   * @param p_data_out    返回的数据集
   * @param p_projectcode  项目编码
   * @param p_projectcode  审批内容
   * @param p_personid  提交人
   * @param p_deptid  提交部门
   * @param p_rowkey  主键id
   * @param p_specialids  特殊审批项目id字符串,(格式:1,2,3)
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE addApproveList(
    p_data_out    OUT rc,      --返回的数据集
    p_projectcode IN VARCHAR2,
    p_spnr        IN VARCHAR,
    p_personid    IN INTEGER,
    p_deptid      IN INTEGER,
    p_rowkey      IN INTEGER,
    p_specialids  IN VARCHAR2 DEFAULT NULL
  )
  IS
    c_spxmdata   rc;                  --审批项目明细数据
    v_spxmid     sp_xm.spxmid%TYPE;    --审批项目id
    v_spxmmc     sp_xm.spxmmc%TYPE;    --审批项目名称
    v_dybm       sp_xm.dybm%TYPE;      --对应表名
    v_zjzdm       sp_xm.zjzdm%TYPE;      --主键字段名
    v_ztzdm       sp_xm.ztzdm%TYPE;      --状态字段名
    v_zttgz      sp_xm.zttgz%TYPE;      --状态通过值
    v_ztmszdm    sp_xm.ztmszdm%TYPE;   --状态描述字段名
    v_spridzdm   sp_xm.spridzdm%TYPE;  --2004.02.26添加
    v_spxmmxid   sp_xmmx.spxmmxid%TYPE; --
    v_spdj       sp_xmmx.spdj%TYPE; --审批等级
    v_spmc       sp_xmmx.spmc%TYPE; --审批名称
    v_url        sp_xmmx.url%TYPE;  --url
    v_spxmtsmxid sp_xmmx.spxmtsmxid%TYPE; --特殊明细id
    v_tsz        sp_xmmx.tsz%TYPE;  --特殊值
    --
    v_spjlid     sp_jl.spjlid%TYPE := -1; --审批记录id
    v_count      INT;
    v_sql        VARCHAR2(300);
  BEGIN
  /*
  审批记录ID    spjlID  NO11
  人员ID        personid  提交人
  部门id        deptid  提交部门
  审批项目编码  spxmbm  VA32
  审批项目名称  spxmmc  VA32
  主键id        zjid  N
  提交审批日期  tjsprq  D
  是否结束      sfjs  N1
  --
  审批记录明细ID  spjlmxID    INTEGER
  人员ID          personid  审批人  INTEGER
  审批项目明细ID  spxmmxID    INTEGER
  审批记录ID      spjlID    INTEGER
  审批等级        spdj    INTEGER
  审批名称        spmc    VARCHAR2(32)
  是否通过        sftg    INTEGER
  审批意见        spyj  审批意见  VARCHAR2(256)
  URL              URL    VARCHAR2(128)
  */
    BEGIN
      SELECT x.spxmid, x.spxmmc, x.dybm, x.zjzdm, x.ztzdm, x.zttgz, x.ztmszdm, x.spridzdm
      INTO   v_spxmid, v_spxmmc, v_dybm, v_zjzdm, v_ztzdm, v_zttgz, v_ztmszdm, v_spridzdm
      FROM   sp_xm x   WHERE x.spxmbm = p_projectcode;
    EXCEPTION
      WHEN no_data_found THEN
        OPEN p_data_out FOR
        SELECT FLOW_NO_EXIST AS resultCode, '相对应的审批项目不存在' AS resultCap FROM dual;
        RETURN;
    END;
    --判断所填项目是否已经在审批之中
    SELECT COUNT(*) INTO v_count
    FROM sp_jl j
    WHERE nvl(j.sfjs, 0)=0 AND j.spxmid = v_spxmid AND j.zjid = p_rowkey;
    IF(v_count > 0) THEN
      OPEN p_data_out FOR
      SELECT FLOW_ALREADY_EXECUTE AS resultCode, '该记录已经在审批之中' AS resultCap FROM dual;
      RETURN;
    END IF;
    --校验是否有定义审批人
    FOR c_lc IN (
      SELECT a.spxmmxid, COUNT(r.personid) num
      FROM   sp_xmmx a, sp_spr r
      WHERE  a.spxmmxid = r.spxmmxid(+) AND a.spxmid = v_spxmid
      GROUP BY a.spxmmxid
    )
    LOOP
      IF(c_lc.num < 1) THEN
        OPEN p_data_out FOR
        SELECT FLOW_NO_PERSON AS resultCode, '其中一条审批流程未定义审批人' AS resultCap FROM dual;
        RETURN;
      END IF;
    END LOOP;
    --提取定义的审批流程
    /*FOR c_mx IN (
      SELECT a.spxmmxid, a.spdj, a.spmc, a.url, a.spxmtsmxid, a.tsz
      FROM   sp_xmmx a WHERE  a.spxmid = v_spxmid  ORDER BY a.spdj
    )*/
    v_sql := 'SELECT a.spxmmxid, a.spdj, a.spmc, a.url, a.spxmtsmxid, a.tsz FROM sp_xmmx a WHERE ';
    IF(p_specialids IS NOT NULL) THEN
    --2004.4.9用spxmmxid代替spxmtsmxid
    --v_sql := v_sql || '(a.spxmmxid NOT IN ('|| p_specialids ||') OR a.spxmtsmxid IS NULL) AND ';
      v_sql := v_sql || 'a.spxmmxid NOT IN ('|| p_specialids ||') AND ';
    END IF;
    v_sql := v_sql || 'a.spxmid ='|| v_spxmid ||' ORDER BY a.spdj';
    OPEN c_spxmdata FOR v_sql;
    LOOP
      FETCH c_spxmdata INTO v_spxmmxid, v_spdj, v_spmc, v_url, v_spxmtsmxid, v_tsz;
      EXIT WHEN c_spxmdata%NOTFOUND;
      IF(v_spjlid < 0) THEN
        SELECT s_sp_jl.NEXTVAL INTO v_spjlid FROM dual;
        --插入审批记录
        INSERT INTO sp_jl(spjlid, spxmid, personid, deptid, spnr,
          spxmbm, spxmmc, zjid, tjsprq, sfjs)
        VALUES (v_spjlid, v_spxmid, p_personid, p_deptid, p_spnr,
          p_projectcode, v_spxmmc, p_rowkey, SYSDATE, 0);
      END IF;
      --插入审批审批记录明细
      INSERT INTO sp_jlmx(spjlmxid, spxmmxid, spjlid, spdj, spmc,
        sftg, url, spxmtsmxid, tsz)
      VALUES (s_sp_jlmx.NEXTVAL, v_spxmmxid, v_spjlid, v_spdj, v_spmc,
        0, v_url, v_spxmtsmxid, v_tsz);
    END LOOP;
    CLOSE c_spxmdata;
    --如果没有审批流程， 2004.02.26添加,若没审批流程,则审批人为提交人
    IF(v_spjlid < 0) THEN
      v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztzdm ||'='''|| v_zttgz ||''','||
               v_spridzdm || '=''' || p_personid ||''','||
               v_ztmszdm ||'=''通过审批(没有审批流程)'' WHERE '|| v_zjzdm ||'='|| p_rowkey;
      EXECUTE IMMEDIATE v_sql;
      IF(SQL%ROWCOUNT<>1)THEN
        raise_application_error(-20001, '数据没有发现!');
      END IF;
      OPEN p_data_out FOR
      SELECT FLOW_NO_DEFINE AS resultCode, '通过审批(没有审批流程)' AS resultCap, v_spjlid AS spjlid,
      v_zjzdm AS zjzdm, v_ztzdm AS ztzdm, v_zttgz AS zttgz, v_ztmszdm AS ztmszdm, 9 ztddz,
      v_spridzdm AS spridzdm
      FROM dual;
      RETURN;
    END IF;
    v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztzdm ||'=''9'','||
             v_ztmszdm ||'=''审批中'' WHERE '|| v_zjzdm ||'='|| p_rowkey;
    EXECUTE IMMEDIATE v_sql;
    IF(SQL%ROWCOUNT<>1)THEN
      raise_application_error(-20001, '数据没有发现!');
    END IF;
    OPEN p_data_out FOR
    SELECT FLOW_OPERATE_SUCCEED AS resultCode, '审批中' AS resultCap, v_spjlid AS spjlid,
    v_zjzdm AS zjzdm, v_ztzdm AS ztzdm, v_zttgz AS zttgz, v_ztmszdm AS ztmszdm, 9 ztddz
    FROM dual;
  END addApproveList;
  /**
   * 取消审批
   * @param p_spjlmxid  审批项目明细id
   * @param p_personid  审批人
   * @param p_sftg  是否通过，审批结果
   * @param p_spyj  审批意见
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE cancelApprove(
    p_spxmcode   IN VARCHAR2,
    p_personid   IN INTEGER,
    p_zjid       IN INTEGER,
    p_spyj       IN VARCHAR2 DEFAULT NULL
  )
  IS
    v_spxmid sp_xm.spxmid%TYPE;
    v_spjlid sp_jl_ls.spjlid%TYPE;
    v_count  INT; --没有通过审批的流程记录数
    v_retu   BOOLEAN;
  BEGIN
    BEGIN
      SELECT spxmid INTO v_spxmid FROM sp_xm x WHERE x.spxmbm = p_spxmcode;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20000, '不存在的审批项目');
    END;
    --是否定义审批流程
    SELECT COUNT(*) INTO v_count
    FROM sp_xmmx b WHERE b.spxmid = v_spxmid;
    IF (v_count = 0) THEN--没有审批流程，直接取消
      v_retu := cancelRelativeRecord(v_spxmid, p_zjid);
      RETURN;
    END IF;
    --是否在审批中
    SELECT COUNT(*) INTO v_count
    FROM sp_jl j WHERE j.zjid = p_zjid AND j.spxmid = v_spxmid;
    IF(v_count > 0) THEN
      raise_application_error(-20001, '该项目已经在审批中');
    END IF;
    --得到最近一次审批记录id
    BEGIN
      SELECT t.spjlid INTO v_spjlid
      FROM
      ( SELECT l.spjlid FROM sp_jl_ls l WHERE l.spxmbm = p_spxmcode AND l.zjid = p_zjid
        ORDER BY l.tjsprq DESC, l.spjlid DESC
      ) t
      WHERE ROWNUM< 2;
    EXCEPTION
      WHEN no_data_found THEN
        v_retu := cancelRelativeRecord(v_spxmid, p_zjid);
        RETURN;
    END;
    --插入取消审核记录
    SELECT nvl(MAX(nvl(m.spdj,0)),0)+1 INTO v_count FROM sp_jlmx_ls m WHERE m.spjlid = v_spjlid;
    INSERT INTO sp_jlmx_ls(spjlmxid, spjlid, spdj, spmc, sftg, sprq, spyj, spr)
    SELECT s_sp_jlmx.NEXTVAL, v_spjlid, v_count, '取消审批', 3, SYSDATE, p_spyj,
      (SELECT e.xm FROM emp e WHERE e.personid = p_personid) spr
    FROM dual;
    --取消数据记录状态
    v_retu := cancelRelativeRecord(v_spxmid, p_zjid);
  END cancelApprove;
  --隐式游标只使用SQL%FOUND,SQL%NOTFOUND,SQL%ROWCOUNT三个属性.SQL%FOUND,SQL%NOTFOUND是布尔值，SQL%ROWCOUNT是整数值
  --在执行任何DML语句前SQL%FOUND和SQL%NOTFOUND的值都是NULL
  /**
   * 提交审批审
   * @param p_spjlmxid  审批项目明细id
   * @param p_personid  审批人
   * @param p_sftg  是否通过，审批结果
   * @param p_spyj  审批意见
   * @return 结果信息. 1:成功 2:所填的项目不存在 3:没有审批流程  4:已经在审批之中
   */
  PROCEDURE submitApprove(
    p_spjlmxid   IN INTEGER,
    p_personid   IN INTEGER,
    p_sftg       IN INTEGER,
    p_spyj       IN VARCHAR2
  )
  IS
    v_spjlid   sp_jl.spjlid%TYPE;
    v_zjid     sp_jl.zjid%TYPE; --审批记录的主键值
    v_spjlmxid sp_jlmx.spjlmxid%TYPE;
    v_count  INT; --没有通过审批的流程记录数
    v_no     BOOLEAN;
  BEGIN
    IF(p_sftg <> 2 AND p_sftg <> 1) THEN
      raise_application_error(-20000, '非法审批值!');
    END IF;
    --锁定记录
    SELECT m.spjlmxid INTO v_spjlmxid FROM sp_jlmx m
    WHERE m.spjlmxid=p_spjlmxid FOR UPDATE;
    UPDATE sp_jlmx m
    SET m.personid = p_personid, m.sftg = p_sftg,
        m.spyj = p_spyj, m.sprq = SYSDATE
    WHERE m.spjlmxid = p_spjlmxid;
    --
    IF(SQL%NOTFOUND)THEN
      raise_application_error(-20001, '不存在该审批流程记录!');
    END IF;
    --得到审批记录id, 锁定记录
    BEGIN
      SELECT m.spjlid INTO v_spjlid FROM sp_jlmx m
      WHERE  m.spjlmxid = p_spjlmxid FOR UPDATE;
      SELECT j.zjid INTO v_zjid FROM sp_jl j
      WHERE  j.spjlid = v_spjlid FOR UPDATE;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20002, '不存在的审批项目!');
    END;
    --审批结果分支
    IF(p_sftg = 1) THEN--通过，得到还未审批的记录数
      SELECT COUNT(*) INTO v_count FROM sp_jlmx m
      WHERE nvl(m.sftg, 0) = 0 AND m.spjlid = v_spjlid;
    END IF;
    --驳回或全部审批通过
    IF(p_sftg = 2 OR (p_sftg = 1 AND v_count = 0)) THEN
      --插入记录到历史表
      INSERT INTO sp_jl_ls(spjlid, spxmbm, spxmmc,  spnr,   zjid,   tjsprq,   tjbm, tjr)
      SELECT          j.spjlid, j.spxmbm, j.spxmmc, j.spnr, j.zjid, j.tjsprq, b.mc, e.xm
      FROM   sp_jl j, emp e, bm b
      WHERE  j.personid = e.personid(+) AND j.deptid = b.deptid
      AND    j.spjlid = v_spjlid;
      INSERT INTO sp_jlmx_ls(spjlmxid, spjlid, spdj, spmc, sftg, sprq, spyj, url, spr)
      SELECT m.spjlmxid, m.spjlid, m.spdj, m.spmc, m.sftg, m.sprq, m.spyj, m.url, e.xm
      FROM   sp_jlmx m, emp e
      WHERE  m.personid = e.personid(+)
      AND    m.spjlid = v_spjlid;
    END IF;
    --更新相关表记录
    v_no := updateRelativeRecord(v_spjlid, p_spjlmxid, v_zjid, p_personid, p_sftg=2, (p_sftg = 1 AND v_count = 0));
    IF(v_no)THEN
      raise_application_error(-20003, '查找不到该审批项目记录!');
    END IF;
    IF(p_sftg = 2 OR (p_sftg = 1 AND v_count = 0)) THEN
      --删除原表记录
      DELETE FROM sp_jlmx m WHERE m.spjlid = v_spjlid;
      DELETE FROM sp_jl j WHERE j.spjlid = v_spjlid;
    END IF;
  END submitApprove;
  /**
   * 更新相关表记录
   * @param p_spjlid    审批项目id
   * @param p_spjlmxid  审批项目明细id
   * @param p_rowkey    主键值
   * @param p_personid  审批人id
   * @param p_isreturn  是否驳回
   * @param p_isok      是否通过(全部审批通过)
   * @return 返回是否失败
   */
  FUNCTION updateRelativeRecord(
    p_spjlid   IN INTEGER,
    p_spjlmxid IN INTEGER,
    p_rowkey   IN INTEGER,
    p_personid IN INTEGER,
    p_isreturn IN BOOLEAN,
    p_isok     IN BOOLEAN
  ) RETURN BOOLEAN
  IS
    v_dybm    sp_xm.dybm%TYPE;      --对应表名
    v_zjzdm    sp_xm.zjzdm%TYPE;      --主键字段名
    v_ztzdm    sp_xm.ztzdm%TYPE;      --状态字段名
    v_zttgz   sp_xm.zttgz%TYPE;      --状态通过值
    v_ztbtgz  sp_xm.zttgz%TYPE;     --状态不通过值
    v_ztmszdm sp_xm.ztmszdm%TYPE;   --状态描述字段名
    v_spridzdm sp_xm.spridzdm%TYPE; --审批人id字段名
    v_ztmstgz  sp_xmmx.ztmstgz%TYPE;   --状态描述通过值
    v_ztmsbtgz sp_xmmx.ztmsbtgz%TYPE;   --状态描述不通过值
    v_sql VARCHAR2(200);
  BEGIN
    BEGIN
      SELECT x.dybm, x.zjzdm, x.ztzdm, x.zttgz, x.ztbtgz, x.ztmszdm, x.spridzdm
      INTO   v_dybm, v_zjzdm, v_ztzdm, v_zttgz, v_ztbtgz, v_ztmszdm, v_spridzdm
      FROM   sp_jl j, sp_xm x
      WHERE  j.spxmid = x.spxmid AND j.spjlid = p_spjlid;
      SELECT n.ztmstgz, n.ztmsbtgz INTO v_ztmstgz, v_ztmsbtgz
      FROM   sp_jlmx m, sp_xmmx n
      WHERE  m.spxmmxid = n.spxmmxid AND m.spjlmxid = p_spjlmxid;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN FALSE;
    END;
    --更新相关记录
    --update v_dybm set v_ztzdm='v_zttgz', v_ztmszdm='不用审批' where v_zjzdm = p_rowkey
    IF(p_isreturn) THEN
      v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztzdm ||'='''|| v_ztbtgz ||''','||
        v_ztmszdm ||'='''|| v_ztmsbtgz ||''' WHERE '|| v_zjzdm ||'='|| p_rowkey;
    ELSIF(p_isok) THEN
      v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztzdm ||'='''|| v_zttgz ||''','||
        v_spridzdm ||'='''|| p_personid ||''','||
        v_ztmszdm ||'='''' WHERE '|| v_zjzdm ||'='|| p_rowkey;
        --v_ztmszdm ||'='''|| v_ztmstgz ||''' WHERE '|| v_zjzdm ||'='|| p_rowkey;
    ELSE
      v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztmszdm ||'='''|| v_ztmstgz ||
        ''' WHERE '|| v_zjzdm ||'='|| p_rowkey;
    END IF;
    EXECUTE IMMEDIATE v_sql;
    RETURN SQL%ROWCOUNT<>1;--SQL%NOTFOUND;
  END updateRelativeRecord;
  /**
   * 取消相关表记录
   * @param p_spmxid    审批项目id
   * @param p_rowkey    主键值
   * @param p_ztms      传递的状态描述，用于取消审批
   * @return 返回是否成功
   */
  FUNCTION cancelRelativeRecord(
    p_spmxid   IN INTEGER,
    p_rowkey   IN INTEGER,
    p_ztms     IN VARCHAR2 DEFAULT ''
  ) RETURN BOOLEAN
  IS
    v_dybm    sp_xm.dybm%TYPE;      --对应表名
    v_zjzdm    sp_xm.zjzdm%TYPE;      --主键字段名
    v_ztzdm    sp_xm.ztzdm%TYPE;      --状态字段名
    --v_zttgz   sp_xm.zttgz%TYPE;      --状态通过值
    v_ztbtgz  sp_xm.zttgz%TYPE;     --状态不通过值
    v_ztmszdm sp_xm.ztmszdm%TYPE;   --状态描述字段名
    v_sql VARCHAR2(200);
  BEGIN
    BEGIN
      SELECT x.dybm, x.zjzdm, x.ztzdm, x.ztbtgz, x.ztmszdm
      INTO   v_dybm, v_zjzdm, v_ztzdm, v_ztbtgz, v_ztmszdm
      FROM   sp_xm x
      WHERE  x.spxmid = p_spmxid;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN FALSE;
    END;
    --更新相关记录
    --update v_dybm set v_ztzdm='v_zttgz', v_ztmszdm='不用审批' where v_zjzdm = p_rowkey
    v_sql := 'UPDATE '|| v_dybm ||' SET '|| v_ztzdm ||'='''|| v_ztbtgz ||''','||
        v_ztmszdm ||'='''|| p_ztms ||''' WHERE '|| v_zjzdm ||'='|| p_rowkey;
    EXECUTE IMMEDIATE v_sql;
    RETURN SQL%FOUND;
  END cancelRelativeRecord;
  /**
   * 得到审批项目流程可审批的人员id列表,以逗号分割
   * @param p_spjlid    审批项目id
   * @return 人员id列表
   */
  FUNCTION getApprovePerson(
    p_spjlid   IN NUMBER
  ) RETURN VARCHAR2
  IS
    v_peronid VARCHAR2(300);
    v_deptid bm.deptid%TYPE;
  BEGIN
    SELECT j.deptid INTO v_deptid FROM sp_jl j WHERE j.spjlid = p_spjlid;
    FOR c_person IN (
      SELECT DISTINCT r.personid FROM sp_xmmx x, sp_spr r, --jc_bmqx b,
      (SELECT spxmmxid FROM
        (SELECT m.spxmmxid FROM sp_jlmx m WHERE nvl(m.sftg,0)=0 AND m.spjlid=p_spjlid ORDER BY m.spdj)
       WHERE rownum < 2
      ) m
      WHERE x.spxmmxid = r.spxmmxid AND m.spxmmxid = x.spxmmxid
      --2004.2.28 增加审批人员部门权限(需要部门级权限)
      --2004.4.8  用审批人表中的部门id作为部门审批权限
      --AND  r.personid = b.personid AND b.qxlx=1 AND b.deptid = v_deptid
      AND   r.deptid = v_deptid
    )
    LOOP
      IF(v_peronid IS NULL) THEN
        v_peronid := c_person.personid;
      ELSE
        v_peronid := v_peronid || ',' || c_person.personid;
      END IF;
    END LOOP;
    RETURN v_peronid;
  END getApprovePerson;
  /**
   * 提取审批列表
   * p_data_out   OUT --返回的数据集
   * p_personid   IN  --人员id
   */
  PROCEDURE getApproveList(
    p_data_out   OUT rc,      --返回的数据集
    p_personid   IN NUMBER
  )
  IS
  BEGIN
    OPEN  p_data_out FOR
    SELECT j.spjlid, j.spxmbm, j.spxmmc, j.spnr, j.zjid, j.deptid, j.personid, j.tjsprq
    FROM sp_jl j, sp_spr s, (
       SELECT a.spxmmxid, a.spjlid FROM (
        SELECT m.spxmmxid, m.spjlid, m.spdj,
          (SELECT MIN(t.spdj) FROM sp_jlmx t WHERE (t.sftg IS NULL OR t.sftg=0) AND t.spjlid = m.spjlid) mindj
        FROM sp_jlmx m WHERE m.sftg IS NULL OR m.sftg=0
      ) a WHERE a.spdj = a.mindj
    ) b
    WHERE j.spjlid = b.spjlid AND b.spxmmxid = s.spxmmxid
    --2004。3。2需要部门级权限
    --2004.4.8  用审批人表中的部门id作为部门审批权限
    --AND j.deptid IN (SELECT x.deptid FROM jc_bmqx x WHERE x.qxlx=1 AND x.personid=p_personid)
    AND j.deptid = s.deptid
    AND (j.sfjs IS NULL OR j.sfjs=0) AND s.personid = p_personid;
    --ORDER BY j.spxmbm, j.deptid, j.tjsprq, j.personid;
  END  getApproveList;
  /**
   * 审批项目是否事后审批得
   * @param p_spmxbm    审批项目编码
   * @return 返回是否事后审批得
   */
  FUNCTION isAfterApprove(
    p_spmxbm   IN VARCHAR2
  ) RETURN BOOLEAN
  IS
    v_splx sp_xmlx.splx%TYPE;
  BEGIN
    SELECT nvl(l.splx,0) INTO v_splx
    FROM sp_xm x, sp_xmlx l WHERE x.spxmid = l.spxmid AND x.spxmbm=p_spmxbm;
    RETURN (v_splx=1);
  EXCEPTION
    WHEN no_data_found THEN
      RETURN FALSE;
  END isAfterApprove;
END PCK_APPROVE;
/

prompt
prompt Creating package body PCK_BASE
prompt ==============================
prompt
CREATE OR REPLACE PACKAGE BODY pck_base IS
  -- Private type declarations
  --type <TypeName> is <Datatype>;
  -- Private constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Private variable declarations
  --<VariableName> <Datatype>;
  -- Function and procedure implementations
/*  function <FunctionName>(<Parameter> <Datatype>) return <Datatype> is
    <LocalVariable> <Datatype>;
  begin
    <Statement>;
    return(<Result>);
  end;*/
  /**
   * 提取字段的下一个编码
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_prefix_in    前缀（父结点的编码）
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @param p_addlength_in 递增的长度
   * @param p_isAddPrefix  返回的编码是否含有前缀(1=是,2=否)
   * @return 返回下一个编码的值
   */
  FUNCTION fieldNextCode(
    p_table_in     IN VARCHAR2,
    p_field_in     IN VARCHAR2,
    p_prefix_in    IN VARCHAR2 DEFAULT NULL,
    p_where_in     IN VARCHAR2 DEFAULT NULL,
    p_addlength_in IN INT      DEFAULT 2,
    p_isAddPrefix  IN INT      DEFAULT 1
  ) RETURN VARCHAR2 IS
    v_prefix       VARCHAR2(32) := '';
    v_code         VARCHAR2(32);
    v_format       VARCHAR2(32) := '';
    v_sql          VARCHAR2(300);
    v_prefixLen    INT; --前缀部分的长度
    v_autolen      INT; --自增部分的长度
    v_nextLen      INT; --总长度
    v_count        INT;
  BEGIN
    v_prefix := p_prefix_in;
    v_autolen := p_addlength_in;
    IF(v_prefix IS NULL OR v_prefix = '0') THEN
      v_prefix := '';
      v_prefixLen := 0;
    ELSE
      v_prefixLen := length(v_prefix);
    END IF;
    v_nextLen   := v_prefixLen + v_autolen;
    --组装SQL语句
    v_sql := 'SELECT COUNT(*), MAX('|| p_field_in ||') FROM '|| p_table_in ||
            ' WHERE length('|| p_field_in ||') = '|| v_nextLen;
    IF(v_prefixLen > 0) THEN
      v_sql := v_sql ||' AND SUBSTR('|| p_field_in ||', 1,'|| v_prefixLen ||')='''|| v_prefix ||'''';
    END IF;
    IF(p_where_in IS NOT NULL) THEN
      v_sql := v_sql ||' AND '|| p_where_in;
    END IF;
    --提取最大编码
    EXECUTE IMMEDIATE v_sql INTO v_count, v_code;
    --组装编码
    FOR i IN 1..v_autolen LOOP
      v_format := v_format ||'0';
    END LOOP;
    IF (v_count = 0) THEN
      v_code := TRIM(to_char(1, v_format));
    ELSE
      v_code := substr(v_code, v_prefixLen+1, v_autolen);
      BEGIN
        v_code := TRIM(to_char(to_number(v_code)+1, v_format));
      EXCEPTION
        WHEN OTHERS THEN
          v_code := '';
      END;
    END IF;
    --add prefix code
    IF(p_isAddPrefix = 1) THEN
      v_code := v_prefix || v_code;
    END IF;
    RETURN v_code;
  END fieldNextCode;
  /**
   * 提取单据字段的编码信息
   * @param p_coderule_in     JC_CODERULE的主键
   * @param p_prefix_in    返回的前缀前缀（父结点的编码）
   * @param p_extend_in    表名的扩展名
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @param p_isAddPrefix  返回的编码是否含有前缀(1=是,2=否)
   * @return 返回下一个编码的值
   */
  FUNCTION billNextCode(
    p_coderule_in  IN VARCHAR2,
    p_field_in     IN VARCHAR2 DEFAULT NULL,
    p_extend_in    IN VARCHAR2 DEFAULT NULL,
    p_where_in     IN VARCHAR2 DEFAULT NULL,
    p_isAddPrefix  IN INT      DEFAULT 1
  ) RETURN VARCHAR2 IS
    v_tablecode  jc_coderule.tablecode%TYPE;
    v_fieldCode  jc_coderule.fieldcode%TYPE;
    v_where      jc_coderule.wherecond%TYPE;

    v_codeprefix jc_coderule_cont.codeprefix%TYPE;
    v_dateformat jc_coderule_cont.dateformat%TYPE;
    v_autolen    jc_coderule_cont.autolen%TYPE;
    v_prefix     VARCHAR2(32) := '';
    v_table      VARCHAR2(32) := '';
  BEGIN
    v_table := lower(p_coderule_in);
    IF(p_extend_in IS NOT NULL) THEN
      v_table := v_table || '.' || lower(p_extend_in);
    END IF;
    --提取数据
    SELECT j.tablecode, j.fieldcode, j.wherecond
    INTO   v_tablecode, v_fieldCode, v_where
    FROM   jc_coderule j WHERE j.coderule = v_table;
    --提取数据
    BEGIN
      SELECT c.codeprefix, c.dateformat, c.autolen
      INTO   v_codeprefix, v_dateformat, v_autolen
      FROM   jc_coderule_cont c WHERE c.coderule = v_table;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20000, '还未定义该单据的编码规则');
    END;

    IF (p_field_in IS NOT NULL) THEN
      v_fieldcode := p_field_in;
    END IF;

    IF (p_where_in IS NOT NULL) THEN
      v_where := p_where_in;
    END IF;

    v_prefix := v_codeprefix || to_char(SYSDATE, v_dateformat);
    --返回编码规则
    RETURN fieldNextCode(v_tablecode, v_fieldcode, v_prefix, v_where, v_autolen, p_isAddPrefix);
  END billNextCode;
  /**
   * 更新子结点的编码(在父结点的编码被更改时)
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_oldprefix_in 旧的前缀（旧的父结点的编码）
   * @param p_newprefix_in 新的前缀（新的父结点的编码）
   * @param p_where_in     where子句的字符串（isdelete=0）
   */
  PROCEDURE updateChildCode(
    p_table_in     IN VARCHAR2,
    p_field_in     IN VARCHAR2,
    p_oldprefix_in IN VARCHAR2,
    p_newprefix_in IN VARCHAR2,
    p_where_in     IN VARCHAR2 DEFAULT NULL
  ) IS
    v_sql          VARCHAR2(300);
    v_oldleng      INT;
  BEGIN
    IF(p_oldprefix_in IS NULL) THEN
      RETURN;
    END IF;
    v_oldleng := length(p_oldprefix_in);
    v_sql :=
      'UPDATE '|| p_table_in ||
     ' SET '|| p_field_in ||'='''|| p_newprefix_in ||'''||substr('|| p_field_in ||','|| (v_oldleng+1) ||', length('|| p_field_in ||')-'|| v_oldleng ||') '||
     ' WHERE length('|| p_field_in ||') >'|| v_oldleng ||' AND substr('|| p_field_in ||', 1,'|| v_oldleng ||')='''|| p_oldprefix_in ||'''';
    IF(p_where_in IS NOT NULL) THEN
      v_sql := v_sql ||' AND '|| p_where_in;
    END IF;
    /*组装后的SQL例子
    UPDATE bm SET dm='02'|| substr(dm,3, length(dm)-2)
    WHERE length(dm) >2 AND substr(dm, 1,2)='01' AND isdelete=0
    */
    EXECUTE IMMEDIATE v_sql;
  END updateChildCode;
  /**
   * 判断某一个表的字段的值是否已经存在
   * @param p_table_in     表名
   * @param p_field_in     字段名
   * @param p_value_in     字段值
   * @param p_where_in     where子句的字符串（isdelete=0）
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION fieldCodeCount(
    p_table_in   IN VARCHAR2,
    p_field_in   IN VARCHAR2,
    p_value_in   IN VARCHAR2,
    p_where_in   IN VARCHAR2 DEFAULT NULL
  ) RETURN INT IS
    v_sql          VARCHAR2(300);
    v_count      INT;
  BEGIN
    v_sql := 'SELECT COUNT(*) FROM '|| p_table_in ||' WHERE '|| p_field_in ||' ='''|| p_value_in||'''';
    IF(p_where_in IS NOT NULL) THEN
      v_sql := v_sql ||' AND '|| p_where_in;
    END IF;
    EXECUTE IMMEDIATE v_sql INTO v_count;
    RETURN v_count;
  END fieldCodeCount;
  /**
   * 提取系统参数
   * @param p_paramCode_in     表名
   * @param p_filialeID_in     字段名
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION systemParam(
    p_paramCode_in IN VARCHAR2,
    p_filialeID_in IN INT DEFAULT 0
  ) RETURN VARCHAR2 IS
    v_value VARCHAR2(32);
    v_num   INT;
  BEGIN
    SELECT COUNT(1) INTO v_num
    FROM  systemparam
    WHERE code=p_paramCode_in
    AND (deptid =0 OR deptid = p_filialeID_in);
    --若没有该分公司的参数，则提取默认的参数
    IF(v_num = 1) THEN
      SELECT VALUE INTO v_value FROM systemparam
      WHERE code=p_paramCode_in AND deptid = 0;
    ELSIF (v_num > 1) THEN
      SELECT VALUE INTO v_value FROM systemparam
      WHERE code=p_paramCode_in AND deptid = p_filialeID_in;
    END IF;
    RETURN (v_value);
  END;
  /**
   * 给数字补零
   * @param p_number_in     数字
   * @param p_format_in     格式话
   * @return 存在数量.=0:表示不存在
   */
  FUNCTION fillZero(
    p_number_in    IN VARCHAR2,
    p_format_in    IN VARCHAR2 DEFAULT '000'
  ) RETURN VARCHAR2 IS
    v_value VARCHAR2(32);
    --v_format VARCHAR2(10);
  BEGIN
    --组装编码
    BEGIN
      v_value := TRIM(to_char(to_number(p_number_in), p_format_in));
    EXCEPTION
      WHEN OTHERS THEN
        RETURN p_format_in;
    END;
    RETURN (v_value);
  END;

  /**
   * 格式化数字,只格式化化小数位
   * p_number_in    IN INTEGER,
   * p_format_in    IN VARCHAR2 DEFAULT '#.00'
   * @return 返回格式化后的数字
  */
  FUNCTION formartNumber(
    p_number_in    IN INTEGER,
    p_format_in    IN VARCHAR2 DEFAULT '#.00'
  ) RETURN INTEGER IS
    v_decimalLen  INT;
  BEGIN
    IF(p_format_in = '#.00') THEN
      v_decimalLen := 2;
    ELSE
      v_decimalLen := length(p_format_in) - Instr(p_format_in, '.');
    END IF;
    RETURN round(p_number_in, v_decimallen);
  END formartNumber;

END pck_base;
/

prompt
prompt Creating package body PCK_BUY_REP
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_BUY_REP IS
  /**
   * 应付款明细帐
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(进货单或发票)
   * @param p_provideid_in IN VARCHAR2    供应商id
   * @param p_providetype_in IN VARCHAR2  供应商类型
   * @param p_personid_in IN VARCHAR2   业务员id
   * @param p_jhdcheck_in IN VARCHAR2   进货单是否包括未记帐 1,0
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE buy_receivable_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_provideid_in    IN VARCHAR2,
    p_providetype_in  IN VARCHAR2,
    p_personid_in   IN VARCHAR2,
    p_jhdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --表示进货单
    IF(p_billtype_in = '1') THEN
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT NULL id, (v_start-1) rq, '期初余额' zy, nvl(cshyfk,0)+nvl(xf,0) xf, nvl(yf,0)+nvl(yfk,0) yf, nvl(cshyfk,0)+nvl(xf,0)-nvl(yf,0)-nvl(yfk,0) ye,
               NULL djh, NULL jsfs, NULL ywy, NULL lx
        FROM
        (SELECT
           (SELECT SUM(nvl(yfk,0)) yfk FROM cg_yfk
             WHERE (p_provideid_in IS NULL OR dwtxid = p_provideid_in)
             AND (p_fgsid_in IS NULL OR fgsid = p_fgsid_in)
             AND (p_providetype_in IS NULL OR khlx = p_providetype_in)
            ) cshyfk, --系统初始化应付款
           (SELECT SUM(nvl(t.zje,0)) FROM cg_htjhd t  WHERE t.jhrq < v_start
            AND (p_provideid_in IS NULL OR t.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR t.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
            AND (p_providetype_in IS NULL OR t.khlx = p_providetype_in)
            AND (p_jhdcheck_in = '1' OR t.zt=2) --t.zt = 1 OR t.zt=8)
           ) xf,--期初应付款(小于查询开始日期的和)
           (SELECT SUM(nvl(l.je,0)) FROM cw_cgjs l WHERE l.rq < v_start
            AND (p_provideid_in IS NULL OR l.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR l.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
            AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
            AND (p_jscheck_in = '1' OR l.isrefer=1)
           ) yf, --期初已付款(小于查询开始日期的和)
           (SELECT SUM(nvl(m.ybje,0)) FROM cw_cgyfk m WHERE m.yfrq < v_start
            AND (p_provideid_in IS NULL OR m.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR m.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR m.fgsid = p_fgsid_in)
            --AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
            AND (p_jscheck_in = '1' OR m.isrefer=1)
           ) yfk --期初采购预付款(小于查询开始日期的和)
         FROM dual
        ) a
        --进货单数据
        UNION ALL
        SELECT t.jhdid id, t.jhrq, decode(t.djlx, 1, '采购进货', -1, '采购退货', ''), t.zje, NULL, NULL,
               t.jhdbm,   j.jsfs,  e.xm, t.khlx
        FROM cg_htjhd t, jsfs j, emp e
        WHERE t.jsfsid = j.jsfsid(+) AND t.personid = e.personid(+)
        AND   t.jhrq >= v_start AND t.jhrq <= v_end
        AND (p_provideid_in IS NULL OR t.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR t.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
        AND (p_providetype_in IS NULL OR t.khlx = p_providetype_in)
        AND (p_jhdcheck_in = '1' OR t.zt=2) --t.zt = 1 OR t.zt=8)
        --采购结算数据
        UNION ALL
        SELECT l.cgjsid id, l.rq,   '结算', NULL, l.je, NULL,
               l.djh,   j.jsfs,  e.xm, l.khlx
        FROM cw_cgjs l, jsfs j, emp e
        WHERE l.jsfsid = j.jsfsid(+) AND l.personid = e.personid(+)
        AND   l.rq >= v_start AND l.rq <= v_end
        AND (p_provideid_in IS NULL OR l.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR l.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
        AND (p_jscheck_in = '1' OR l.isrefer=1)
        UNION ALL
        --采购预付款
        SELECT m.cgyfkid id, m.yfrq,   '采购预付款', NULL, m.ybje, NULL,
               m.yfkbh,   j.jsfs,  e.xm, NULL
        FROM cw_cgyfk m, jsfs j, emp e
        WHERE m.jsfsid = j.jsfsid(+) AND m.personid = e.personid(+)
        AND   m.yfrq >= v_start AND m.yfrq <= v_end
        AND (p_provideid_in IS NULL OR m.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR m.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR m.fgsid = p_fgsid_in)
        --AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
        AND (p_jscheck_in = '1' OR m.isrefer=1)
      ) t
      ORDER BY rq;
     ELSE --IF(p_billtype_in = '2') THEN
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT NULL id, (v_start-1) rq, '期初余额' zy, nvl(cshyfk,0)+nvl(xf,0) xf, nvl(yf,0)+nvl(yfk,0) yf, nvl(cshyfk,0)+nvl(xf,0)-nvl(yf,0)-nvl(yfk,0) ye,
               NULL djh, NULL jsfs, NULL ywy, NULL lx
        FROM
        (SELECT
           (SELECT sum(nvl(yfk,0)) yfk FROM cg_yfk
             WHERE (p_provideid_in IS NULL OR dwtxid = p_provideid_in)
             AND (p_fgsid_in IS NULL OR fgsid = p_fgsid_in)
             AND (p_providetype_in IS NULL OR khlx = p_providetype_in)
            ) cshyfk, --系统初始化应付款
           (SELECT SUM(nvl(m.jshj,0)) FROM cw_cgfp f ,cw_cgfpmx m WHERE f.kprq< v_start
            AND f.cgfpid=m.cgfpid
            AND (p_provideid_in IS NULL OR f.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR f.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
            AND (p_jhdcheck_in = '1' OR f.isrefer=1)
           ) xf,
           (SELECT SUM(nvl(l.je,0)) FROM cw_cgjs l WHERE l.rq < v_start
            AND (p_provideid_in IS NULL OR l.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR l.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
            AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
            AND (p_jscheck_in = '1' OR l.isrefer=1)
           ) yf,
           (SELECT SUM(nvl(m.ybje,0)) FROM cw_cgyfk m WHERE m.yfrq < v_start
            AND (p_provideid_in IS NULL OR m.dwtxid = p_provideid_in)
            AND (p_personid_in IS NULL OR m.personid = p_personid_in)
            AND (p_fgsid_in IS NULL OR m.fgsid = p_fgsid_in)
            --AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
            AND (p_jscheck_in = '1' OR m.isrefer=1)
           ) yfk --期初采购预付款(小于查询开始日期的和)
         FROM dual
        ) a
        --发票数据
        UNION ALL
        SELECT f.cgfpid id,f.kprq, '发票', SUM(nvl(M.jshj,0)), NULL, NULL,
               f.fphm,   j.jsfs,  e.xm, NULL lx
        FROM cw_cgfp f, cw_cgfpmx m, jsfs j, emp e
        WHERE f.jsfsid = j.jsfsid(+)
        AND  f.cgfpid=m.cgfpid
        AND f.personid = e.personid(+)
        AND   f.kprq>= v_start AND f.kprq <= v_end
        AND (p_provideid_in IS NULL OR f.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR f.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
        AND (p_jhdcheck_in = '1' OR f.isrefer=1)
        GROUP BY f.cgfpid,f.kprq, f.fphm, j.jsfs, e.xm
        --采购结算数据
        UNION ALL
        SELECT l.cgjsid id,l.rq,  '结算',  NULL, l.je, NULL,
          NULL lx, l.djh,   j.jsfs,  l.khlx
        FROM cw_cgjs l, jsfs j, emp e
        WHERE l.jsfsid = j.jsfsid(+) AND l.personid = e.personid(+)
        AND   l.rq >= v_start AND l.rq <= v_end
        AND (p_provideid_in IS NULL OR l.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR l.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
        AND (p_jscheck_in = '1' OR l.isrefer=1)
        UNION ALL
         --采购预付款
        SELECT m.cgyfkid id, m.yfrq,   '采购预付款', NULL, m.ybje, NULL,
               m.yfkbh,   j.jsfs,  e.xm, NULL
        FROM cw_cgyfk m, jsfs j, emp e
        WHERE m.jsfsid = j.jsfsid(+) AND m.personid = e.personid(+)
        AND   m.yfrq >= v_start AND m.yfrq <= v_end
        AND (p_provideid_in IS NULL OR m.dwtxid = p_provideid_in)
        AND (p_personid_in IS NULL OR m.personid = p_personid_in)
        AND (p_fgsid_in IS NULL OR m.fgsid = p_fgsid_in)
        --AND (p_providetype_in IS NULL OR l.khlx = p_providetype_in)
        AND (p_jscheck_in = '1' OR m.isrefer=1)
      ) t
      ORDER BY rq
      ;
    END IF;
  END buy_receivable_detail;
  /**
   * 采购应付款汇总
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_dqdm_in IN VARCHAR2   地区代码
   * @param p_dwdm_in IN VARCHAR2 单位代码
   * @param p_dwmc_in IN VARCHAR2   单位名称
   * @param p_khlx_in IN VARCHAR2   客户类型
   * @param p_billtype_in IN VARCHAR2  单据类型(进货单或发票)
   * @param p_check_in IN VARCHAR2   进货单是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE buy_balance(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_dqdm_in IN VARCHAR2,
    p_dwdm_in   IN VARCHAR2,
    p_dwmc_in IN VARCHAR2,
    p_khlx_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_check_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_dwmc  VARCHAR2(100);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_dwmc  := '%'||p_dwmc_in||'%';
    --表示进货单
    IF(p_billtype_in = '1') THEN
      OPEN p_data_out FOR
     SELECT dwtxid, dwmc, dwdm, dqdm, khlx, SUM(nvl(qcye,0)) qcye, SUM(nvl(xf,0)) xf, SUM(nvl(yf,0)) yf,
            SUM(nvl(qcye,0)+nvl(qmye,0)) qmye
     FROM
     (
     SELECT  dwtxid, dwmc, dwdm, dqdm ,khlx, NULL qcye, SUM(nvl(xf,0)) xf, SUM(nvl(yf,0)) yf, SUM(nvl(xf,0))-SUM(nvl(yf,0)) qmye
      FROM
      (
      SELECT a.dwtxid dwtxid, b.dwmc dwmc, b.dwdm dwdm, c.areacode dqdm, a.khlx khlx, nvl(a.zje,0) xf, NULL yf
        FROM cg_htjhd a, dwtx b, dwdq c --得到应付
        WHERE a.dwtxid=b.dwtxid AND a.jhrq>=v_start AND a.jhrq<=v_end AND a.fgsid=p_fgsid_in
        AND b.dqh=c.dqh
        AND (p_dqdm_in IS NULL OR c.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR b.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR b.dwmc like v_dwmc)
        AND (p_khlx_in IS NULL OR a.khlx = p_khlx_in)
        AND (p_check_in = '1' OR a.zt=2)
        --GROUP BY dwtxid, dwmc, dwdm, dqdm , khlx
      UNION ALL
      SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, c.khlx, NULL xf, nvl(c.je,0) yf
        FROM cw_cgjs c, dwtx d, dwdq e --得到已付
        WHERE c.dwtxid=d.dwtxid AND c.rq>=v_start AND c.rq<=v_end AND c.fgsid=p_fgsid_in
        AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
        --GROUP BY dwtxid, dwmc, dwdm, dqdm , khlx
       UNION ALL
       SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, NULL, NULL xf, nvl(c.ybje,0) yf
        FROM cw_cgyfk c, dwtx d, dwdq e --得到已付
        WHERE c.dwtxid=d.dwtxid AND c.yfrq>=v_start AND c.yfrq<=v_end AND c.fgsid=p_fgsid_in
        AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        --AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
        --GROUP BY dwtxid, dwmc, dwdm, dqdm , khlx
      ) e
      GROUP BY dwtxid, dwdm, dwmc, dqdm, khlx
    UNION ALL
    SELECT  dwtxid, dwmc, dwdm, dqdm, khlx, SUM(nvl(xf,0))-SUM(nvl(yf,0)) qcye, NULL, NULL, NULL
     FROM --得到期初余额
      (
      SELECT a.dwtxid dwtxid, b.dwmc dwmc, b.dwdm dwdm, c.areacode dqdm, a.khlx khlx, nvl(a.yfk,0) xf, NULL yf
        FROM cg_yfk a, dwtx b, dwdq c
        WHERE a.dwtxid=b.dwtxid--得到采购应付款初始化值
        AND b.dqh=c.dqh
        AND (p_dqdm_in IS NULL OR c.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR b.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR b.dwmc like v_dwmc)
        AND (p_khlx_in IS NULL OR a.khlx = p_khlx_in)
      UNION ALL
      SELECT a.dwtxid dwtxid, b.dwmc dwmc, b.dwdm dwdm, c.areacode dqdm, a.khlx khlx, nvl(a.zje,0) xf, NULL yf
         FROM cg_htjhd a, dwtx b, dwdq c
         WHERE a.dwtxid=b.dwtxid AND  a.jhrq<v_start AND a.fgsid=p_fgsid_in
         AND b.dqh=c.dqh
         AND (p_dqdm_in IS NULL OR c.areacode = p_dqdm_in)
         AND (p_dwdm_in IS NULL OR b.dwdm = p_dwdm_in)
         AND (p_dwmc_in IS NULL OR b.dwmc like v_dwmc)
         AND (p_khlx_in IS NULL OR a.khlx = p_khlx_in)
         AND (p_check_in = '1' OR a.zt=2)
      UNION ALL
      SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, NULL, NULL xf, nvl(c.ybje,0) yf
        FROM cw_cgyfk c, dwtx d, dwdq e
        WHERE c.dwtxid=d.dwtxid AND  c.yfrq<v_start AND c.fgsid=p_fgsid_in
         AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        --AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
      UNION ALL
      SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, c.khlx, NULL xf, nvl(c.je,0) yf
        FROM cw_cgjs c, dwtx d, dwdq e
        WHERE c.dwtxid=d.dwtxid AND  c.rq<v_start AND c.fgsid=p_fgsid_in
         AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
       ) f
       GROUP BY dwtxid, dwdm, dwmc,dqdm, khlx
      ) g
      GROUP BY dwtxid, dwdm, dwmc,dqdm, khlx
      ORDER BY dwdm;
    ELSE --表示为发票
      OPEN p_data_out FOR
      SELECT dwtxid, dwmc, dwdm, dqdm, NULL khlx, SUM(nvl(qcye,0)) qcye, SUM(nvl(xf,0)) xf, SUM(nvl(yf,0)) yf,
             SUM(nvl(qcye,0)+nvl(qmye,0)) qmye
     FROM
     (
     SELECT  dwtxid, dwmc, dwdm,dqdm, NULL qcye, SUM(nvl(xf,0)) xf, SUM(nvl(yf,0)) yf, SUM(nvl(xf,0))-SUM(nvl(yf,0)) qmye
      FROM
      (
      SELECT h.dwtxid dwtxid, k.dwmc dwmc, k.dwdm dwdm, l.areacode dqdm, SUM(nvl(j.jshj,0)) xf, NULL yf
        FROM cw_cgfp h, cw_cgfpmx j, dwtx k, dwdq l --得到应付
        WHERE h.cgfpid=j.cgfpid AND h.dwtxid=k.dwtxid AND h.kprq>=v_start AND h.kprq<=v_end AND h.fgsid=p_fgsid_in
        AND k.dqh=l.dqh
        AND (p_dqdm_in IS NULL OR l.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR k.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR k.dwmc like v_dwmc)
        AND (p_check_in = '1' OR h.isrefer=1)
        GROUP BY h.dwtxid, dwmc, dwdm, l.areacode
      UNION ALL
      SELECT l.dwtxid dwtxid,m.dwmc, m.dwdm, e.areacode dqdm, NULL xf, nvl(l.je,0) yf
        FROM cw_cgjs l, dwtx m, dwdq e  --得到已付
        WHERE l.dwtxid=m.dwtxid AND l.rq>=v_start AND l.rq<=v_end AND l.fgsid=p_fgsid_in
        AND m.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR m.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR m.dwmc like v_dwmc)
        AND (p_check_in = '1' OR l.isrefer=1)
       UNION ALL
       SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, NULL xf, nvl(c.ybje,0) yf
        FROM cw_cgyfk c, dwtx d, dwdq e --得到已付
        WHERE c.dwtxid=d.dwtxid AND c.yfrq>=v_start AND c.yfrq<=v_end AND c.fgsid=p_fgsid_in
        AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        --AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
        --GROUP BY dwtxid, dwmc, dwdm, dqdm , khlx
      ) e
      GROUP BY dwtxid, dwdm, dwmc, dqdm
    UNION ALL
    SELECT  dwtxid, dwmc, dwdm, dqdm, SUM(nvl(xf,0))-SUM(nvl(yf,0)) qcye, NULL, NULL, NULL
     FROM --得到期初余额
      (
      SELECT a.dwtxid dwtxid, b.dwmc dwmc, b.dwdm dwdm, c.areacode dqdm, nvl(a.yfk,0) xf, NULL yf
        FROM cg_yfk a, dwtx b, dwdq c
        WHERE a.dwtxid=b.dwtxid--得到采购应付款初始化值
        AND b.dqh=c.dqh
        AND (p_dqdm_in IS NULL OR c.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR b.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR b.dwmc like v_dwmc)
      UNION ALL
      SELECT h.dwtxid dwtxid, k.dwmc dwmc, k.dwdm dwdm,l.areacode dqdm, SUM(nvl(j.jshj,0)) xf, NULL yf
         FROM cw_cgfp h, cw_cgfpmx j, dwtx k, dwdq l
         WHERE h.cgfpid=j.cgfpid AND h.dwtxid=k.dwtxid AND  h.kprq<v_start AND h.fgsid=p_fgsid_in
         AND k.dqh=l.dqh
        AND (p_dqdm_in IS NULL OR l.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR k.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR k.dwmc like v_dwmc)
        AND (p_check_in = '1' OR h.isrefer=1)
        GROUP BY h.dwtxid, dwmc, dwdm, l.areacode
      UNION ALL
      SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, NULL xf, nvl(c.je,0) yf
        FROM cw_cgjs c, dwtx d, dwdq e
        WHERE c.dwtxid=d.dwtxid AND  c.rq<v_start AND c.fgsid=p_fgsid_in
        AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        AND (p_check_in = '1' OR c.isrefer=1)
      UNION ALL
      SELECT c.dwtxid dwtxid, d.dwmc, d.dwdm, e.areacode dqdm, NULL xf, nvl(c.ybje,0) yf
        FROM cw_cgyfk c, dwtx d, dwdq e
        WHERE c.dwtxid=d.dwtxid AND  c.yfrq<v_start AND c.fgsid=p_fgsid_in
         AND d.dqh=e.dqh
        AND (p_dqdm_in IS NULL OR e.areacode = p_dqdm_in)
        AND (p_dwdm_in IS NULL OR d.dwdm = p_dwdm_in)
        AND (p_dwmc_in IS NULL OR d.dwmc like v_dwmc)
        --AND (p_khlx_in IS NULL OR c.khlx = p_khlx_in)
        AND (p_check_in = '1' OR c.isrefer=1)
       ) f
       GROUP BY dwtxid, dwdm, dwmc, dqdm
      ) g
      GROUP BY dwtxid, dwdm, dwmc, dqdm
      ORDER BY dwdm;
  END IF;
  END buy_balance;
 ----------------------------------------------------------------
END PCK_BUY_REP;
/

prompt
prompt Creating package body PCK_COMPILE
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY pck_compile IS
  -- Private type declarations
  --type <TypeName> is <Datatype>;
  -- Private constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Private variable declarations
  --<VariableName> <Datatype>;
  -- Function and procedure implementations
/*  function <FunctionName>(<Parameter> <Datatype>) return <Datatype> is
    <LocalVariable> <Datatype>;
  begin
    <Statement>;
    return(<Result>);
  end;*/
  /*创建job
  begin
    sys.dbms_job.submit(job => :job,
                        what => 'pck_compile.CompileInvalid();
  insert into test(txt) values(to_char(SYSDATE, ''YYYY-MM-DD hh24:mi:ss''));',
                        next_date => to_date('20-11-2003 16:51:56', 'dd-mm-yyyy hh24:mi:ss'),
                        interval => 'sysdate+1/360');
    commit;
  end;
  /
  --初始化参数 job_queue_process=n  job_queue_interval=N
*/
  /**
   * 编译不可用对象
   */
  PROCEDURE CompileInvalid
  IS
    v_error VARCHAR2(128);
  BEGIN
    v_error := CompileInvalid(0, 0);
    v_error := CompileInvalid(0, 0);
  END CompileInvalid;
  /**
   * 编译不可用对象
   * @param p_level     递归调用级数
   * @param p_objectid  数据库对象
   * @return 出错信息
   */
  FUNCTION CompileInvalid(
    p_level    IN INTEGER DEFAULT 0,
    p_objectid IN INTEGER DEFAULT 0
  ) RETURN VARCHAR2
  IS
    v_temp  VARCHAR2(128);
    v_error VARCHAR2(128);
    --v_sql   VARCHAR2(128);
  BEGIN
    IF(p_level > 8) THEN
      RETURN NULL;
    END IF;
    --第一次调用函数
    IF(p_objectid <= 0) THEN
      FOR c_obj IN (
        SELECT obj.object_type, obj.object_name, obj.object_id
        FROM   all_objects obj
        WHERE  obj.status = 'INVALID'
      )
      LOOP
        v_temp := CompileInvalid(p_level+1, c_obj.object_id);
        --处理错误
        IF(v_error IS NULL AND v_temp IS NOT NULL) THEN
          v_error := v_temp;
        END IF;
        --执行编译
        --v_sql := 'ALTER '|| c_obj.object_type ||' '|| c_obj.object_name ||' COMPILE';
        BEGIN
          CompileObject(c_obj.object_type, c_obj.object_name);
        EXCEPTION
          WHEN OTHERS THEN
            v_error := 'compile '|| c_obj.object_type ||' '|| c_obj.object_name ||' error';
        END;
      END LOOP;
      RETURN v_error;
    --递归进去，编译依赖关系的程序
    ELSE
      FOR c_obj IN (
        SELECT obj.object_type, obj.object_name, obj.object_id
        FROM   all_objects obj, public_dependency pd
        WHERE  pd.referenced_object_id = obj.object_id
        AND    obj.status = 'INVALID'
        AND    pd.object_id = p_objectid
      )
      LOOP
        v_temp := CompileInvalid(p_level+1, c_obj.object_id);
        --处理错误
        IF(v_error IS NULL AND v_temp IS NOT NULL) THEN
          v_error := v_temp;
        END IF;
        --执行编译
        --v_sql := 'ALTER '|| c_obj.object_type ||' '|| c_obj.object_name ||' COMPILE';
        BEGIN
          CompileObject(c_obj.object_type, c_obj.object_name);
        EXCEPTION
          WHEN OTHERS THEN
            v_error := 'compile '|| c_obj.object_type ||' '|| c_obj.object_name ||' error';
        END;
      END LOOP;
      RETURN v_error;
    END IF;
  END CompileInvalid;
  /**
   * 编译对象
   * @param p_object_type  对象类型
   * @param p_object_name  对象名称
   * @return 出错信息
   */
  PROCEDURE CompileObject(
    p_object_type IN VARCHAR2,
    p_object_name IN VARCHAR2
  )
  IS
  BEGIN
    IF(p_object_type = 'PACKAGE BODY') THEN
      EXECUTE IMMEDIATE 'ALTER PACKAGE '|| p_object_name ||' COMPILE';
      --EXECUTE IMMEDIATE 'a.*, (a.pm ||'' ''||a.gg) product FROM kc_dm a';
    --ELSIF (p_object_type = 'VIEW' AND p_object_name = 'VW_KC_DM_EXIST') THEN
    ELSE
      EXECUTE IMMEDIATE 'ALTER '|| p_object_type ||' '|| p_object_name ||' COMPILE';
    END IF;
  /*EXCEPTION
    WHEN OTHERS THEN
      NULL;*/
  END CompileObject;
  /**
   * 添加字段
   * @param p_table_in  表名
   * @param p_column_in  字段名称
   * @param p_type_in  字段类型 1=字符型,2=文本型,3=枚举型,4=数值型
   * @param p_leng_in  字段长度
   * @param p_precision_in  精度
   * @param p_isAdd  是:添加字段,否:修改字段
   */
  PROCEDURE tableColumn(
    p_table_in     IN VARCHAR2,
    p_column_in    IN VARCHAR2,
    p_type_in      IN INT,
    p_leng_in      IN INT,
    p_precision_in IN INT DEFAULT 0,
    p_isAdd        IN INT DEFAULT 1
  ) IS
    v_sql VARCHAR2(300);
  BEGIN
    IF(p_type_in < 1 OR p_type_in > 4) THEN
      RETURN;
    END IF;
    v_sql := 'ALTER TABLE '|| p_table_in;
    IF(p_isAdd = 1) THEN
      v_sql := v_sql || ' ADD ' || p_column_in;
    ELSE
      v_sql := v_sql || ' MODIFY ' || p_column_in;
    END IF;
    IF(p_type_in = 1 OR p_type_in =2 OR p_type_in =3) THEN
      v_sql := v_sql || ' VARCHAR(' || p_leng_in || ')';
    ELSIF(p_type_in = 4) THEN
      v_sql := v_sql || ' NUMBER(' || p_leng_in;
      IF(p_precision_in IS NOT NULL AND p_precision_in > 0 AND p_precision_in < p_leng_in) THEN
        v_sql := v_sql || ',' || p_precision_in;
      END IF;
      v_sql := v_sql || ')';
    END IF;
    EXECUTE IMMEDIATE v_sql;
    --编译对象
  END tableColumn;
  /**
   * 删除表字段
   * @param p_table_in  表名
   * @param p_column_in  字段名称
   */
  PROCEDURE dropTableColumn(
    p_table_in     IN VARCHAR2,
    p_column_in    IN VARCHAR2
  ) IS
    v_sql VARCHAR2(300);
  BEGIN
    v_sql := 'UPDATE '|| p_table_in || ' SET ' || p_column_in || '=NULL';
    EXECUTE IMMEDIATE v_sql;
    v_sql := 'ALTER TABLE '|| p_table_in || ' DROP COLUMN ' || p_column_in;
    EXECUTE IMMEDIATE v_sql;
    --编译对象
  END dropTableColumn;
END pck_compile;
/

prompt
prompt Creating package body PCK_LOGIN
prompt ===============================
prompt
create or replace package body pck_login is
  -- Private type declarations
  --type <TypeName> is <Datatype>;
  -- Private constant declarations
  --<ConstantName> constant <Datatype> := <Value>;
  -- Private variable declarations
  --<VariableName> <Datatype>;
  -- Function and procedure implementations
/*  function <FunctionName>(<Parameter> <Datatype>) return <Datatype> is
    <LocalVariable> <Datatype>;
  begin
    <Statement>;
    return(<Result>);
  end;*/
  --提取菜单的数据
  PROCEDURE getMenuData(
    p_data_out   OUT rc,       --返回的数据集
    p_userid_in  IN  VARCHAR2, --用户ID
    p_sysType_in IN  VARCHAR2  --系统类型
  ) is
  BEGIN
    IF(p_userid_in = '0' or p_userid_in = '-1') THEN
      OPEN p_data_out FOR
      SELECT n.nodeid, n.nodecode, n.parentnodeid, n.nodename, n.url, n.isexecute
      FROM   nodeinfo n
      WHERE  n.isdelete = 0;
      /*
    ELSIF(p_userid_in = '-1') THEN
      OPEN p_data_out FOR
      SELECT n.nodeid, n.nodecode, n.parentnodeid, n.nodename, n.url, n.isexecute
      FROM   nodeinfo n
      WHERE  n.isdelete = 0;
      */
    ELSE
      OPEN p_data_out FOR
      --提取可用的不可执行的结点数据.nodetype=9表示超级用户的菜单
      --isexecute=0表示菜单标题
      SELECT n.nodeid, n.nodecode, n.parentnodeid, n.nodename, n.url, n.isexecute
      FROM   nodeinfo n
      WHERE  n.nodetype <> 9 AND n.isexecute = 0 AND n.isdelete = 0
      AND   (SELECT COUNT(*) FROM VW_USER_LIMITS l
             WHERE l.personid = p_userid_in
             AND   substr(l.nodecode, 1, length(n.nodecode))= n.nodecode
            ) >0
      UNION
      --isexecute=1表示菜单项目
      SELECT DISTINCT
             l.nodeid, l.nodecode, l.parentnodeid, l.nodename, l.url, 0 isexecute
      FROM   VW_USER_LIMITS l
      WHERE  l.nodetype <> 9 AND l.personid = p_userid_in;
    END IF;
  END  getMenuData;
  PROCEDURE getMenuData_new(
    p_data_out   OUT rc,       --返回的数据集
    p_userid_in  IN  VARCHAR2, --用户ID
    p_sysType_in IN  VARCHAR2  --系统类型
  ) is
  BEGIN
    IF(p_userid_in = '0' or p_userid_in = '-1') THEN
      OPEN p_data_out FOR
      SELECT n.nodeid, n.nodecode, n.parentnodeid, n.nodename, n.url, n.isexecute
      FROM   nodeinfo n
      WHERE  n.isdelete = 0 and n.isjit=1;
    ELSE
      OPEN p_data_out FOR
      --提取可用的不可执行的结点数据.nodetype=9表示超级用户的菜单
      --isexecute=0表示菜单标题
      SELECT n.nodeid, n.nodecode, n.parentnodeid, n.nodename, n.url, n.isexecute
      FROM   nodeinfo n
      WHERE  n.nodetype <> 9 AND n.isexecute = 0 AND n.isdelete = 0 and n.isjit=1
      AND   (SELECT COUNT(*) FROM VW_USER_LIMITS_NEW l
             WHERE l.personid = p_userid_in
             AND   substr(l.nodecode, 1, length(n.nodecode))= n.nodecode
            ) >0
      UNION
      --isexecute=1表示菜单项目
      SELECT DISTINCT
             l.nodeid, l.nodecode, l.parentnodeid, l.nodename, l.url, 0 isexecute
      FROM   VW_USER_LIMITS_NEW l
      WHERE  l.nodetype <> 9 AND l.personid = p_userid_in;
    END IF;
  END  getMenuData_new;
  /**
  *
  --根据入参取得该人员所具有的角色
  *
  **/
  PROCEDURE getRoleData(
    cursorData  OUT  rc, --返回的数据集
    p_userId_in VARCHAR2
  ) IS
  BEGIN
    OPEN cursorData FOR
      SELECT DISTINCT b.roleid, b.rolename
      FROM   personlimits a, roleInfo b
      WHERE a.roleid = b.roleid AND a.personid = p_userId_in;
  END getRoleData;
  --提取用户信息
  PROCEDURE getUserInfo(
    p_data_out OUT rc, --返回的数据集
    p_user_in  IN  VARCHAR2, --用户名
    p_pass_in  IN  VARCHAR2  --密码
  ) is
  BEGIN
    OPEN p_data_out FOR
      SELECT a.personid,    a.bm AS personcode, a.xm AS personname,
             b.deptid,      b.dm AS deptno,     b.mc AS deptname,
             0 AS firstdeptid, '0' AS firstdeptno, '0' AS firstdeptname,
             b.ismember,    a.gh AS workno
      FROM   emp a, bm b
      WHERE  a.deptid = b.deptid
      AND    lower(a.username) = lower(p_user_in)
      AND    ((p_pass_in IS NOT NULL AND a.userpass = p_pass_in)
               OR (p_pass_in IS NULL AND a.userpass IS NULL))
      AND    ((a.Isdelete = 0 AND a.isuse = 1 AND b.isdelete=0) OR a.personid=0 OR a.personid=-1)
      AND    rownum < 2;
  END getUserInfo;
  --提取用户的角色用例权限信息
  PROCEDURE getUserLimits(
    p_data_out     OUT rc,  --返回的数据集
    p_userid_in    IN INT, --用户序号
    p_url_in       IN VARCHAR2, --网页URL
    p_limitCode_in IN VARCHAR2 --权限编号
  ) is
  begin
    OPEN p_data_out FOR
      --用户的角色用例权限信息
      SELECT l.intercode AS nodecode, l.priviligecode, 1 nodetype
      FROM   VW_USER_LIMITS l
      WHERE  l.personid = p_userid_in
      --AND    e.personid = l.personid;
      --提取审批权限
      UNION ALL
      SELECT DISTINCT a.spxmbm, '', 0
      FROM   sp_xm a, sp_xmmx b, sp_spr c
      WHERE  a.spxmid = b.spxmid AND  b.spxmmxid = c.spxmmxid
      AND    c.personid = p_userid_in;
  END getUserLimits;
  --用户更改密码
  PROCEDURE changepass(
    p_userid_in  VARCHAR2, --行序号
    p_newpass_in VARCHAR2 --新密码
  ) IS
  BEGIN
    IF(p_newpass_in IS NOT NULL) THEN
      UPDATE emp e
      SET    e.userpass = p_newpass_in
      WHERE  e.personid = p_userid_in;
    ELSE
      UPDATE emp e
      SET    e.userpass = NULL
      WHERE  e.personid = p_userid_in;
    END IF;
  END changepass;
  --记录操作日志。记录内容为 操作员序号(登录用户)、操作时间(系统时间)、客户端ip、url、操作描述
  PROCEDURE writeLog(
    p_userid_in VARCHAR2,  --操作员序号
    p_ip_in     VARCHAR2,  --客户端ip
    p_url_in    VARCHAR2,  --url
    p_option_in VARCHAR2   --操作描述
  ) IS
  BEGIN
    IF (p_userid_in IS NOT NULL) THEN
      INSERT INTO jc_rz(rzid, personid, czrq, ip, url, czms)
      VALUES (s_jc_rz.NEXTVAL, p_userid_in, SYSDATE, p_ip_in, p_url_in, p_option_in);
    END IF;
  END writeLog;
  /**
   * 提取所有的分公司信息
   * @param p_data_out  出参 返回的数据集
   */
  PROCEDURE getFilialesInfo(
    p_data_out  OUT  rc  --返回的数据集
  ) IS
  BEGIN
    OPEN p_data_out FOR
      SELECT b.deptid, b.dm deptcode, b.mc deptname
      FROM   bm b
      WHERE  b.parentdeptid = 0;
  END getFilialesInfo;

  --提取菜单的数据
  PROCEDURE checkMenuData(
    p_data_out   OUT rc,       --返回的数据集
    p_personid_in  IN  VARCHAR2,--传入personid
    p_nodeid_in    IN  VARCHAR2--传入nodeid
  ) IS
  BEGIN
    OPEN p_data_out FOR
    select t.* from
   (
   select t.nodeid,t.parentnodeid,t.nodename,t.url,t.nodecode,1 you
   from nodeinfo t where t.isdelete=0
   and t.nodeid in (
   select distinct t.nodeid from limitlist t ,personlimits a where  t.limitid=a.limitid and a.personid=p_personid_in
   )
   union all
   select t.nodeid,t.parentnodeid,t.nodename,t.url,t.nodecode ,0 you
   from nodeinfo t where t.isdelete=0 and p_personid_in<>'0' and t.nodeid not in (select distinct t.nodeid from limitlist t ,personlimits a
   where  t.limitid=a.limitid and a.personid=p_personid_in)
   union all
   select t.nodeid,t.parentnodeid,t.nodename,t.url,t.nodecode,1 you
   from nodeinfo t where t.isdelete=0 and p_personid_in='0'
   ) t
   --where t.parentnodeid = p_nodeid_in
   order by t.nodecode;
  END checkMenuData;
  PROCEDURE getOtherUserInfo(
    p_data_out OUT rc, --返回的数据集
    p_dwdm_in  IN  VARCHAR2, --单位代码    
    p_user_in  IN  VARCHAR2, --用户名
    p_pass_in  IN  VARCHAR2  --密码
  )is
  BEGIN
    OPEN p_data_out FOR
      SELECT a.dwdm,a.dwtxid,a.dwmc,a.deptid,a.types
             ,b.xm,b.lxrid,b.loginPassword,b.loginName
      FROM   dwtx a, dwtx_lxr b
      WHERE  a.dwtxid = b.dwtxid
      AND    lower(b.loginName) = lower(p_user_in)
      AND    ((p_pass_in IS NOT NULL AND b.loginPassword = p_pass_in)
               OR (p_pass_in IS NULL AND b.loginPassword IS NULL)) 
      ;
  END getOtherUserInfo; 
 END pck_login;
/

prompt
prompt Creating package body PCK_PERSON_REP
prompt ====================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_PERSON_REP IS
  /**
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_deptid_in IN INTEGER,     --部门编号
   * @param P_bm_in IN VARCHAR2,       --职工编码
   * @param P_xm_in IN VARCHAR2        --员工姓名
   */
  PROCEDURE rl_change_person(
    p_data_out   OUT rc,    --返回的数据集
    p_deptid_in IN INTEGER,     --部门编号
    P_bm_in IN VARCHAR2,       --职工编码
    P_bdlx_in IN INTEGER,       --变动类型
    P_xm_in IN VARCHAR2        --员工姓名
  )
  IS
  BEGIN
  --P_bdlx_in = 1 职工离职情况.不须要再去其它表中为 变动前/后ID或属性取关联资料
  IF  ( p_bdlx_in = 1 ) THEN
      OPEN p_data_out FOR
      SELECT  a.*, c.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              d.mc, b.bdqID,     --变动前id或属性.当是离职的时候此id里面写的应该不是id号而是一句描述的话.下同
              b.bdhid      --变动后id或属性
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d
        WHERE a.personid = b.personid    --员工表中的个人id与变动明细中的personid关联
        AND (p_bm_in IS NULL OR a.bm = p_bm_in )  --职工编码为空时情况
              AND b.zgxxid = c.zgxxid  --主动主及明细表变动信息id关联
              AND ( p_deptid_in IS NULL OR a.deptid = p_deptid_in )  --部门参数如为空的情况
              AND c.bdlx = P_bdlx_in    --变动类型输入参数条件
              AND a.deptid = d.deptid   --部门及员工表的用部门关联
              AND c.bdlx = 1 --表示离职
              AND ( p_xm_in IS NULL OR a.xm = p_xm_in )           --姓名输入为空时的情况
        ORDER BY a.personid;
  --P_bdlx_in = 2 部门调动.去bm表中为变动前/后ID或属性取关联资料
  ELSIF ( p_bdlx_in = 2 ) THEN
      OPEN p_data_out FOR
      SELECT  a.*, c.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              e.mc AS bdqid, --变动前id或属性.
              f.mc AS bdhid      --变动后id或属性
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d,
          (SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,bm c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdqid=to_char(c.deptid)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) e,--此表中根据变动前id取出相应的部门名称
           (
            SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,bm c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdhid=to_char(c.deptid)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) f    ----此表中根据变动后id取出相应的部门名称
        WHERE a.personid = b.personid
              AND (p_bm_in IS NULL OR a.bm = p_bm_in )
              AND b.zgxxid = c.zgxxid
              AND ( p_deptid_in IS NULL OR a.deptid = p_deptid_in )
              AND c.bdlx = p_bdlx_in
              AND a.deptid = d.deptid
              AND c.bdlx = 2 --表示部门调动
              AND ( p_xm_in IS NULL OR a.xm = p_xm_in )
              AND e.xxbdmxid = b.xxbdmxid
              AND f.xxbdmxid = b.xxbdmxid
        ORDER BY a.personid;
   --p_bdlx_in = 3 OR p_bdlx_in = 4  '类别变动',4, '职务变迁'
   --这两类转换全总去员工辅助信息 (rl_ygfzxx)去取
  ELSIF  ( p_bdlx_in = 3 OR p_bdlx_in = 4 ) THEN
      OPEN p_data_out FOR
      SELECT  a.*, c.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              f.mc AS bdqid, --变动前id或属性.
              g.mc AS bdhid      --变动后id或属性
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d,
          rl_ygfzxx e,
          (SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,rl_ygfzxx c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdqid=to_char(c.ygfzxxID)
                  AND ( a.bdlx='3' OR a.bdlx = 4 ) AND b.personid=d.personid
                  AND d.personid = d.personid
           ) f,--此表中根据变动前id取出
           --1职务 2人员类别 3学历 4民族 5籍贯 6职称 7政治面貌其中之一的名称
           (
            SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,rl_ygfzxx c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdhid=to_char(c.ygfzxxID)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) g    --此表中根据变动后id取出
           --1职务 2人员类别 3学历 4民族 5籍贯 6职称 7政治面貌其中之一的名称
        WHERE a.personid = b.personid
              AND (p_bm_in IS NULL OR a.bm = p_bm_in )
              AND b.zgxxid = c.zgxxid
              AND ( p_deptid_in IS NULL OR a.deptid = p_deptid_in )
              AND c.bdlx = p_bdlx_in
              AND a.deptid = d.deptid
              AND ( c.bdlx = 3  OR c.bdlx = 4) --表示3=类别变动,4=职务变迁
              AND ( p_xm_in IS NULL OR a.xm = p_xm_in )
              AND f.xxbdmxid = b.xxbdmxid
              AND g.xxbdmxid = b.xxbdmxid
        ORDER BY a.personid;
       --p_bdlx_in = 5 表示职员复职
  ELSIF ( p_bdlx_in = 5 ) THEN
      OPEN p_data_out FOR
      SELECT  a.*, c.bdyy, --变动原因,
              c.zgxxid, --信息变动ID
              c.bdrq, --变动日期
              DEcode
              (c.bdlx, 1, '职工离职',2, '部门调动',3, '类别变动',4, '职务变迁', 5, '职员复职'
              ) AS bdlx, --变动类型
              DEcode
              (c.zt, 0, '未审核',NULL, '未审核',1, '审核',2, '已入库',9, '已完成') AS zt,  --状态
              b.bdqid,
              e.mc AS bdhid      --变动后id或属性
        FROM
          emp a, rl_zgxxbdmx b, --职工信息变动明细
          rl_zgxxbd c, --职工信息变动
          bm d,
          (SELECT c.mc, b.xxbdmxid
            FROM  rl_zgxxbd a,rl_zgxxbdmx b,bm c,emp d
            WHERE a.zgxxid=b.zgxxid AND b.bdhid=to_char(c.deptid)
                  AND a.bdlx='2' AND b.personid=d.personid
           ) e--此表中根据变动后id取出相应的部门名称
        WHERE a.personid = b.personid
              AND (p_bm_in IS NULL OR a.bm = p_bm_in )
              AND b.zgxxid = c.zgxxid
              AND ( p_deptid_in IS NULL OR a.deptid = p_deptid_in )
              AND c.bdlx = p_bdlx_in
              AND a.deptid = d.deptid
              AND c.bdlx = 5 --表示部门调动
              AND ( p_xm_in IS NULL OR a.xm = p_xm_in )
              AND e.xxbdmxid = b.xxbdmxid
        ORDER BY a.personid;
  END IF;
 END rl_change_person;
 ----------------------------------------------------------------
END PCK_PERSON_REP;
/

prompt
prompt Creating package body PCK_PRODUCE
prompt =================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_PRODUCE IS
  /**
   * 提取BOM表的数据(BOM表模块)
   * p_data_out   OUT rc,      --返回的数据集
   * p_parentid   IN  INT      --父节点ID
   */
  PROCEDURE getBomTreeData(
    p_data_out   OUT rc,       --返回的数据集
    p_parentid   IN INT       --p_isself=1:父节点ID. p_isself=0:当前节点ID.
  )
  IS
  BEGIN
    IF(p_parentid <= 0) THEN
      OPEN p_data_out FOR
      SELECT t.*, (b.cpbm||' '||b.pm||' '||b.gg) mc
      FROM
      (
        SELECT a.cpid, 0 sjcpid, COUNT(c.cpid) childcount
        FROM   (SELECT DISTINCT sjcpid AS cpid FROM sc_bom) a, sc_bom c
        WHERE a.cpid = c.sjcpid(+)
        GROUP BY a.cpid
      ) t, vw_kc_dm_exist b
      WHERE t.cpid = b.cpid
      ORDER BY b.cpbm;
    ELSE
      OPEN p_data_out FOR
      SELECT t.*, (b.cpbm||' '||b.pm||' '||b.gg) mc
      FROM
      (
        SELECT a.cpid, a.sjcpid, COUNT(c.cpid) childcount
        FROM sc_bom a, sc_bom c
        WHERE a.cpid = c.sjcpid(+) AND a.sjcpid = p_parentid
        --AND ((p_isself <=0 AND a.sjcpid = p_parentid) OR (p_isself >0 AND a.cpid = p_parentid))
        GROUP BY a.cpid, a.sjcpid
      ) t, vw_kc_dm_exist b
      WHERE t.cpid = b.cpid
      ORDER BY b.cpbm;
    END IF;
  END  getBomTreeData;
  /**
   * 提取复制配料的数据(BOM表模块)
   * @param p_data_out   OUT rc,      --返回的数据集
   * @param p_copyid   IN  INT        --复制节点ID
   * @param p_pasteid  IN  INT        --粘贴节点ID
   */
  PROCEDURE getBomCopyData(
    p_data_out   OUT rc,       --返回的数据集
    p_copyid     IN INT,
    p_pasteid    IN INT
  )
  IS
  BEGIN
    OPEN p_data_out FOR
    SELECT a.bomid, a.cpid, a.sjcpid, a.sl, a.shl, a.zjlx, a.xgr, a.wgcl, a.cpbm
    FROM
    (
      SELECT t.*, pck_produce.isBomFatherNode(p_pasteid,0,t.cpid) isfather
      FROM vw_sc_bom t
      WHERE t.cpid NOT IN (SELECT v.cpid FROM vw_sc_bom v WHERE v.sjcpid = p_pasteid)
      AND   t.cpid <> p_pasteid AND t.sjcpid = p_copyid
    ) a
    WHERE a.isfather = 0;
  END getBomCopyData;
  /**
   * 提取BOM节点显示的名称(BOM表模块)
   * @param  p_cpid   IN  INT      --产品ID
   */
  FUNCTION getBomNodeCaption(
    p_cpid IN INT
  ) RETURN VARCHAR2 IS
    v_caption VARCHAR2(256);
  BEGIN
    SELECT b.cpbm||' '||b.pm||' '||b.gg INTO v_caption
    FROM vw_kc_dm b
    WHERE b.cpid = p_cpid;
    RETURN v_caption;
  EXCEPTION
    WHEN OTHERS THEN
      RETURN '';
  END getBomNodeCaption;
  /**
   * 提取客户BOM节点的各个父节点id(客户BOM表模块)
   * @param p_dwtxid IN  INTEGER      --单位ID
   * @param p_hthwid IN  INT      --合同货物ID
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_fatherpath  IN  VARCHAR2  --父节点路径
   */
  FUNCTION getCustBomNodePath(
    p_dwtxid IN INTEGER,
    p_hthwid IN INTEGER,
    p_cpid   IN INTEGER,
    p_level  IN INT DEFAULT 0,
    p_fatherpath IN VARCHAR2 DEFAULT ''
  ) RETURN VARCHAR2 IS
    --v_sjcpid sc_bom.sjcpid%TYPE;
    v_path VARCHAR2(512);
  BEGIN
    IF(p_level > 20) THEN
      RETURN p_fatherpath;
    END IF;
    v_path := p_fatherpath;
    FOR c_bom IN (
      SELECT a.sjcpid
      FROM sc_khbom a, kc_dm b
      WHERE a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
      AND a.cpid = p_cpid AND a.hthwid = p_hthwid AND a.dwtxid = p_dwtxid
    )
    LOOP
      IF(v_path IS NULL) THEN
        v_path := c_bom.sjcpid;
      ELSE
        v_path := v_path || ',' || c_bom.sjcpid;
      END IF;
      v_path := getCustBomNodePath(p_dwtxid, p_hthwid, c_bom.sjcpid, p_level+1, v_path);
    END LOOP;
    RETURN v_path;
  END getCustBomNodePath;
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   */
  FUNCTION getBomChildNodePath(
    p_cpid  IN INT
  ) RETURN VARCHAR2 IS
    v_path VARCHAR2(1024);
  BEGIN
    procBomChildNodePath(p_cpid, 0, v_path);
    RETURN v_path;
  END getBomChildNodePath;
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_childspath IN OUT VARCHAR2  --所有子节点路径
   */
  PROCEDURE procBomChildNodePath(
    p_cpid  IN INT,
    p_level IN INT,
    p_childspath IN OUT VARCHAR2
  ) IS
  BEGIN
    IF(p_level > 20) THEN
      RETURN;
    END IF;
    FOR c_bom IN (
      SELECT a.cpid
      FROM sc_bom a, kc_dm b
      WHERE a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
      AND a.sjcpid = p_cpid
    )
    LOOP
      IF(p_childspath IS NULL) THEN
        p_childspath := c_bom.cpid;
      ELSE
        p_childspath := p_childspath || ',' || c_bom.cpid;
      END IF;
      procBomChildNodePath(c_bom.cpid, p_level+1, p_childspath);
    END LOOP;
  END procBomChildNodePath;
  /**
   * 提取BOM节点的各个父节点id(BOM表模块)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_fatherpath  IN  VARCHAR2  --父节点路径
   */
  FUNCTION getBomNodePath(
    p_cpid  IN INT,
    p_level IN INT DEFAULT 0,
    p_fatherpath IN VARCHAR2 DEFAULT ''
  ) RETURN VARCHAR2 IS
    --v_sjcpid sc_bom.sjcpid%TYPE;
    v_path VARCHAR2(512);
  BEGIN
    IF(p_level > 20) THEN
      RETURN p_fatherpath;
    END IF;
    v_path := p_fatherpath;
    FOR c_bom IN (
      SELECT a.sjcpid
      FROM sc_bom a, kc_dm b
      WHERE a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
      AND a.cpid = p_cpid
    )
    LOOP
      IF(v_path IS NULL) THEN
        v_path := c_bom.sjcpid;
      ELSE
        v_path := v_path || ',' || c_bom.sjcpid;
      END IF;
      v_path := getBomNodePath(c_bom.sjcpid, p_level+1, v_path);
    END LOOP;
    RETURN v_path;
  END getBomNodePath;
  /**
   * 判断p_otherid是否是p_cpid的父节点(BOM表模块，BOM表成批替换)
   * @param p_cpid   IN  INT      --产品ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   * @param p_otherid  IN  VARCHAR2  --父节点ID
   */
  FUNCTION isBomFatherNode(
    p_cpid  IN INT,
    p_level IN INT,
    p_otherid IN INT
  ) RETURN INT IS
  BEGIN
    IF(p_level > 20) THEN
      RETURN 0;
    END IF;
    FOR c_bom IN (
      SELECT a.sjcpid
      FROM sc_bom a, kc_dm b
      WHERE a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
      AND a.cpid = p_cpid
    )
    LOOP
      IF(c_bom.sjcpid = p_otherid)THEN
        RETURN 1;
      ELSIF(isBomFatherNode(c_bom.sjcpid, p_level+1, p_otherid) = 1) THEN
        RETURN 1;
      END IF;
    END LOOP;
    RETURN 0;
  END isBomFatherNode;
  /**
   * 更新父物资的提前期
   * @param p_childid   IN  INT      --子节点ID
   * @param p_level  IN  INT      --层次（最大递归数量20）
   */
  PROCEDURE updateBomProduceTime(
    p_childid  IN INT,
    p_level    IN INT DEFAULT 0
  ) IS
    v_tqq      kc_dm.tqq%TYPE;   --当前节点的生产期
    v_childtqq kc_dm.ztqq%TYPE; --子节点的最大提前期
    v_currtqq  kc_dm.ztqq%TYPE;  --当前节点的提前期
  BEGIN
    IF(p_level > 20) THEN
      RETURN;
    END IF;
    --得到当前bom结点最大子节点的提前期
    SELECT nvl(MAX(nvl(b.ztqq,0)),0) INTO v_childtqq
    FROM   sc_bom a, kc_dm b
    WHERE  a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
    AND    a.sjcpid = p_childid;
    --提取当前节点的生产期,当前节点的原提前期
    BEGIN
      SELECT nvl(b.tqq,0), nvl(b.ztqq, 0)
      INTO   v_tqq, v_currtqq
      FROM   kc_dm b
      WHERE  b.cpid = p_childid;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;
    --更新当前bom节点的总提前期
    IF(v_currtqq = (v_childtqq + v_tqq)) THEN
      RETURN;
    END IF;
    UPDATE kc_dm b SET b.ztqq = v_childtqq + v_tqq
    WHERE  b.cpid = p_childid;
    --递归更新bom父节点的总提前期
    FOR c_bom IN (
      SELECT a.sjcpid
      FROM   sc_bom a, kc_dm b
      WHERE  a.cpid = b.cpid AND nvl(b.isdelete, 0) = 0
      AND    a.cpid = p_childid
    )
    LOOP
      updateBomProduceTime(c_bom.sjcpid, p_level+1);
    END LOOP;
  END updateBomProduceTime;
  /**
   * 提取物料需求计划明细的数据(MRP表模块)
   * p_data_out   OUT rc,      --返回的数据集
   * p_scjhid   IN  INTEGER     --生产计划id
   */
  PROCEDURE getMRPdata(
    p_data_out   OUT rc,       --返回的数据集
    p_scjhid     IN INTEGER     --生产计划id
  ) IS
  BEGIN
    /*--清空临时表数据。一般情况调用完过程以后会自动删除临时数据
    LOCK TABLE sc_wlxqlsb IN SHARE MODE;
    DELETE FROM sc_wlxqlsb;
    --提取生产计划明细
    FOR c_jh IN (
      SELECT d.scjhmxid, d.cpid, d.gylxid, nvl(d.sl,0) xql, k.chxz,
        nvl(d.ksrq, trunc(SYSDATE)) ksrq,
        (SELECT h.htid FROM xs_hthw h WHERE d.hthwid = h.hthwid) htid
      FROM sc_jhmx d, kc_dm k
      WHERE d.cpid = k.cpid AND d.scjhid = p_scjhid
    )
    LOOP
      --插入产品数据（层次0表示产成品）
      INSERT INTO sc_wlxqlsb(scjhmxid, htid, cpid, gylxid, xql, chxz, cc)
      VALUES (c_jh.scjhmxid, c_jh.htid, c_jh.cpid, c_jh.gylxid, c_jh.xql, c_jh.chxz, 0);
      --生成产成品的配料
      buildMRPdata(c_jh.scjhmxid, c_jh.htid, c_jh.cpid, c_jh.xql, c_jh.ksrq, 1);
    END LOOP;
    --返回临时数据
    OPEN p_data_out FOR
    SELECT * FROM
    (
      SELECT l.scjhmxid, l.htid, l.cpid, l.gylxid, l.xql, l.xqrq, l.chxz, l.cc
      FROM   sc_wlxqlsb l WHERE l.cc = 0
      UNION ALL
      SELECT l.scjhmxid, l.htid, l.cpid, l.gylxid, SUM(l.xql), l.xqrq, l.chxz, l.cc
      FROM   sc_wlxqlsb l WHERE l.cc > 0
      GROUP BY l.scjhmxid, l.htid, l.cpid, l.gylxid, l.xqrq, l.chxz, l.cc
    ) t
    ORDER BY cc;*/
    OPEN p_data_out FOR
    SELECT * FROM
    (
      SELECT d.scjhmxid, (SELECT h.htid FROM xs_hthw h WHERE d.hthwid = h.hthwid) htid,
        d.cpid, d.dmsxid, d.gylxid,
        nvl(d.scsl,0) xql, nvl(d.sl,0) jlxql, NULL xqrq, k.chxz, 0 cc
      FROM sc_jhmx d, kc_dm k
      WHERE d.cpid = k.cpid AND d.scjhid = p_scjhid
      UNION ALL
      SELECT NULL scjhmxid, l.htid, l.cpid, l.dmsxid,
        (SELECT g.gylxid FROM sc_gylx g WHERE g.cpid = l.cpid AND ROWNUM < 2) gylxid,
        SUM(l.scxql), SUM(l.xql), MIN(l.xqrq), k.chxz, MAX(l.cc)
      FROM   sc_sjbom l, sc_jhmx d, kc_dm k
      --不提取o层的数据
      WHERE  l.cc > 0 AND l.scjhmxid = d.scjhmxid AND l.cpid=k.cpid AND d.scjhid = p_scjhid
      GROUP BY l.htid, l.cpid, l.dmsxid, k.chxz
      /*
      SELECT l.scjhmxid, l.htid, l.cpid, l.dmsxid,
        (SELECT g.gylxid FROM sc_gylx g WHERE g.cpid = l.cpid AND ROWNUM < 2) gylxid,
        SUM(l.xql), l.xqrq, l.chxz, l.cc
      FROM   sc_sjbom l, sc_jhmx d
      WHERE  l.scjhmxid = d.scjhmxid AND d.scjhid = 543
      GROUP BY l.scjhmxid, l.htid, l.cpid, l.dmsxid, l.xqrq, l.chxz, l.cc*/
    ) t
    ORDER BY cc;
  END getMRPdata;
  /**
   * 生产计划明细实际BOM数据(生产计划模块)
   * p_scjhmxid IN  INTEGER     --生产计划明细id
   * p_xshthwid IN  VARCHAR2   --销售合同货物ID
   * p_cpid     IN  INTEGER     --产品ID
   * p_xql      IN  INTEGER     --需求量
   * p_ksrq     IN  VARCHAR2   --总开始日期
   * p_count    IN  INT        --与该计划明细处于同一计划的该计划明细总记录数量
   */
  PROCEDURE buildFactBOMdata(
    p_scjhmxid   IN INTEGER,
    p_xshthwid   IN VARCHAR2,
    p_cpid       IN INTEGER,
    p_dmsxid     IN VARCHAR2,
    p_xql        IN INTEGER,
    p_ksrq       IN VARCHAR2,
    p_count      IN INT
  ) IS
    v_ksrq DATE;
    v_xshtid  xs_hthw.htid%TYPE;
    v_sjbomid sc_sjbom.sjbomid%TYPE;
    v_scjhid  sc_jh.scjhid%TYPE;
    v_jhlx    sc_jh.jhlx%TYPE :=0;
    v_count INT;
  BEGIN
    IF(p_ksrq IS NULL) THEN
      v_ksrq := trunc(SYSDATE);
    ELSE
      v_ksrq := to_date(p_ksrq,'YYYY-MM-DD');
    END IF;
    --
    IF(p_xshthwid IS NOT NULL) THEN
      SELECT h.htid INTO v_xshtid FROM xs_hthw h WHERE h.hthwid = p_xshthwid;
    END IF;
    SELECT m.scjhid INTO v_scjhid FROM sc_jhmx m WHERE m.scjhmxid= p_scjhmxid;
    --是否是分切计划
    SELECT COUNT(*) INTO v_count FROM sc_fqjhwl l, sc_jh j
    WHERE l.sfjs=0 AND j.jhlx=1 AND l.scjhid = j.scjhid AND l.scjhid= v_scjhid;
    IF(v_count > 0)THEN
      --清空临时表数据。一般情况调用完过程以后会自动删除临时数据
      --创建基本bom列表
      LOCK TABLE sc_khbomlsb IN SHARE MODE;
      DELETE FROM sc_khbomlsb l;
      buildBaseBomData(p_cpid, 0);
      --
      FOR c_wl IN (
        SELECT w.dmsxid, w.cpid, nvl(w.sl,0) sl, nvl(w.scsl, 0) scsl
        FROM sc_fqjhwl w WHERE w.scjhid = v_scjhid
      )
      LOOP
        INSERT INTO sc_fqjhwlbom(scjhid, cpid, dmsxid, sl, scsl)
        VALUES (v_scjhid, c_wl.cpid, c_wl.dmsxid, c_wl.sl, c_wl.scsl);
        --
        insertDispartCutBOMdata(v_scjhid, c_wl.cpid, c_wl.dmsxid, c_wl.sl, c_wl.scsl, 0);
      END LOOP;
      UPDATE sc_fqjhwl l SET l.sfjs = 1 WHERE l.scjhid = v_scjhid;
    END IF;
    --SELECT COUNT(j.scjhmxid) FROM sc_jhmx j, sc_jhmx j2
    --WHERE j.scjhid = j2.scjhid AND j2.scjhmxid = p_scjhmxid;
    --先删除已经存在的数据，再插入数据
    DELETE FROM sc_sjbom s WHERE s.scjhmxid = p_scjhmxid;
    --插入0层数据
    SELECT s_sc_sjbom.NEXTVAL INTO v_sjbomid FROM dual;
    INSERT INTO sc_sjbom(
      sjbomid,   scjhmxid,  dmsxid,  cpid, sjsjbomid,   htid,     sl,
      xql,   xqrq, chxz,     cc,    zjlx, sjcpid)
    VALUES (
      v_sjbomid, p_scjhmxid, p_dmsxid, p_cpid, NULL,    v_xshtid, 1,
      p_xql, v_ksrq, 1/*自制件*/, 0, 1/*=普通件*/, NULL);
    insertFactBOMdata(p_scjhmxid, v_xshtid, p_cpid, v_sjbomid, p_xql, v_ksrq, 1, p_count);
  END buildFactBOMdata;
  /**
   * 分切物料BOM的数据
   * p_scjhid   in  INTEGER,    --生产计划id
   * p_cpid     IN  INTEGER     --下级产品ID
   * p_dmsxid   IN  INTEGER     --下级规格属性ID
   * p_jlsl     IN  INTEGER     --计量数量
   * p_scsl     IN  INTEGER     --生产数量
   * p_level    IN  INTEGER     --层次数
   */
  PROCEDURE insertDispartCutBOMdata(
    p_scjhid     IN INTEGER,
    p_cpid       IN INTEGER,
    p_dmsxid     IN INTEGER,
    p_jlsl       IN INTEGER,
    p_scsl       IN INTEGER,
    p_level      IN INT
  ) IS
    v_sjcpid   sc_bom.cpid%TYPE;
    v_zjsl     sc_bom.sl%TYPE;
    v_jlsl     sc_fqjhwlbom.sl%TYPE;
    v_scsl     sc_fqjhwlbom.scsl%TYPE;
    v_dmsxid   kc_dmsx.dmsxid%TYPE;
    v_sxz      kc_dmsx.sxz%TYPE;
    v_isdelete kc_dmsx.isdelete%TYPE;
  BEGIN
    IF(p_level > 20) THEN
      Raise_application_error(-20000, 'bom表的级数太多了');
    END IF;
    BEGIN
      SELECT b.cpid, nvl(a.sl,0) sl INTO v_sjcpid, v_zjsl
      FROM sc_khbomlsb a, sc_khbomlsb b
      WHERE a.sjcpid=b.cpid AND a.zjlx=6 AND a.cpid=p_cpid; --zjlx=6,表示主配料
      --
      IF(v_sjcpid = p_cpid)THEN
        RETURN;
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        RETURN;
    END;
    --得到规格属性ID
    IF(p_dmsxid IS NOT NULL) THEN
      SELECT k.sxz INTO v_sxz FROM kc_dmsx k WHERE k.dmsxid = p_dmsxid;
      BEGIN
        SELECT k.dmsxid, k.isdelete INTO v_dmsxid, v_isdelete
        FROM kc_dmsx k  WHERE k.sxz=v_sxz AND k.cpid=v_sjcpid;
        IF(v_isdelete = 1) THEN
          UPDATE kc_dmsx k SET k.isdelete=0 WHERE k.dmsxid=v_dmsxid;
        END IF;
      EXCEPTION
        WHEN no_data_found THEN
          SELECT s_kc_dmlbsx.NEXTVAL INTO v_dmsxid FROM dual;
          INSERT INTO kc_dmsx(dmsxid, cpid, sxz, isdelete)
          VALUES(v_dmsxid, v_sjcpid, v_sxz, 0);
      END;
    END IF;
    IF(v_zjsl = 0)THEN
      v_jlsl :=0;
      v_scsl :=0;
    ELSE
      v_jlsl := p_jlsl/v_zjsl;
      v_scsl := p_scsl/v_zjsl;
    END IF;
    INSERT INTO sc_fqjhwlbom(scjhid, cpid, dmsxid, sl, scsl)
    VALUES (p_scjhid, v_sjcpid, v_dmsxid, v_jlsl, v_scsl);
    insertDispartCutBOMdata(p_scjhid, v_sjcpid, v_dmsxid, v_jlsl, v_scsl, p_level+1);
  END insertDispartCutBOMdata;
  /**
   * 生成物料需求计划明细的数据(MRP表模块)
   * p_scjhmxid   OUT rc,      --生产计划明细id
   * p_xshtid   IN  INTEGER     --销售合同ID
   * p_cpid     IN  INTEGER     --上级产品ID
   * p_sjbomid  IN  INTEGER     --上级实际BOMID
   * p_xql      IN  INTEGER     --需求量
   * p_ksrq     IN  DATE       --总开始日期
   * p_level    IN  INTEGER     --层次数
   * p_count    IN  INT        --与该计划明细处于同一计划的该计划明细总记录数量
   */
  PROCEDURE insertFactBOMdata(
    p_scjhmxid   IN INTEGER,
    p_xshtid     IN INTEGER,  --销售合同id
    p_cpid       IN INTEGER,
    p_sjbomid    IN INTEGER,
    p_xql        IN INTEGER,
    p_ksrq       IN DATE,
    p_level      IN INT,
    p_count      IN INT
  ) IS
    v_hasDispart BOOLEAN; --是否是物料分切计划信息
    v_sjbomid sc_sjbom.sjbomid%TYPE;
  BEGIN
    IF(p_level > 20) THEN
      Raise_application_error(-20000, 'bom表的级数太多了');
    END IF;
    --
    FOR c_wl IN (
      SELECT d.cpid, d.sl, (p_xql*nvl(d.sl,0)) xql, nvl(k.ztqq, 0) ztqq, k.chxz, d.zjlx
      FROM sc_bom d, vw_kc_dm_exist k
      WHERE d.cpid = k.cpid AND d.sjcpid = p_cpid
    )
    LOOP
      v_hasDispart := FALSE;
      --可能存在多条计划明细对应多条分切计划物料信息。
      --所有各个物料信息需要平均分配给各条计划明细
      --得到分切计划的原料
      FOR c_yl IN (
        SELECT t.cpid, t.dmsxid, decode(p_count, 0, 0, nvl(t.sl,0)/p_count) jlsl, --计量单位数量
               decode(p_count, 0, 0, nvl(t.scsl,0)/p_count) scsl --生产单位数量
        FROM  sc_fqjhwlbom t, sc_jhmx j
        WHERE t.scjhid = j.scjhid AND j.scjhmxid = p_scjhmxid
        AND   t.cpid = c_wl.cpid
      )
      LOOP
        v_hasDispart := TRUE;
        SELECT s_sc_sjbom.NEXTVAL INTO v_sjbomid FROM dual;
        --通常情况，需求量=子件数量*计划明细的数量。分切则直接等于原料的数量
        INSERT INTO sc_sjbom(sjbomid, scjhmxid, dmsxid,      cpid, sjsjbomid,   htid,     sl,--子件数量
          xql,       scxql/*生产需求量*/,    xqrq, chxz,      cc,      zjlx,    sjcpid)
        VALUES (v_sjbomid, p_scjhmxid, c_yl.dmsxid, c_wl.cpid,   p_sjbomid,   p_xshtid, c_wl.sl,
          c_yl.jlsl, c_yl.scsl,  p_ksrq+c_wl.ztqq, c_wl.chxz, p_level, c_wl.zjlx, p_cpid);
      END LOOP;
      --
      IF(v_hasDispart = FALSE) THEN
        SELECT s_sc_sjbom.NEXTVAL INTO v_sjbomid FROM dual;
        INSERT INTO sc_sjbom(sjbomid, scjhmxid, dmsxid, cpid, sjsjbomid,   htid,     sl,
          xql, xqrq, chxz, cc, zjlx, sjcpid)
        VALUES (v_sjbomid, p_scjhmxid, NULL, c_wl.cpid, p_sjbomid,p_xshtid, c_wl.sl,
          c_wl.xql, p_ksrq+c_wl.ztqq, c_wl.chxz, p_level, c_wl.zjlx, p_cpid);
      END IF;
      /*
      INSERT INTO sc_wlxqlsb(scjhmxid, htid, cpid, gylxid, xql,
        xqrq, chxz, cc)
      VALUES(p_scjhmxid, p_xshtid, c_wl.cpid, c_wl.gylxid, c_wl.xql,
        p_ksrq+c_wl.ztqq, c_wl.chxz, p_level);
      --
      */
      insertFactBOMdata(p_scjhmxid, p_xshtid, c_wl.cpid, v_sjbomid, c_wl.xql, p_ksrq, p_level+1, p_count);
    END LOOP;
  END insertFactBOMdata;
  /**
   * 提取基本BOM数据(制定客户BOM模块)
   * p_data_out   OUT rc,      --返回的数据集
   * p_sjcpid   IN  INTEGER     --上级物资id
   */
  PROCEDURE getBaseBomData(
    p_data_out   OUT rc,       --返回的数据集
    p_sjcpid     IN INTEGER     --上级物资id
  ) IS
  BEGIN
    --清空临时表数据。一般情况调用完过程以后会自动删除临时数据
    LOCK TABLE sc_khbomlsb IN SHARE MODE;
    DELETE FROM sc_khbomlsb l;
    --
    buildBaseBomData(p_sjcpid, 0);
    --返回临时数据
    OPEN p_data_out FOR
    SELECT t.sjcpid, t.cpid, t.sl, t.shl, t.zjlx FROM sc_khbomlsb t;
  END getBaseBomData;
  /**
   * 生成基本BOM数据(制定客户BOM模块)
   * p_sjcpid   IN  INTEGER     --上级物资id
   * p_level    IN  INTEGER     --递归层次数
   */
  PROCEDURE buildBaseBomData(
    p_sjcpid     IN INTEGER,     --上级物资id
    p_level      IN INT     --
  ) IS
  BEGIN
    IF(p_level > 20) THEN
      Raise_application_error(-20000, 'bom表的级数太多了');
    END IF;
    --
    FOR c_wl IN (
      SELECT d.cpid, d.sl, d.shl, d.zjlx
      FROM vw_sc_bom d, vw_kc_dm_exist k
      WHERE d.cpid = k.cpid AND d.sjcpid = p_sjcpid
    )
    LOOP
      INSERT INTO sc_khbomlsb(sjcpid, cpid, sl, shl, zjlx)
      VALUES(p_sjcpid, c_wl.cpid, c_wl.sl, c_wl.shl, c_wl.zjlx);
      --
      buildBaseBomData(c_wl.cpid, p_level+1);
    END LOOP;
  END buildBaseBomData;
  /**
   * 生产计划回填销售合同的计划量
   * p_scjhmxid IN INTEGER     --生产计划明细id
   * p_xshthwid IN  INTEGER    --销售合同货物ID
   * p_add_sl_in  IN INTEGER   --增加或减少的计划量
   */
  PROCEDURE updateSaleOrderPlanNum(
    p_scjhmxid   IN INTEGER,
    p_xshthwid   IN INTEGER,
    p_add_sl_in  IN NUMBER
  ) IS
    v_xsht  xs_ht.htid%TYPE;
    v_zt    xs_ht.zt%TYPE;
    v_count INT;
  BEGIN
    IF(p_add_sl_in = 0)THEN
      RETURN;
    END IF;
    BEGIN
      SELECT h.htid INTO v_xsht
      FROM xs_hthw h WHERE h.hthwid = p_xshthwid;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;
    UPDATE xs_hthw h SET h.yjhsl = nvl(h.yjhsl,0) + p_add_sl_in
    WHERE  h.hthwid = p_xshthwid;
    SELECT COUNT(*) INTO v_count
    FROM xs_hthw h WHERE nvl(h.sl,0)<>nvl(h.yjhsl,0) AND h.htid = v_xsht;
    SELECT m.zt INTO v_zt
    FROM xs_ht m WHERE m.htid = v_xsht;
    /*
    SELECT COUNT(*), m.zt INTO v_count, v_zt
    FROM xs_hthw h, xs_ht m
    WHERE h.htid = m.htid AND nvl(h.sl,0)<>nvl(h.yjhsl,0)
    AND m.htid = v_xsht
    GROUP BY m.zt;
    */
    IF(v_zt<>2 OR v_zt<>3) THEN
      RETURN;
    END IF;
    --2:计划未完全
    IF(v_count > 0 AND v_zt<>2) THEN
      UPDATE xs_ht m SET m.zt=2 WHERE m.htid = v_xsht;
    --3:计划完全
    ELSIF(v_count = 0 AND v_zt<>3) THEN
      UPDATE xs_ht m SET m.zt=3 WHERE m.htid = v_xsht;
    END IF;
  END updateSaleOrderPlanNum;
  /**
   * 生产加工单回填生产任务单已排任务量
   * p_rwdmxid_in IN INTEGER   --生产任务单明细id
   * p_add_sl_in  IN INTEGER   --增加或减少的加工量
   * p_add_scsl_in  IN INTEGER   --增加或减少的加工单的生产数量
   */
  PROCEDURE updateProduceTaskNum(
    p_rwdmxid_in IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_scsl_in IN NUMBER
  ) IS
  BEGIN
    IF(p_add_sl_in = 0)THEN
      RETURN;
    END IF;
    UPDATE sc_rwdmx h
    SET h.yjgl=nvl(h.yjgl,0) + p_add_sl_in,
        h.yjgscl=nvl(h.yjgscl,0) + p_add_scsl_in
    WHERE  h.rwdmxid = p_rwdmxid_in;
  END updateProduceTaskNum;
  /**
   * 工人工作量回填生产加工单已排任务量
   * p_jgdmxid_in IN INTEGER   --生产加工单明细id
   * p_gx_in      IN VARCHAR  --工序名称
   * p_add_sl_in  IN INTEGER   --增加或减少的加工量
   */
  PROCEDURE updateProduceProcessNum(
    p_jgdmxid_in IN INTEGER,
    p_gx_in      IN VARCHAR,
    p_add_sl_in  IN NUMBER
  ) IS
  BEGIN
    IF(p_add_sl_in = 0)THEN
      RETURN;
    END IF;
    UPDATE sc_jgdmxgzl h SET h.ypgzl = nvl(h.ypgzl,0) + p_add_sl_in
    WHERE  h.jgdmxid = p_jgdmxid_in AND h.gx = p_gx_in;
    --没有数据，则插入数据
    IF (SQL%NOTFOUND) THEN
      INSERT INTO sc_jgdmxgzl(jgdmxid, gx, ypgzl)
      VALUES(p_jgdmxid_in, p_gx_in, p_add_sl_in);
    END IF;
  END updateProduceProcessNum;
  /**
   * 生产任务单回填物料需求计划的已排任务量,生产计划已完成量
   * p_wlxqjhmxid_in IN INTEGER   --物料需求计划明细id
   * p_add_sl_in  IN INTEGER      --增加或减少的加工量
   * p_add_scsl_in  IN INTEGER      --增加或减少的加工的生产数量
   * @return 返回生产计划id
   */
  PROCEDURE updatePlanOverNum(
    p_wlxqjhmxid_in IN INTEGER,
    p_add_sl_in     IN INTEGER,
    p_add_scsl_in   IN NUMBER
  ) IS
    v_scjhid   sc_jhmx.scjhid%TYPE;
    v_scjhmxid sc_jhmx.scjhmxid%TYPE;
  BEGIN
    IF(p_add_sl_in = 0)THEN
      RETURN;
    END IF;
    --回填物料需求计划的已排任务量
    UPDATE sc_wlxqjhmx a
    SET a.yprwl = nvl(a.yprwl,0)+p_add_sl_in,
        a.yprwcsl = nvl(a.yprwcsl,0)+p_add_scsl_in
    WHERE a.wlxqjhmxid = p_wlxqjhmxid_in;
    --得到生产计划id
    BEGIN
      SELECT b.scjhmxid, b.scjhid INTO v_scjhmxid, v_scjhid
      FROM   sc_jhmx b, sc_wlxqjhmx a
      WHERE  a.cc=0 AND a.scjhmxid = b.scjhmxid AND a.wlxqjhmxid = p_wlxqjhmxid_in;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;
    --更新已经完成量
    UPDATE sc_jhmx h SET h.ywcl = nvl(h.ywcl,0) + p_add_sl_in
    WHERE  h.scjhmxid = v_scjhmxid;
    /*更新状态
    UPDATE sc_jh j SET j.zt=8
    WHERE (SELECT COUNT(*) FROM sc_jhmx b WHERE nvl(b.sl,0)>nvl(b.ywcl,0) AND b.scjhid=v_scjhid)=0
    AND    j.scjhid = v_scjhid;*/
  END updatePlanOverNum;
  /**
   * 更新物料需求计划明细的已购量和申请单的合同数量（sc_wlxqjhmx)
   * @param  p_cgsqdhwid_in  --采购申请单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实提数量或换算数量
   * @param  p_ishssl_in   --采购的单位是否用换算单位 pck_base.systemparam('BUY_PRICLE_METHOD', p_fgsid_in) = '1'
   */
  PROCEDURE updateMRPBuyNum(
    p_cgsqdhwid_in IN INTEGER,
    p_cpid_in      IN INTEGER,
    p_add_sl_in    IN INTEGER,
    p_ishssl_in    IN BOOLEAN
  ) IS
    v_hsbl kc_dm.hsbl%TYPE;
  BEGIN
    --更新申请单的合同数量
    UPDATE cg_sqdhw t SET t.skhtl = nvl(t.skhtl,0)+p_add_sl_in
    WHERE  t.cgsqdhwid = p_cgsqdhwid_in;
    --更新物料需求计划明细的已购量(根据采购报价方法)  1,申请单数量以换算单位报价
    IF(p_ishssl_in) THEN
      SELECT nvl(k.hsbl,0) INTO v_hsbl FROM kc_dm k WHERE k.cpid = p_cpid_in;
      IF(v_hsbl = 0) THEN
        v_hsbl := 1;
      END IF;
      --
      UPDATE sc_wlxqjhmx h
      SET h.ygl = nvl(h.ygl,0) + p_add_sl_in * v_hsbl
      WHERE h.wlxqjhmxid = (SELECT t.wlxqjhmxid FROM cg_sqdhw t WHERE t.cgsqdhwid = p_cgsqdhwid_in);
    ELSE
      UPDATE sc_wlxqjhmx h
      SET h.ygl = nvl(h.ygl,0) + p_add_sl_in
      WHERE h.wlxqjhmxid = (SELECT t.wlxqjhmxid FROM cg_sqdhw t WHERE t.cgsqdhwid = p_cgsqdhwid_in);
    END IF;
  END updateMRPBuyNum;
 ----------------------------------------------------------------
END PCK_PRODUCE;
/

prompt
prompt Creating package body PCK_SALE_REP
prompt ==================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_SALE_REP IS
  /**
   * 应收帐款明细表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)  djxz  1=提单&2=发票
   * @param p_areacode_in IN VARCHAR2    地区号  areacode
   * @param p_custid_in IN VARCHAR2    客户id   dwtxid
   * @param p_custtype_in IN VARCHAR2  客户类型  khlx
   * @param p_salerid_in IN VARCHAR2   业务员id  personid
   * @param p_tdcheck_in IN VARCHAR2   提单是否包括未记帐 1,0  1=是&0=否
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0  1=是&0=否
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_areacode_in    IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_custtype_in  IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_tdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --表示提货单
    IF(p_billtype_in = '1') THEN
      OPEN p_data_out FOR
      --按提单计算
      SELECT * FROM
      (
      --得期初余额
        SELECT NULL id,NULL areacode,NULL dwdm,NULL dwmc, (v_start-1) rq,  '期初余额' zy,
               NULL jf, NULL df, nvl(jf,0)+nvl(ysk,0)-nvl(df,0) ye, NULL lx, NULL djh, NULL jsfs, NULL ywy,NULL khlx
        FROM
        (
        SELECT
           (
            SELECT SUM(nvl(b.jje,0))
            FROM xs_td t,dwtx w,dwdq q,xs_tdhw b
            WHERE t.dwtxid=w.dwtxid AND t.tdid=b.tdid
            AND w.dqh=q.dqh
            AND t.tdrq < v_start
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custid_in IS NULL OR t.dwtxid = p_custid_in)
            AND (p_salerid_in IS NULL OR t.personid = p_salerid_in)
            AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
            AND (p_custtype_in IS NULL OR t.khlx = p_custtype_in)
            AND ((p_tdcheck_in = '1' AND t.zt IN(2,8))  OR (p_tdcheck_in = '0' AND t.zt=8))--2004-5-13 初始化提单不计入应收款
            AND t.isinit=0
           ) jf,
           (
            SELECT SUM(nvl(l.je,0))
            FROM cw_xsjs l,dwtx w,dwdq q
            WHERE l.dwtxid=w.dwtxid
            AND w.dqh=q.dqh
            AND l.rq < v_start
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
            AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
            AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
            AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
            AND (p_jscheck_in = '1' OR l.zt IN(1,8))
           ) df,
           (
            SELECT SUM(nvl(x.ysk,0))ysk
            FROM xs_ysk x,dwtx w,dwdq q
            WHERE  x.dwtxid=w.dwtxid
            AND w.dqh=q.dqh
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custid_in IS NULL OR x.dwtxid = p_custid_in)
            AND (p_fgsid_in IS NULL OR x.fgsid = p_fgsid_in)
            AND (p_custtype_in IS NULL OR x.khlx = p_custtype_in)
            AND (p_salerid_in IS NULL OR x.personid = p_salerid_in)
           ) ysk
         FROM dual
        ) a
        --提单数据
        UNION ALL
        SELECT  t.tdid id,q.areacode,f.dwdm, f.dwmc, t.tdrq,  decode(t.djlx, 1, '销货', -1, '销退', '') zy,
               sum(nvl(b.jje,0)) jf, NULL df, NULL, NULL lx, t.tdbh,   j.jsfs,  e.xm,t.khlx --zy 摘要
        FROM xs_td t, jsfs j, emp e,dwtx f,dwdq q,xs_tdhw b
        WHERE t.jsfsid = j.jsfsid AND t.tdid=b.tdid
        AND f.dqh=q.dqh
        AND t.personid = e.personid
        AND t.dwtxid=f.dwtxid
        AND   t.tdrq >= v_start
        AND t.tdrq <= v_end
        AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
        AND (p_custid_in IS NULL OR t.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR t.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
        AND (p_custtype_in IS NULL OR t.khlx = p_custtype_in)
        AND ((p_tdcheck_in = '1' AND t.zt IN(2,8))  OR (p_tdcheck_in = '0' AND t.zt =8))--2004-5-13 初始化提单不计入应收款
        AND t.isinit=0
        GROUP BY t.tdid ,q.areacode,f.dwdm, f.dwmc, t.tdrq,t.tdbh,   j.jsfs,  e.xm,t.khlx,t.djlx
        --销售结算数据
        UNION ALL
        SELECT l.xsjsid id,q.areacode,f.dwdm,f.dwmc, l.rq,    '结算' zy, NULL jf, l.je df, NULL,
          NULL lx, l.djh,   j.jsfs,  e.xm,l.khlx
        FROM cw_xsjs l, jsfs j, emp e,dwtx f,dwdq q
        WHERE l.jsfsid = j.jsfsid
        AND l.personid = e.personid
        AND l.dwtxid=f.dwtxid
        AND   l.rq >= v_start AND l.rq <= v_end
        AND f.dqh=q.dqh
        AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
        AND ((p_jscheck_in = '1' AND l.zt IN (0,1,9,8)) OR (p_jscheck_in = '0' AND l.zt IN (1,8)))--1=全部&0=已审+完成
      ) t
      ORDER BY rq;
      --按发票计算
     ELSE --IF(p_billtype_in = '2') THEN
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT NULL id, NULL areacode,NULL dwdm,NULL dwmc, (v_start-1) rq,  '期初余额' zy, NULL jf, NULL df, nvl(jf,0)+nvl(ce,0)-nvl(df,0) ye,
          NULL lx, NULL djh, NULL jsfs, NULL ywy,NULL khlx
        FROM
        (SELECT
           (
            SELECT SUM(nvl(m.jshj,0))
            FROM cw_xsfp f ,cw_xsfpmx m,dwtx w,dwdq q---------------
            WHERE f.kprq< v_start
            AND f.xsfpid=m.xsfpid
            AND f.dwtxid=w.dwtxid
            AND w.dqh=q.dqh
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custid_in IS NULL OR f.dwtxid = p_custid_in)
            AND (p_salerid_in IS NULL OR f.personid = p_salerid_in)
            AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
            AND (p_tdcheck_in = '1' OR f.zt = 1)
           ) jf,
           (
            SELECT SUM(nvl(l.je,0))
            FROM cw_xsjs l, dwtx w,dwdq q
            WHERE l.rq < v_start
            AND l.dwtxid=w.dwtxid
            AND w.dqh=q.dqh
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
            AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
            AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
            AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
            AND (p_jscheck_in = '1' OR l.zt IN (1,8))
           ) df,
           (
            SELECT sum(nvl(ysk,0))
            FROM xs_ysk k,dwtx w,dwdq q
            WHERE  (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
            AND k.dwtxid=w.dwtxid
            AND w.dqh=q.dqh
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_custtype_in IS NULL OR k.khlx = p_custtype_in)
            AND (p_fgsid_in IS NULL OR k.fgsid = p_fgsid_in)
            AND (p_salerid_in IS NULL OR k.personid = p_salerid_in)
           ) ce--应收款
         FROM dual
        ) a
        --发票数据
        UNION ALL
        SELECT f.xsfpid id,q.areacode,h.dwdm,h.dwmc, f.kprq,  '结算' zy, (nvl(m.jshj,0))zje, NULL, NULL,
          NULL lx, f.fphm,   j.jsfs,  e.xm,NULL khlx
        FROM cw_xsfp f,cw_xsfpmx m, jsfs j, emp e,dwtx h,dwdq q
        WHERE f.jsfsid = j.jsfsid
        AND  f.xsfpid=m.xsfpid
        AND f.dwtxid=h.dwtxid
        AND h.dqh=q.dqh
        AND f.personid = e.personid
        AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
        AND   f.kprq>= v_start AND f.kprq <= v_end
        AND (p_custid_in IS NULL OR f.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR f.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
        AND (p_tdcheck_in = '1' OR f.zt = 1)
        --销售结算数据
        UNION ALL
        SELECT l.xsjsid id, q.areacode,h.dwdm,h.dwmc, l.rq,    '结算' zy,  NULL, l.je, NULL,
          NULL lx, l.djh,   j.jsfs,  e.xm,l.khlx
        FROM cw_xsjs l, jsfs j, emp e,dwtx h,dwdq q
        WHERE l.jsfsid = j.jsfsid
        AND l.personid = e.personid
        AND   l.rq >= v_start
        AND l.rq <= v_end
        AND l.dwtxid=h.dwtxid
        AND h.dqh=q.dqh
        AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
        AND ((p_jscheck_in = '1' AND l.zt IN (0,1,9,8)) OR (p_jscheck_in = '0' AND l.zt IN (1,8)))
      ) t
      ORDER BY rq
      ;
    END IF;
  END xs_receivable_detail;
 ----------------------------------------------------------------
 ----------------------------------------------------------------
  /**
   * 应收帐款余额表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_areacode_in IN VARCHAR2  地区编号
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_custid_in IN VARCHAR2    客户id
   * @param p_custtype_in IN VARCHAR2  客户类型
   * @param p_salerid_in IN VARCHAR2   业务员id
   * @param p_tdcheck_in IN VARCHAR2   提单是否包括未记帐 1,0
   * @param p_jscheck_in IN VARCHAR2   结算是否包括未记帐 1.0
   * @param p_condition_in IN VARCHAR2   不显示本月没发生,期未余额为0的客户
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_balance(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_areacode_in  IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_custtype_in  IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_tdcheck_in   IN VARCHAR2,
    p_jscheck_in   IN VARCHAR2,
    p_condition_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD')+1;
    --表示提货单
    IF(p_billtype_in = '1') THEN
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT areacode,dqmc, dwmc,dwdm,dwtxid, sum(nvl(qichuye,0))qichuye, sum(nvl(zjf,0))zjf,sum(nvl(zdf,0))zdf,sum(nvl(qichuye,0)+nvl(zjf,0)-nvl(zdf,0))qimeye,sum(nvl(zsl,0))zsl
        FROM
         (
           --得到期初余额(始)
           SELECT areacode,dqmc, dwmc,dwdm,dwtxid,sum(nvl(jf,0)-nvl(df,0)+nvl(ysk,0))qichuye, NULL zjf, NULL zdf, NULL qimeye,NULL zsl
           from
              (
               SELECT q.areacode,q.dqmc,c.dwmc,c.dwdm,t.dwtxid,NULL qichuye,SUM(nvl(t.zje,0))jf,NULL df,NULL ysk,NULL zsl--借金额
               FROM xs_td t,dwtx c,dwdq q
               WHERE t.tdrq < v_start
               AND t.dwtxid=c.dwtxid
               AND c.dqh=q.dqh
               AND (p_custid_in IS NULL OR t.dwtxid = p_custid_in)
               AND (p_salerid_in IS NULL OR t.personid = p_salerid_in)
               AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
               AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
               AND (p_custtype_in IS NULL OR t.khlx = p_custtype_in)
               AND (p_tdcheck_in = '1' OR t.zt IN(1,2,8))--2004-5-13 初始化提单不计入应收款
               AND t.zt<>3
               GROUP BY c.dwmc,t.dwtxid,c.dwdm,q.areacode,q.dqmc
             UNION ALL
              SELECT q.areacode,q.dqmc,x.dwmc,x.dwdm,l.dwtxid,NULL qichuye,NULL jf,SUM(nvl(l.je,0))df,NULL ysk,NULL zsl--贷金额
              FROM cw_xsjs l,dwtx x,dwdq q
              WHERE l.rq < v_start
              AND l.dwtxid=x.dwtxid
              AND x.dqh=q.dqh
              AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
              AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
              AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
              AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
              AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
              AND (p_jscheck_in = '1' OR l.zt = 1 OR l.zt=8)
              GROUP BY x.dwmc,l.dwtxid,x.dwdm,q.areacode,q.dqmc
             UNION ALL
              SELECT q.areacode,q.dqmc,d.dwmc,d.dwdm,y.dwtxid,NULL qichuye,NULL jf,NULL df,sum(nvl(y.ysk,0)) ysk,NULL zsl--应收款
              FROM xs_ysk y,dwtx d,dwdq q
              WHERE  y.dwtxid=d.dwtxid
              AND d.dqh=q.dqh
              AND (p_custid_in IS NULL OR y.dwtxid = p_custid_in)
              AND (p_fgsid_in IS NULL OR y.fgsid = p_fgsid_in)
              AND (p_salerid_in IS NULL OR d.personid= p_salerid_in)
              AND (p_custtype_in IS NULL OR y.khlx = p_custtype_in)
              AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
              GROUP BY q.areacode,q.dqmc,d.dwmc,d.dwdm,y.dwtxid
             )e
          GROUP BY dwmc,dwtxid ,dwdm,areacode,dqmc -----得到期初余额(未)
          UNION ALL
            SELECT areacode,dqmc, dwmc,dwdm,dwtxid,NULL qichuye,SUM(nvl(njf,0))zjf,SUM(nvl(ndf,0))zdf,NULL qimeye,SUM(nvl(zsl,0))zsl
            FROM --得到本时间段的借金额与贷金额
             (
             SELECT q.areacode,q.dqmc, w.dwmc,w.dwdm,t.dwtxid,SUM(nvl(t.zje,0))njf,NULL ndf,SUM(nvl(t.zsl,0))zsl--借金额
             FROM xs_td t,dwtx w,dwdq q
             WHERE t.tdrq < v_end
             AND t.tdrq>=v_start
             AND t.dwtxid=w.dwtxid
             AND w.dqh=q.dqh
             AND (p_custid_in IS NULL OR t.dwtxid = p_custid_in)
             AND (p_salerid_in IS NULL OR t.personid = p_salerid_in)
             AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
             AND (p_fgsid_in IS NULL OR t.fgsid = p_fgsid_in)
             AND (p_custtype_in IS NULL OR t.khlx = p_custtype_in)
             AND (p_tdcheck_in = '1' OR t.zt IN(1,2,8))
             AND t.zt<>3
             --AND (p_condition_in  = '1' OR (nvl(t.zje,0)>0))------------------------------
             GROUP BY w.dwmc,t.dwtxid,w.dwdm,q.areacode,q.dqmc
             UNION ALL
             SELECT q.areacode,q.dqmc, f.dwmc,f.dwdm,l.dwtxid,NULL njf, SUM(nvl(l.je,0))ndf,NULL zsl--贷金额
             FROM cw_xsjs l ,dwtx f,dwdq q
             WHERE l.rq < v_end
             AND l.rq>=v_start
             AND l.dwtxid=f.dwtxid
             AND f.dqh=q.dqh
             AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
             AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
             AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
             AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
             AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
             AND (p_jscheck_in = '1' OR (l.zt = 1 OR l.zt = 8))
             --AND (p_custtype_in  = '0' OR (nvl(l.je,0)>0))-----------------------------------
             group by f.dwmc,l.dwtxid,f.dwdm,q.areacode,q.dqmc
             )h
            group by dwmc,dwtxid,dwdm,areacode,dqmc
        )p
        GROUP BY dwmc,dwtxid,dwdm,areacode,dqmc
      )t
      WHERE p_condition_in=1 OR (t.zjf <> 0 OR t.zdf<>0 OR qimeye<>0);
     ELSE --表示发票
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT areacode,dqmc,dwmc,dwdm,dwtxid, sum(nvl(qichuye,0))qichuye, sum(nvl(zjf,0))zjf,sum(nvl(zdf,0))zdf,sum(nvl(qichuye,0)+nvl(zjf,0)-nvl(zdf,0))qimeye,SUM(nvl(zsl,0))zsl
        FROM
        (
        --得到发票期初余额
        SELECT areacode,dqmc, dwmc,dwdm,dwtxid,sum(nvl(jf,0)-nvl(df,0)+nvl(ysk,0))qichuye, NULL zjf, NULL zdf, NULL qimeye,SUM(nvl(zsl,0))zsl
        FROM
        (
            SELECT q.areacode,q.dqmc, c.dwmc,c.dwdm,f.dwtxid,NULL qichuye,SUM(nvl(m.jshj,0))jf,NULL df,NULL ysk,SUM(nvl(m.sl,0))zsl
            FROM cw_xsfp f ,cw_xsfpmx m ,dwtx c,dwdq q
            WHERE f.kprq< v_start
            AND f.dwtxid=c.dwtxid
            AND c.dqh=q.dqh
            AND f.xsfpid=m.xsfpid
            AND (p_custid_in IS NULL OR f.dwtxid = p_custid_in)
            AND (p_salerid_in IS NULL OR f.personid = p_salerid_in)
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
            AND (p_tdcheck_in = '1' OR f.zt = 1)
            group by c.dwmc ,f.dwtxid,c.dwdm,q.areacode,q.dqmc
            UNION ALL
            SELECT q.areacode,q.dqmc, x.dwmc,x.dwdm,l.dwtxid,NULL qichuye,NULL jf,SUM(nvl(l.je,0))df,NULL ysk,NULL zsl
            FROM cw_xsjs l ,dwtx x,dwdq q
            WHERE l.rq < v_start
            AND l.dwtxid=x.dwtxid
            AND x.dqh=q.dqh
            AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
            AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
            AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
            AND (p_jscheck_in = '1' OR l.zt = 1 OR l.zt=8)
            group by x.dwmc,l.dwtxid,x.dwdm,q.areacode,q.dqmc
            UNION ALL
            SELECT q.areacode,q.dqmc, d.dwmc,d.dwdm,y.dwtxid,NULL qichuye,NULL jf,NULL df,sum(nvl(y.ysk,0)) ysk,NULL zsl
            FROM xs_ysk y,dwtx d,dwdq q
            WHERE  y.dwtxid=d.dwtxid
            AND d.dqh=q.dqh
            AND (p_custid_in IS NULL OR y.dwtxid = p_custid_in)
            AND (p_fgsid_in IS NULL OR y.fgsid = p_fgsid_in)
            AND (p_salerid_in IS NULL OR d.personid = p_salerid_in)
            AND (p_custtype_in IS NULL OR y.khlx = p_custtype_in)
            AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
            GROUP BY q.areacode,q.dqmc, d.dwmc,d.dwdm,y.dwtxid--应收款
        )d
        GROUP BY dwmc,dwdm,dwtxid ,areacode,dqmc -----得到期初余额(未)
        UNION ALL
        SELECT areacode,dqmc,  dwmc,dwdm,dwtxid,NULL qichuye,SUM(nvl(njf,0))zjf,SUM(nvl(ndf,0))zdf,NULL qimeye,SUM(nvl(zsl,0))zsl
        FROM --得到本时间段的借金额与贷金额
           (
             SELECT q.areacode,q.dqmc, w.dwmc,w.dwdm,f.dwtxid,SUM(nvl(m.jshj,0))njf,NULL ndf,SUM(nvl(m.sl,0))zsl--借方
             FROM cw_xsfp f ,cw_xsfpmx m ,dwtx w,dwdq q--销售发票
             WHERE f.kprq< v_end
             AND f.xsfpid=m.xsfpid
             AND f.dwtxid=w.dwtxid
             AND w.dqh=q.dqh
             AND (p_custid_in IS NULL OR f.dwtxid = p_custid_in)
             AND (p_salerid_in IS NULL OR f.personid = p_salerid_in)
             AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
             AND (p_fgsid_in IS NULL OR f.fgsid = p_fgsid_in)
             AND (p_tdcheck_in = '1' OR f.zt = 1)
             group by w.dwmc ,f.dwtxid,w.dwdm,q.areacode,q.dqmc
             UNION ALL
             SELECT q.areacode,q.dqmc, c.dwmc,c.dwdm,l.dwtxid,NULL njf, SUM(nvl(l.je,0))ndf,NULL zsl--贷方
             FROM cw_xsjs l ,dwtx c ,dwdq q--销售结算
             WHERE l.rq < v_end
             AND l.dwtxid=c.dwtxid
             AND c.dqh=q.dqh
             AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
             AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
             AND (p_areacode_in IS NULL OR q.areacode = p_areacode_in)
             AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
             AND (p_custtype_in IS NULL OR l.khlx = p_custtype_in)
             AND (p_jscheck_in = '1' OR l.zt = 1 OR l.zt=8)
             group by c.dwmc ,l.dwtxid,c.dwdm,q.areacode,q.dqmc
           )d
           GROUP BY dwmc ,dwtxid,dwdm,areacode,dqmc
        ) b
       GROUP BY dwmc,dwtxid,dwdm,areacode,dqmc
      )t
      WHERE p_condition_in=1 OR (t.zjf <> 0 OR t.zdf<>0 OR qimeye<>0);
    END IF;
  END xs_receivable_balance;
  ----------------------------------------------------------------
  /**
   * 应收帐款分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_custid_in IN VARCHAR2    客户id
   * @param p_salerid_in IN VARCHAR2   业务员id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receivable_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_custid_in    IN VARCHAR2,
    p_salerid_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --表示提货单
      OPEN p_data_out FOR
      SELECT SUM(aye) aye,SUM(cye) cye,SUM(acye) acye, SUM(axsje)axsje,SUM(cxsje)cxsje, SUM(acxsje)acxsje,SUM(assje) assje, SUM(cssje) cssje,SUM(acssje) acssje,sum(nvl(aye,0)+nvl(axsje,0)-nvl(assje,0))aqian,sum(nvl(cye,0)+nvl(cxsje,0)-nvl(cssje,0))cqian,sum(nvl(acye,0)+nvl(acxsje,0)-nvl(acssje,0))acqian,dwmc,dwtxid,dwdm
      FROM
      (
        SELECT SUM(nvl(axfje,0)+nvl(aysk,0)-nvl(ayfje,0)) aye,SUM(nvl(cxfje,0)+nvl(cysk,0)-nvl(cyfje,0)) cye, SUM(nvl(acxfje,0)+nvl(acysk,0)-nvl(acyfje,0)) acye,NULL axsje, NULL assje, NULL cxsje, NULL acxsje,NULL cssje,NULL acssje,  dwmc,dwdm,dwtxid
        FROM
        (---------------------a
          SELECT c.dwdm,c.dwmc,  sum(nvl(x.jje,0)) axfje,NULL cxfje,NULL acxfje, NULL ayfje, NULL cyfje,NULL acyfje,NULL aysk,NULL cysk,NULL acysk,j.dwtxid
          FROM xs_td j,xs_tdhw x, dwtx c--得到上期需付款
          WHERE j.dwtxid=c.dwtxid
          AND j.tdid=x.tdid
          AND j.tdrq<v_start AND j.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR j.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR j.personid = p_salerid_in)
          AND  j.zt= 8
          AND j.khlx='A'----
          GROUP BY c.dwmc, c.dwdm,j.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc, NULL axfje,NULL cxfje,NULL acxfje, SUM(nvl(h.je,0)) ayfje , NULL cyfje,NULL acyfje,NULL aysk,NULL cysk,NULL acysk,h.dwtxid
          FROM cw_xsjs h, dwtx b --得到上期已付款
          WHERE h.dwtxid=b.dwtxid
          AND h.rq<v_start
          AND h.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR h.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR h.personid = p_salerid_in)
          AND  h.zt IN(1,8)
          AND h.khlx='A'-----
          GROUP BY b.dwmc, b.dwdm,h.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc,  NULL axfje,NULL cxfje, NULL acxfje,NULL ayfje , NULL cyfje,NULL acyfje,sum(nvl(ysk,0))aysk,NULL cysk,NULL acysk,k.dwtxid
          FROM xs_ysk k, dwtx b --得到上期已付款
          WHERE k.dwtxid=b.dwtxid
          AND k.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR k.personid = p_salerid_in)
          AND k.khlx='A'-----
          GROUP BY b.dwmc,b.dwdm,k.dwtxid
          UNION ALL------------------------------c
          SELECT c.dwdm,c.dwmc, NULL axfje, sum(nvl(x.jje,0)) cxfje,NULL acxfje, NULL ayfje, NULL cyfje,NULL acyfje,NULL aysk,NULL cysk,NULL acysk,j.dwtxid
          FROM xs_td j,xs_tdhw x, dwtx c--得到上期需付款
          WHERE j.dwtxid=c.dwtxid
          AND j.tdid=x.tdid
          AND j.tdrq<v_start AND j.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR j.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR j.personid = p_salerid_in)
          AND j.zt =8
          AND j.khlx='C'
          GROUP BY c.dwmc, c.dwdm,j.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc,  NULL axfje, NULL cxfje,NULL acxfje, NULL ayfje, SUM(nvl(h.je,0)) cyfje ,NULL acyfje,NULL aysk,NULL cysk,NULL acysk,h.dwtxid
          FROM cw_xsjs h, dwtx b --得到上期已付款
          WHERE h.dwtxid=b.dwtxid
          AND h.rq<v_start
          AND h.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR h.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR h.personid = p_salerid_in)
          AND  h.zt IN(1,8)
          AND h.khlx='C'
          GROUP BY b.dwmc, h.khlx,b.dwdm,h.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc, NULL axfje, NULL cxfje,NULL acxfje, NULL ayfje, NULL cyfje ,NULL acyfje ,NULL aysk ,sum(nvl(ysk,0))cysk,NULL acysk ,k.dwtxid
          FROM xs_ysk k, dwtx b --得到上期已付款
          WHERE k.dwtxid=b.dwtxid
          AND k.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR k.personid = p_salerid_in)
          AND k.khlx='C'
          GROUP BY b.dwmc,b.dwdm,k.dwtxid
          UNION ALL------------------------------ac
          SELECT c.dwdm,c.dwmc, NULL axfje,NULL cxfje, sum(nvl(x.jje,0)) acxfje, NULL ayfje, NULL cyfje,NULL acyfje,NULL aysk,NULL cysk,NULL acysk,j.dwtxid
          FROM xs_td j,xs_tdhw x, dwtx c--得到上期需付款
          WHERE j.dwtxid=c.dwtxid
          AND j.tdid=x.tdid
          AND j.tdrq<v_start AND j.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR j.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR j.personid = p_salerid_in)
          AND  j.zt =8
          GROUP BY c.dwmc, c.dwdm,j.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc, NULL axfje, NULL cxfje,NULL acxfje, NULL ayfje,NULL cyfje,  SUM(nvl(h.je,0)) acyfje ,NULL aysk,NULL cysk,NULL acysk,h.dwtxid
          FROM cw_xsjs h, dwtx b --得到上期已付款
          WHERE h.dwtxid=b.dwtxid
          AND h.rq<v_start
          AND h.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR h.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR h.personid = p_salerid_in)
          AND  h.zt IN(1,8)
          GROUP BY b.dwmc, b.dwdm,h.dwtxid
          UNION ALL
          SELECT b.dwdm,b.dwmc, NULL axfje, NULL cxfje, NULL acxfje,NULL ayfje, NULL cyfje ,NULL acyfje ,NULL aysk ,NULL cysk,sum(nvl(k.ysk,0))acysk,k.dwtxid
          FROM xs_ysk k, dwtx b --得到上期已付款
          WHERE k.dwtxid=b.dwtxid
          AND k.fgsid=p_fgsid_in
          AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
          AND (p_salerid_in IS NULL OR k.personid = p_salerid_in)
          GROUP BY b.dwmc,b.dwdm,k.dwtxid,k.khlx
       ) e
       GROUP BY  dwmc,dwdm,dwtxid----------------------得到余额

        --提单数据
        UNION ALL
        SELECT null aye,null cye,null acye,sum(nvl(r.jje,0))axsje,null assje,NULL cxsje,NULL acxsje,NULL cssje,NULL acssje,c.dwmc,c.dwdm,w.dwtxid
        FROM xs_td w,xs_tdhw r,dwtx c
        WHERE  w.tdid=r.tdid
        AND w.dwtxid=c.dwtxid
        AND w.tdrq >= v_start AND w.tdrq <= v_end
        AND (p_custid_in IS NULL OR w.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR w.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR w.fgsid = p_fgsid_in)
        AND w.zt =8
        AND w.khlx='A'---
        group by c.dwmc,c.dwdm,w.dwtxid
        --销售结算数据
        UNION ALL
        SELECT null aye,NULL cye,null acye,null axsje,sum(nvl(l.je,0)) assje,null cxsje,null acxsje,NULL cssje ,NULL acssje,c.dwmc,c.dwdm,l.dwtxid
        FROM cw_xsjs l,dwtx c
        WHERE   l.rq >= v_start AND l.rq <= v_end
        AND l.dwtxid=c.dwtxid
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND  l.zt IN(1,8)
        AND l.khlx='A'----
        GROUP BY  c.dwmc,c.dwdm,l.dwtxid
        UNION ALL----------------------------------------------------------------c
        SELECT null aye,NULL cye,null acye,NULL axsje,NULL assje,sum(nvl(r.jje,0))cxsje,null acxsje,null cssje,null acssje,c.dwmc,c.dwdm,w.dwtxid
        FROM xs_td w,xs_tdhw r,dwtx c
        WHERE  w.tdid=r.tdid
        AND w.dwtxid=c.dwtxid
        AND w.tdrq >= v_start AND w.tdrq < v_end
        AND (p_custid_in IS NULL OR w.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR w.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR w.fgsid = p_fgsid_in)
        AND  w.zt =8
        AND w.khlx='C'----
        group by c.dwmc,c.dwdm,w.dwtxid
        --销售结算数据
        UNION ALL
        SELECT null aye,NULL cye,null acye,NULL axsje,NULL assje,null cxsje,null acxsje,sum(nvl(l.je,0))cssje,null acssje, c.dwmc,c.dwdm,l.dwtxid
        FROM cw_xsjs l,dwtx c
        WHERE   l.rq >= v_start AND l.rq <= v_end
        AND l.dwtxid=c.dwtxid
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND  l.zt IN(1,8)
        AND l.khlx='C'
        GROUP BY  c.dwmc,c.dwdm,l.dwtxid
        UNION ALL----------------------------------------------------------------ac
        SELECT null aye,NULL cye,null acye,NULL axsje,NULL assje,NULL cxsje,sum(nvl(r.jje,0))acxsje,null cssje,null acssje,c.dwmc,c.dwdm,w.dwtxid
        FROM xs_td w,xs_tdhw r,dwtx c
        WHERE  w.tdid=r.tdid
        AND w.dwtxid=c.dwtxid
        AND w.tdrq >= v_start AND w.tdrq <= v_end
        AND (p_custid_in IS NULL OR w.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR w.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR w.fgsid = p_fgsid_in)
        AND  w.zt =8
        group by c.dwmc,c.dwdm,w.dwtxid
        --销售结算数据
        UNION ALL
        SELECT null aye,NULL cye,null acye,NULL axsje,NULL assje,null cxsje,null acxsje,NULL cssje,sum(nvl(l.je,0)) acssje, c.dwmc,c.dwdm,l.dwtxid
        FROM cw_xsjs l,dwtx c
        WHERE   l.rq >= v_start AND l.rq <= v_end
        AND l.dwtxid=c.dwtxid
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND  l.zt IN(1,8)
        GROUP BY  c.dwmc,c.dwdm,l.dwtxid
      ) t
      GROUP BY dwmc, dwdm,dwtxid
      ;



     /*ELSE --表示发票
      OPEN p_data_out FOR
      SELECT sum(ye)ye,sum(xsje)xsje,sum(ssje)ssje,sum(nvl(ye,0)+nvl(xsje,0)-nvl(ssje,0))qian,khlx,dwmc,dwdm ,dwtxid
      FROM
      (
     SELECT    nvl(xfje,0)+nvl(ysk,0)-nvl(yfje,0)ye,null xsje,null ssje,khlx,dwmc,dwdm,dwtxid
      FROM
      (
      SELECT c.dwdm,  c.dwmc, null khlx, sum(nvl(f.jshj,0)) xfje, NULL yfje ,NULL ysk,m.dwtxid
        FROM cw_xsfp m, dwtx c, cw_xsfpmx f --得到期初应付金额
        WHERE m.dwtxid=c.dwtxid  and m.xsfpid=f.xsfpid
        AND m.kprq<v_start AND m.fgsid=p_fgsid_in
        AND (p_custid_in IS NULL OR m.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR m.personid = p_salerid_in)
        AND (m.zt=1 OR m.zt=8)
        group by c.dwmc,c.dwdm,m.dwtxid
      UNION ALL
      SELECT  c.dwdm, c.dwmc,n.khlx, NULL xfje, sum(nvl(n.je,0)) yfje,NULL ysk,n.dwtxid
        FROM cw_xsjs n, dwtx c --得到期初实收金额
        WHERE n.dwtxid=c.dwtxid
        AND n.rq<v_start AND n.fgsid=p_fgsid_in
        AND (p_custid_in IS NULL OR n.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR n.personid = p_salerid_in)
        AND (n.zt=1 OR n.zt IN(1,8))
        GROUP BY c.dwdm, c.dwmc,n.khlx,n.dwtxid
      UNION ALL
      SELECT b.dwdm, b.dwmc, NULL khlx, NULL xfje, NULL yfje ,sum(nvl(ysk,0))ysk,k.dwtxid
        FROM xs_ysk k, dwtx b --得到上期已付款
        WHERE k.dwtxid=b.dwtxid
        AND k.rq<v_start
        AND k.fgsid=p_fgsid_in
        AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
        GROUP BY b.dwdm, b.dwmc,k.dwtxid
      ) e
        --发票数据
        UNION ALL
        SELECT null ye,sum(nvl(m.jshj,0))xsje,null ssje,null khlx,c.dwmc,c.dwdm,p.dwtxid
        FROM cw_xsfp p,cw_xsfpmx m,dwtx c
        WHERE  p.xsfpid=m.xsfpid
        AND p.dwtxid=c.dwtxid
        AND   p.kprq>= v_start AND p.kprq < v_end
        AND (p_custid_in IS NULL OR p.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR p.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR p.fgsid = p_fgsid_in)
        AND (p.zt = 8 OR p.zt = 1)
        group by c.dwmc,c.dwdm,p.dwtxid
        --销售结算数据
        UNION ALL
        SELECT null ye , NULL xsje,sum(nvl(l.je,0)) ssje, l.khlx,c.dwmc,c.dwdm,l.dwtxid
        FROM cw_xsjs l,dwtx c
        WHERE   l.rq >= v_start AND l.rq < v_end
        AND l.dwtxid=c.dwtxid
        AND (p_custid_in IS NULL OR l.dwtxid = p_custid_in)
        AND (p_salerid_in IS NULL OR l.personid = p_salerid_in)
        AND (p_fgsid_in IS NULL OR l.fgsid = p_fgsid_in)
        AND (l.zt = 8 OR l.zt IN(1,8))
        group by l.khlx,c.dwmc,c.dwdm,l.dwtxid
      ) t
      group by khlx,dwmc,dwdm,dwtxid
      ;
    END IF;*/
  END xs_receivable_collect;
  /**
   * 业务员应收帐款统计
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_billtype_in IN VARCHAR2  单据类型(提货单或发票)
   * @param p_deptid_in IN VARCHAR2   部门ID
   * @param p_check_in IN VARCHAR2   单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_saler_receivable(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_billtype_in  IN VARCHAR2,
    p_deptid_in   IN VARCHAR2,
    p_check_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --表示提货单
    IF(p_billtype_in = '1') THEN
      OPEN p_data_out FOR
      SELECT mc, xm, dwmc, SUM(nvl(xssl,0)) xssl, SUM(nvl(xsje,0)) xsje,
             SUM(nvl(bqhk,0)) bqhk, SUM(nvl(sqye,0)) sqye,
             (SUM(nvl(xsje,0))+ SUM(nvl(sqye,0))-SUM(nvl(bqhk,0))) bqye,dwdm
     FROM
     (
     --得到上期余额
     SELECT  mc, xm, dwmc, NULL xssl, NULL xsje, NULL bqhk,
             SUM(nvl(yfje,0)+nvl(ysk,0)-nvl(sfje,0)) sqye,dwdm
      FROM
      (
      SELECT  b.mc, d.xm, c.dwmc, SUM(nvl(a.zje,0)) yfje, NULL sfje ,NULL ysk,c.dwdm
        FROM xs_td a, bm b, dwtx c, emp d --得到期初应付金额
        WHERE a.deptid=b.deptid
        AND a.dwtxid=c.dwtxid
        AND a.personid=d.personid(+)
        AND a.tdrq<v_start
        AND a.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_check_in='1' OR a.zt=8)
        AND a.zt<>3
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT  b.mc, d.xm, c.dwmc, NULL yfje, SUM(nvl(f.je,0)) sfje,NULL ysk,c.dwdm
        FROM cw_xsjs f, bm b, dwtx c, emp d --得到期初实收金额
        WHERE f.deptid=b.deptid
        AND f.dwtxid=c.dwtxid
        AND f.personid=d.personid(+)
        AND f.rq<v_start
        AND f.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR f.deptid = p_deptid_in)
        AND (p_check_in='1' OR f.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT NULL mc, NULL xm, b.dwmc, NULL yfje ,NULL sfje,sum(nvl(ysk,0))ysk,b.dwdm
        FROM xs_ysk k, dwtx b --得到上期已付款
        WHERE k.dwtxid=b.dwtxid
        AND k.rq<v_start
        AND k.fgsid=p_fgsid_in
        GROUP BY b.dwmc,b.dwdm
        --AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
      ) e
      GROUP BY mc, xm, dwmc,dwdm
    UNION ALL
    SELECT  mc, xm, dwmc, SUM(nvl(xssl,0)) xssl, SUM(nvl(xsje,0)) xsje, SUM(nvl(bqhk,0)) bqhk,
            NULL sqye,dwdm
     FROM --得到本期销售数量和回款金额
      (
      SELECT b.mc, d.xm, c.dwmc, SUM(nvl(a.zsl,0)) xssl, SUM(nvl(a.zje,0)) xsje, NULL bqhk,c.dwdm
        FROM xs_td a, bm b, dwtx c, emp d --得到本期的销售数量
         WHERE a.deptid=b.deptid AND a.dwtxid=c.dwtxid AND a.personid=d.personid(+)
        AND a.tdrq>=v_start AND a.tdrq<=v_end AND a.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_check_in='1' OR a.zt=8)
        AND a.zt<>3
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT  b.mc, d.xm, c.dwmc, NULL xssl, NULL xsje, SUM(f.je) bqhk,c.dwdm
        FROM cw_xsjs f, bm b, dwtx c, emp d --得到本期的回款
        WHERE f.deptid=b.deptid AND f.dwtxid=c.dwtxid AND f.personid=d.personid(+)
        AND f.rq>=v_start AND f.rq<=v_end AND f.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR f.deptid = p_deptid_in)
        AND (p_check_in='1' OR f.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      ) h
      GROUP BY mc, xm, dwmc,dwdm
      ) g
      GROUP BY mc, xm, dwmc,dwdm
      ORDER BY mc,xm;
  ELSE            -------------------发票
      OPEN p_data_out FOR
      SELECT mc, xm, dwmc, SUM(nvl(xssl,0)) xssl, SUM(nvl(xsje,0)) xsje,
             SUM(nvl(bqhk,0)) bqhk, SUM(nvl(sqye,0)) sqye,
             (SUM(nvl(xsje,0))+ SUM(nvl(sqye,0))-SUM(nvl(bqhk,0))) bqye,dwdm
     FROM
     (
     --得到上期余额
     SELECT  mc, xm, dwmc, NULL xssl, NULL xsje, NULL bqhk,
             sum(nvl(yfje,0)+nvl(ysk,0)-nvl(sfje,0)) sqye,dwdm
      FROM
      (
      SELECT  b.mc, d.xm, c.dwmc, SUM(nvl(f.jshj,0)) yfje, NULL sfje ,NULL ysk,c.dwdm
        FROM cw_xsfp a, bm b, dwtx c, emp d, cw_xsfpmx f --得到期初应付金额
        WHERE a.deptid=b.deptid AND a.dwtxid=c.dwtxid AND a.personid=d.personid(+)
        AND a.kprq<v_start AND a.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_check_in='1' OR a.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT  b.mc, d.xm, c.dwmc, NULL yfje, SUM(nvl(f.je,0)) sfje,NULL ysk,c.dwdm
        FROM cw_xsjs f, bm b, dwtx c, emp d --得到期初实收金额
        WHERE f.deptid=b.deptid AND f.dwtxid=c.dwtxid AND f.personid=d.personid(+)
        AND f.rq<v_start AND f.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR f.deptid = p_deptid_in)
        AND (p_check_in='1' OR f.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT NULL mc, NULL xm, b.dwmc, NULL yfje ,NULL sfje,sum(nvl(ysk,0))ysk,b.dwdm
        FROM xs_ysk k, dwtx b --得到上期已付款
        WHERE k.dwtxid=b.dwtxid
        AND k.rq<v_start
        AND k.fgsid=p_fgsid_in
        GROUP BY b.dwdm,b.dwmc
        --AND (p_custid_in IS NULL OR k.dwtxid = p_custid_in)
      ) e  GROUP BY mc, xm, dwmc,dwdm
    UNION ALL-----
    SELECT  mc, xm, dwmc, SUM(nvl(xssl,0)) xssl, SUM(nvl(xsje,0)) xsje, SUM(nvl(bqhk,0)) bqhk,
            NULL sqye,dwdm
     FROM --得到本期销售数量和回款金额
      (
      SELECT b.mc, d.xm, c.dwmc, SUM(nvl(j.sl,0)) xssl, SUM(nvl(j.jshj,0)) xsje, NULL bqhk,c.dwdm
        FROM cw_xsfp a, bm b, dwtx c, emp d, cw_xsfpmx j--得到本期的销售数量
         WHERE a.deptid=b.deptid AND a.dwtxid=c.dwtxid AND a.personid=d.personid(+)
        AND a.kprq>=v_start AND a.kprq<=v_end AND a.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_check_in='1' OR a.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      UNION ALL
      SELECT  b.mc, d.xm, c.dwmc, NULL xssl, NULL xsje, SUM(f.je) bqhk,c.dwdm
        FROM cw_xsjs f, bm b, dwtx c, emp d --得到本期的回款
        WHERE f.deptid=b.deptid AND f.dwtxid=c.dwtxid AND f.personid=d.personid(+)
        AND f.rq>=v_start AND f.rq<=v_end AND f.fgsid=p_fgsid_in
        AND (p_deptid_in IS NULL OR f.deptid = p_deptid_in)
        AND (p_check_in='1' OR f.zt=1)
        GROUP BY b.mc, d.xm, c.dwmc,c.dwdm
      ) h
      GROUP BY mc, xm, dwmc ,dwdm------------
      ) g
      GROUP BY mc, xm, dwmc,dwdm
      ORDER BY mc,xm;
    END IF;
  END xs_saler_receivable;
  /**
   * 销售资金回笼表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_money(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start :=to_date(p_startyear_in||'-'||p_startmonth_in||'-1','YYYY-MM-DD');
    v_end   :=to_date(p_enddyear_in||'-'||p_enddmonth_in||'-1','YYYY-MM-DD');
      OPEN p_data_out FOR
        SELECT sum(nvl(qcye,0))qcye,sum(nvl(dje,0))dje,sum(nvl(jje,0))jje,(sum(nvl(qcye,0))+sum(nvl(jje,0))-sum(nvl(dje,0)))qmye ,personid,xm
        FROM
        (
        ------------------------------------------------------------------------------------------
        SELECT SUM(nvl(qicu.zje,0)-nvl(qicu.je,0))qcye,NULL dje,NULL jje,qicu.personid,qicu.xm
        FROM
        (
        SELECT nvl(jf.zje,0)zje,nvl(df.je,0)je,jf.xm,jf.personid
        FROM
        (
        SELECT SUM(nvl(a.zje,0)) zje,b.xm,b.personid
        FROM xs_td a,emp b
        WHERE a.personid=b.personid
        AND a.zt<>4
        AND a.tdrq<v_start
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        GROUP BY b.xm,b.personid
        )jf
        ,(
        SELECT sum(nvl(a.je,0))je,b.xm,b.personid
        FROM cw_xsjs a,emp b
        WHERE a.rq<v_start
        AND a.personid=b.personid
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        GROUP BY b.xm,b.personid
        )df
        WHERE jf.personid=df.personid(+)
        )qicu
        GROUP BY qicu.personid,qicu.xm
        ---------------------------------------------------------------------
        UNION ALL
        SELECT NULL qcye,SUM(nvl(j.je,0))dje,NULL jje,b.personid,b.xm
        FROM cw_xsjs j,emp b
        WHERE j.personid=b.personid
        AND  j.rq >=v_start
        AND (p_fgsid_in IS NULL OR j.fgsid = p_fgsid_in)
        AND to_date(to_char(j.rq,'yyyy-mm'),'yyyy-mm')<=v_end
        ---to_date(to_char(to_date('2004-11-11','YYYY-MM-DD'),'YYYY-MM'), 'YYYY-MM')
        GROUP BY b.xm,b.personid
        UNION ALL
        SELECT NULL qcye,NULL dje,SUM(nvl(a.zje,0))jje,b.personid,b.xm
        FROM xs_td a,emp b
        WHERE a.personid=b.personid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        GROUP BY b.xm,b.personid
        )e
        GROUP BY personid,xm;
  END xs_receive_money;
  ----------------------------------------------------------------
  /**
   * 销售数量金额表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_acmoney(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start :=to_date(p_startyear_in||'-'||p_startmonth_in||'-1','YYYY-MM-DD');
    v_end   :=to_date(p_enddyear_in||'-'||p_enddmonth_in||'-1','YYYY-MM-DD');
      OPEN p_data_out FOR
        SELECT xm,pm,sum(nvl(asl,0))asl,sum(nvl(ajje,0))ajje,sum(nvl(csl,0))csl,sum(nvl(cjje,0))cjje,sum(nvl(acsl,0))acsl,sum(nvl(acjje,0))acjje
        FROM
        (
        SELECT d.xm,c.pm,'A' A,NULL C,NULL AC,sum(nvl(b.sl,0))asl,SUM(nvl(b.jje,0))ajje,NULL csl,NULL cjje,NULL acsl,NULL acjje
        FROM xs_td a,xs_tdhw b,kc_dm c,emp d
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.personid = d.personid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        AND a.khlx='A'
        GROUP BY d.xm,c.pm
        UNION ALL
        SELECT d.xm,c.pm,NULL A,'C' C,NULL AC,NULL asl,NULL ajje,sum(nvl(b.sl,0))csl,SUM(nvl(b.jje,0))cjje,NULL acsl,NULL acjje
        FROM xs_td a,xs_tdhw b,kc_dm c,emp d
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.zt<>4
        AND a.personid = d.personid
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        AND a.khlx='C'
        GROUP BY d.xm,c.pm
        UNION ALL
        SELECT d.xm,c.pm,NULL A,NULL C,'AC' AC,NULL asl,NULL ajje,NULL csl,NULL cjje,sum(nvl(b.sl,0))acsl,SUM(nvl(b.jje,0))acjje
        FROM xs_td a,xs_tdhw b,kc_dm c,emp d
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        AND a.personid = d.personid
        GROUP BY d.xm,c.pm
        )
        GROUP BY xm,pm;
  END xs_receive_acmoney;
  ----------------------------------------------------------------
  /**
   * 月销售统计
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startyear_in IN VARCHAR2 开始年份
   * @param p_startmonth_in IN VARCHAR2 开始月份
   * @param p_enddyear_in IN VARCHAR2   结束年份
   * @param p_enddmonth_in IN VARCHAR2   结束月份
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE xs_receive_acpm(
    p_data_out     OUT rc,      --返回的数据集
    p_startyear_in IN VARCHAR2,
    p_startmonth_in  IN VARCHAR2,
    p_enddyear_in   IN VARCHAR2,
    p_enddmonth_in   IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start :=to_date(p_startyear_in||'-'||p_startmonth_in||'-1','YYYY-MM-DD');
    v_end   :=to_date(p_enddyear_in||'-'||p_enddmonth_in||'-1','YYYY-MM-DD');
      OPEN p_data_out FOR
        SELECT pm,sum(nvl(asl,0))asl,sum(nvl(ajje,0))ajje,sum(nvl(csl,0))csl,sum(nvl(cjje,0))cjje,sum(nvl(acsl,0))acsl,sum(nvl(acjje,0))acjje
        FROM
        (
        SELECT c.pm,'A' A,NULL C,NULL AC,sum(nvl(b.sl,0))asl,SUM(nvl(b.jje,0))ajje,NULL csl,NULL cjje,NULL acsl,NULL acjje
        FROM xs_td a,xs_tdhw b,kc_dm c
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        AND a.khlx='A'
        GROUP BY c.pm
        UNION ALL
        SELECT c.pm,NULL A,'C' C,NULL AC,NULL asl,NULL ajje,sum(nvl(b.sl,0))csl,SUM(nvl(b.jje,0))cjje,NULL acsl,NULL acjje
        FROM xs_td a,xs_tdhw b,kc_dm c
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        AND a.khlx='C'
        GROUP BY c.pm
        UNION ALL
        SELECT c.pm,NULL A,NULL C,'AC' AC,NULL asl,NULL ajje,NULL csl,NULL cjje,sum(nvl(b.sl,0))acsl,SUM(nvl(b.jje,0))acjje
        FROM xs_td a,xs_tdhw b,kc_dm c
        WHERE a.tdid=b.tdid
        AND b.cpid=c.cpid
        AND a.zt<>4
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND  a.tdrq>=v_start
        AND to_date(to_char(a.tdrq,'yyyy-mm'),'yyyy-mm')<=v_end
        GROUP BY c.pm
        )
        GROUP BY pm;
  END xs_receive_acpm;
  /**
   * 销售提单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_tdid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Lading_Bill_Edit(
     p_data_out     OUT rc,      --返回的数据集
     p_tdid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT rownum, c.*
      FROM (
            SELECT
                  a.tdid,a.dwtxid,a.jsfsid,a.deptid,a.personid,a.tdbh,a.tdrq,a.dz,a.lxr,a.hkts
                  ,a.czrq,a.czyid,a.czy zdr,a.zt,a.ztms,a.fgsid,a.hkrq,a.sprid,a.isrefer,a.storeid,
                  a.khlx,a.yfdj,a.yf,a.ddfy,a.djh,
                  b.sl,b.dj,b.jje,b.cpid,b.xsj,b.xsje,b.bz,b.stsl,b.zk,b.hssl,
                  c.cpbm,(c.pm||'  '||c.gg)pm,d.dwmc,e.xm,f.mc,g.sxz,c.jldw,h.jsfs
                  ,j.ckmc,l.sendmode,NULL htbh,(SELECT xm FROM emp p WHERE p.personid=a.sprid)spr
             FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,emp e,bm f,kc_dmsx g,jsfs h,kc_ck j,jc_sendmode l
             WHERE a.tdid=b.tdid
             AND b.cpid=c.cpid
             AND a.dwtxid=d.dwtxid
             AND a.personid=e.personid
             AND a.deptid=f.deptid
             AND b.dmsxid=g.dmsxid(+)
             AND a.jsfsid=h.jsfsid(+)
             AND a.storeid=j.storeid(+)
             AND a.sendmodeid=l.sendmodeid(+)
             AND b.hthwid IS NULL
             AND   a.fgsid = p_fgsid_in
             AND   a.tdid = p_tdid_in
      UNION ALL
      SELECT
                 a.tdid,a.dwtxid,a.jsfsid,a.deptid,a.personid,a.tdbh,a.tdrq,a.dz,a.lxr,a.hkts
                 ,a.czrq,a.czyid,a.czy adr,a.zt,a.ztms,a.fgsid,a.hkrq,a.sprid,a.isrefer,a.storeid,
                 a.khlx,a.yfdj,a.yf,a.ddfy,a.djh,
                 b.sl,b.dj,b.jje,b.cpid,b.xsj,b.xsje,b.bz,b.stsl,b.zk,b.hssl,
                 c.cpbm,(c.pm||c.gg)pm,d.dwmc,e.xm,f.mc,g.sxz,c.jldw,h.jsfs
                 ,j.ckmc,l.sendmode,t.htbh,(SELECT xm FROM emp p WHERE p.personid=a.sprid)spr
      FROM xs_td a,xs_tdhw b,kc_dm c,dwtx d,emp e,bm f,kc_dmsx g,jsfs h,kc_ck j,jc_sendmode l,xs_ht t,xs_hthw r
      WHERE a.tdid=b.tdid
      AND b.cpid=c.cpid
      AND a.dwtxid=d.dwtxid
      AND a.personid=e.personid
      AND a.deptid=f.deptid
      AND b.dmsxid=g.dmsxid(+)
      AND a.jsfsid=h.jsfsid(+)
      AND a.storeid=j.storeid(+)
      AND a.sendmodeid=l.sendmodeid(+)
      AND t.htid=r.htid
      AND b.hthwid=r.hthwid
      AND   a.fgsid = p_fgsid_in
      AND   a.tdid = p_tdid_in
      )  c;
  END Lading_Bill_Edit;--销售提单打印

  /**
   * 销售合同
   * @param p_htid_in IN INTEGER 收发单据id
   *  param p_htid_in IN INTEGER,
    * param p_dwtxid_in     IN INTEGER,
   * param p_htrq_in     IN DATE,
   */
  PROCEDURE xs_ht_add(
     p_htid_in IN INTEGER,
     p_dwtxid_in     IN INTEGER,
     p_htrq_in     IN DATE
  )
  IS
  v_htbh xs_ht.htbh%TYPE;
  BEGIN
  SELECT pck_base.billNextCode('xs_ht','htbh')htbh INTO v_htbh FROM dual;
    --打开数据集
      INSERT INTO xs_ht(HTID,DWTXID,HTBH,HTRQ,CZRQ,CZY,CZYID,FGSID,DEPTID,zt)
      VALUES(p_htid_in,p_dwtxid_in,v_htbh,p_htrq_in,p_htrq_in,'admin',0,0,0,0);
  END xs_ht_add;--销售提单打印
  /**
   * 销售合同货物
   * @param p_htid_in IN INTEGER 收发单据id
   *  param p_htid_in IN INTEGER,
    * param p_dwtxid_in     IN INTEGER,
   * param p_htrq_in     IN DATE,
   */
  PROCEDURE xs_hthw_add(
     p_htid_in IN INTEGER,
     p_hthwid_in IN INTEGER,
     p_wzdjid_in     IN INTEGER,
     p_sl_in     IN INTEGER,
     p_price_in     IN NUMBER
  )
  IS
  v_hthwid xs_hthw.hthwid%TYPE;
  BEGIN
    SELECT S_XS_HTHW.nextval INTO v_hthwid FROM dual;
    --打开数据集
      INSERT INTO xs_hthw(HTID,HTHWID,WZDJID,HSSL,SL,XSJ,XSJE,DJ,JJE)
      VALUES(p_htid_in,v_hthwid,1,p_sl_in,p_sl_in,p_price_in,0,p_price_in,0);
  END xs_hthw_add;--销售提单打印
  ----------------------------------------------------------------
END PCK_SALE_REP;
/

prompt
prompt Creating package body PCK_STORE
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_STORE IS
  --月结有关
  MONTH_BALANCE_NO_DEFINE   CONSTANT INT := -20011;    --所填的项目不存在
  BEFORE_MONTH_NO_BALANCE   CONSTANT INT := -20012;    --上个月还未月结
  HAVE_UNAPPROVE_BILL       CONSTANT INT := -20013;    --还有未审单据
  --移库有关
  --WZMXID_IS_NULL            CONSTANT INT := -20021;    --审批流程没有定义审批人
  --FLOW_ALREADY_EXECUTE      CONSTANT INT := -20022;    --已经在审批之中
  /**
   * 提取最低报价的报价ID
   * p_data_out   OUT rc,        --返回的数据集
   * p_cgsqdid_in IN  VARCHAR2   --采购申请单ID
   */
  PROCEDURE getMinBuyPriceData(
    p_data_out   OUT rc,      --返回的数据集
    p_cgsqdid_in IN VARCHAR2  --采购申请单ID
  )
  IS
    --v_buypriceid cg_bj.cgbjid%TYPE;
  BEGIN
    OPEN p_data_out FOR
    SELECT b.cpid, b.dwtxid, b.bj--, t.cgsqdid
    FROM cg_bj b,
      (SELECT pck_store.getMinBuyPriceID(a.cpid) cgbjid-- a.cgsqdid
       FROM cg_sqdhw a WHERE a.cgsqdid = p_cgsqdid_in) t
    WHERE b.cgbjid = t.cgbjid;
  END  getMinBuyPriceData;
  /**
   * 提取最低报价的报价ID
   * @param p_htid_in     合同ID
   */
  FUNCTION getMinBuyPriceID(
    p_cpid_in    IN  INTEGER  --产品ID
  ) RETURN NUMBER
  IS
    v_buypriceid cg_bj.cgbjid%TYPE;
  BEGIN
    SELECT cgbjid INTO v_buypriceid
    FROM
    (
     SELECT MIN(a.cgbjid) cgbjid
     FROM cg_bj a
     WHERE (a.sflsbj=0 OR a.sflsbj IS NULL) AND a.cpid=p_cpid_in
     GROUP BY a.bj ORDER BY a.bj
    )
    WHERE ROWNUM < 2;
    RETURN v_buypriceid;
  EXCEPTION
    WHEN OTHERS THEN
     RETURN NULL;
  END  getMinBuyPriceID;
  /**
   * 保存物资明细
   * @param  p_operate_in  --操作类型：insert:插入一条数据，update:更新数据, delete:删除数据
   * @param  p_wzmdxid_in  --库存物资明细ID
   * @param  p_cpid_in     --交货单货物ID
   * @param  p_rkdmxid_in  --入库单明细ID
   * @param  p_dmsxid_in   --物资规格属性ID
   * @param  p_storeid_in  --仓库ID
   * @param  p_kwid_in     --库位ID
   * @param  p_wjid_in     --外键ID
   * @param  p_djxz_in     --单据性质
   * @param  p_ph_id       --批号
   * @param  p_zl_in       --重量(更新时表示增加或减少的)
   * @param  p_bz_in       --备注
   * @param  p_fgsid_in    --分公司ID
   *
  PROCEDURE saveGoods(
    p_operate_in  IN VARCHAR2,  --操作类型：insert:插入一条数据，update:更新数据, delete:删除数据
    p_wzmxid_in   IN INTEGER,  --库存物资明细ID
    p_cpid_in     IN INTEGER DEFAULT NULL, --商品ID
    p_rkdmxid_in  IN INTEGER DEFAULT NULL, --入库单明细ID
    p_dmsxid_in   IN INTEGER DEFAULT NULL, --物资规格属性ID
    p_storeid_in  IN INTEGER DEFAULT NULL, --仓库ID
    p_kwid_in     IN INTEGER DEFAULT NULL, --库位ID
    p_wjid_in     IN INTEGER DEFAULT NULL, --外键ID
    p_djxz_in     IN INTEGER DEFAULT NULL, --单据性质
    p_sl_in       IN INTEGER DEFAULT NULL, --重量
    p_fgsid_in    IN INTEGER DEFAULT NULL, --分公司id
    p_ph_id       IN VARCHAR2 DEFAULT NULL, --批号
    p_bz_in       IN VARCHAR2 DEFAULT NULL --备注
  ) IS
    v_old_fgsid   kc_wzmx.fgsid%TYPE;
    v_old_storeid kc_wzmx.storeid%TYPE;
    v_old_cpid    kc_wzmx.cpid%TYPE;
    v_count       INT;
    v_kchzid      kc_kchz.kchzid%TYPE;
    v_isupdatehz  BOOLEAN := TRUE; --是否更新汇总表信息
    v_count       INT;
  BEGIN
    IF (p_wzmxid_in IS NULL )THEN
      raise_application_error(-20000, 'the p_wzmxid_in is null when saveGoods!');
    END IF;
    IF (p_operate_in = 'insert' OR p_operate_in = 'edit' OR p_operate_in = 'delete') THEN
      IF(p_operate_in <> 'delete') THEN
        IF (p_fgsid_in IS NULL) THEN
          raise_application_error(-20002, 'the p_fgsid_in is null when saveGoods!');
        END IF;
        IF (p_storeid_in IS NULL) THEN
          raise_application_error(-20003, 'the p_storeid_in is null when saveGoods!');
        END IF;
        IF (p_cpid_in IS NULL) THEN
          raise_application_error(-20004, 'the p_cpid_in is null when saveGoods!');
        END IF;
      END IF;
      --得到旧的数据
      BEGIN
        IF (p_operate_in = 'edit' OR p_operate_in = 'delete') THEN
          SELECT a.fgsid ,   a.storeid,      a.cpid,    a.kchzid
          INTO   v_old_fgsid, v_old_storeid, v_old_cpid, v_kchzid
          FROM   kc_wzmx a
          WHERE  a.wzmxid = p_wzmxid_in FOR UPDATE;
        END IF;
      EXCEPTION
        WHEN no_data_found THEN
          RETURN;
      END;
      --更新库存物资明细数据
      IF (p_operate_in = 'insert') THEN
        --提取库存汇总表id
        BEGIN
          SELECT h.kchzid INTO v_kchzid FROM kc_kchz h
          WHERE h.storeid=p_storeid_in AND h.cpid=p_cpid_in AND h.fgsid=p_fgsid_in
          FOR UPDATE;
        EXCEPTION
          WHEN no_data_found THEN
            v_isupdatehz := FALSE;
            SELECT s_kc_kchz.NEXTVAL INTO v_kchzid FROM dual;
            --插入库存汇总数据
            INSERT INTO kc_kchz(kchzid, storeid, cpid, sdsl, kcsl, fgsid)
            VALUES(v_kchzid, p_storeid_in, p_cpid_in, 0, p_sl_in, p_fgsid_in);
        END;
        --插入或更新数据到库存物资明细
        INSERT INTO kc_wzmx (wzmxid, cpid, rkdmxid, dmsxid, storeid, kwid,
          wjid, djxz, ph, zl, sdzl, bz, fgsid, kchzid)
        VALUES(p_wzmxid_in, p_cpid_in, p_rkdmxid_in, p_dmsxid_in, p_storeid_in, p_kwid_in,
          p_wjid_in, p_djxz_in, p_ph_id, p_sl_in, 0, p_bz_in, p_fgsid_in, v_kchzid);
      ELSIF (p_operate_in = 'edit') THEN
        UPDATE kc_wzmx
        SET cpid = p_cpid_in,    rkdmxid = p_rkdmxid_in,   dmsxid = p_dmsxid_in,
            storeid = p_storeid_in, kwid = p_kwid_in,      wjid = p_wjid_in,
            djxz = p_djxz_in,    ph = p_ph_id,             zl = zl + p_sl_in,
            bz = p_bz_in,        fgsid = p_fgsid_in
        WHERE wzmxid = p_wzmxid_in;
      ELSE
        DELETE FROM kc_wzmx a WHERE a.wzmxid = p_wzmxid_in;
      END IF;
      --更新 库存明细汇总 (kc_kchz)
      IF (v_isupdatehz) THEN
        --更行旧的汇总数据
        UPDATE kc_kchz b
        SET   b.kcsl = (SELECT nvl(SUM(zl),0) FROM kc_wzmx a WHERE a.kchzid = v_kchzid)
        WHERE b.kchzid = v_kchzid;
        --更新计划可供量
        --UPDATE kc_dm m SET m.jhkgl = nvl(m.jhkgl, 0) + p_sl_in
        --WHERE  m.cpid = p_cpid_in;
      END IF;
    ELSE
      raise_application_error(-20005, 'error p_operate_in when saveGoods!');
    END IF;
  END saveGoods;
  */
  /**
   * 更新库存货物库存数量（kc_wzmx）,如果不存就添加一条新的物资
   * @param  p_sl_in       IN INTEGER,                --重量
   * @param  p_hssl_in     IN INTEGER,                --换算数量
   * @param  p_fgsid_in    IN INTEGER,                --分公司id
   * @param  p_cpid_in     IN INTEGER,                --商品ID
   * @param  p_storeid_in  IN INTEGER,                --仓库ID
   * @param  p_kwid_in     IN INTEGER   DEFAULT NULL, --库位ID
   * @param  p_dmsxid_in   IN INTEGER   DEFAULT NULL, --物资规格属性ID
   * @param  p_ph_id       IN VARCHAR2 DEFAULT NULL, --批号
   * @param  p_dwtxid_in   IN INTEGER   DEFAULT NULL, --单位通讯ID
   * @param  p_wjid_in     IN INTEGER   DEFAULT NULL, --外键ID
   * @param  p_djxz_in     IN INTEGER   DEFAULT NULL, --单据性质
   * @param  p_bz_in       IN VARCHAR2 DEFAULT NULL  --备注
   ×@return 返回库存物资明细ID
   *
  FUNCTION addGoodsNum(
    p_sl_in       IN INTEGER,  --重量
    p_hssl_in     IN INTEGER,  --换算数量
    p_fgsid_in    IN INTEGER,  --分公司id
    p_cpid_in     IN INTEGER,  --商品ID
    p_storeid_in  IN INTEGER,  --仓库ID
    p_kwid_in     IN INTEGER,  --库位ID
    p_dmsxid_in   IN INTEGER,  --物资规格属性ID
    p_ph_id       IN VARCHAR2,--批号
    p_dwtxid_in   IN INTEGER,  --单位通讯ID
    p_wjid_in     IN INTEGER,  --外键ID
    p_djxz_in     IN INTEGER,  --单据性质
    p_bz_in       IN VARCHAR2 --备注
  ) RETURN NUMBER
  IS
    v_wzmxid      kc_wzmx.wzmxid%TYPE;    --库存物资明细ID
    v_kchzid      kc_kchz.kchzid%TYPE;
    v_totalsl     kc_kchz.kcsl%TYPE;
    v_totalhssl   kc_kchz.kchssl%TYPE;
    v_isadd       BOOLEAN;
  BEGIN
    IF (p_fgsid_in IS NULL) THEN
      raise_application_error(-20002, 'the p_fgsid_in is null when saveGoods!');
    END IF;
    IF (p_storeid_in IS NULL) THEN
      raise_application_error(-20003, 'the p_storeid_in is null when saveGoods!');
    END IF;
    IF (p_cpid_in IS NULL) THEN
      raise_application_error(-20004, 'the p_cpid_in is null when saveGoods!');
    END IF;
    --提取库存汇总表id并更新库存明细汇总 (kc_kchz)
    BEGIN
      SELECT h.kchzid INTO v_kchzid FROM kc_kchz h
      WHERE h.storeid=p_storeid_in AND h.cpid = p_cpid_in AND h.fgsid=p_fgsid_in
      AND ((p_dmsxid_in IS NOT NULL AND h.dmsxid = p_dmsxid_in) OR
           (p_dmsxid_in IS NULL AND h.dmsxid IS NULL))
      FOR UPDATE;
      --得到当前总数量
      SELECT nvl(SUM(nvl(zl,0)),0), nvl(SUM(nvl(hszl,0)),0) INTO v_totalsl, v_totalhssl
      FROM kc_wzmx a WHERE a.kchzid=v_kchzid;
      --
      UPDATE kc_kchz b
      SET   b.kcsl= v_totalsl+ p_sl_in, b.kchssl= v_totalhssl+ p_hssl_in
      WHERE b.kchzid = v_kchzid;
    EXCEPTION
      WHEN no_data_found THEN
        SELECT s_kc_kchz.NEXTVAL INTO v_kchzid FROM dual;
        --插入库存汇总数据
        INSERT INTO kc_kchz(kchzid, storeid, cpid, dmsxid,     sdsl, kcsl, hssdsl, kchssl, fgsid)
        VALUES(v_kchzid, p_storeid_in, p_cpid_in, p_dmsxid_in, 0, p_sl_in, 0,   p_hssl_in, p_fgsid_in);
    END;
    --插入或更新数据到库存物资明细
    BEGIN
      SELECT a.wzmxid, a.kchzid INTO v_wzmxid, v_kchzid
      FROM   kc_wzmx a
      WHERE  ((p_kwid_in IS NOT NULL AND a.kwid = p_kwid_in) OR (p_kwid_in IS NULL AND a.kwid IS NULL))
      AND    ((p_dmsxid_in IS NOT NULL AND a.dmsxid = p_dmsxid_in) OR (p_dmsxid_in IS NULL AND a.dmsxid IS NULL))
      AND    ((p_ph_id IS NOT NULL AND a.ph = p_ph_id) OR (p_ph_id IS NULL AND a.ph IS NULL))
      AND    a.fgsid = p_fgsid_in AND a.cpid = p_cpid_in AND a.storeid = p_storeid_in
      FOR UPDATE;
      v_isadd := FALSE;
      --2004.4.3 如果唯一索引相同的话,则只保留最后的供应商ID
      IF(p_dwtxid_in IS NOT NULL) THEN
        UPDATE kc_wzmx a
        SET    a.zl = nvl(a.zl,0) + p_sl_in, a.hszl = nvl(a.hszl,0) + p_hssl_in,
               a.dwtxid = p_dwtxid_in
        WHERE  a.wzmxid = v_wzmxid;
      ELSE
        UPDATE kc_wzmx a
        SET    a.zl = nvl(a.zl,0) + p_sl_in, a.hszl = nvl(a.hszl,0) + p_hssl_in
        WHERE  a.wzmxid = v_wzmxid;
      END IF;
    EXCEPTION
      WHEN no_data_found THEN
        v_isadd := TRUE;
        SELECT s_kc_wzmx.NEXTVAL INTO v_wzmxid FROM dual;
        --2004。4。3 不虚保存rkdmxid
        INSERT INTO kc_wzmx (wzmxid, cpid, dwtxid, dmsxid, storeid, kwid,
          wjid, djxz, ph, zl, sdzl, hszl, hssdzl,
          bz, fgsid, kchzid)
        VALUES(v_wzmxid, p_cpid_in, p_dwtxid_in, p_dmsxid_in, p_storeid_in, p_kwid_in,
          p_wjid_in, p_djxz_in, p_ph_id, p_sl_in, 0, p_hssl_in, 0,
          p_bz_in, p_fgsid_in, v_kchzid);
    END;
    RETURN v_wzmxid;
  END addGoodsNum;
  /**
   * 更新库存货物库存数量（kc_wzmx）
   * @param  p_wzmdxid_in  --库存物资明细ID
   * @param  p_add_sl_in   --重量(更新时表示增加或减少的)
   * @param  p_add_hssl_in --换算数量(更新时表示增加或减少的)
   *
  PROCEDURE updateGoodsNum(
    p_wzmxid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN NUMBER
  )IS
  BEGIN
    UPDATE kc_wzmx a
    SET    a.zl = nvl(a.zl,0) + p_add_sl_in, a.hszl = nvl(a.hszl, 0) + p_add_hssl_in
    WHERE  a.wzmxid = p_wzmxid_in;
    UPDATE kc_kchz b
    SET   b.kcsl = nvl(b.kcsl,0) + p_add_sl_in, b.kchssl = nvl(b.kchssl,0) + p_add_hssl_in
    WHERE b.kchzid = (SELECT a.kchzid FROM kc_wzmx a WHERE a.wzmxid = p_wzmxid_in);
  END updateGoodsNum;
  /**
   * 通过物资明细表（kc_wzmx）同步库存汇总信息
   *
  PROCEDURE syncStoreCollect IS
    v_kchzid kc_kchz.kchzid%TYPE;
  BEGIN
    UPDATE kc_wzmx SET kchzid = NULL;
    DELETE FROM kc_kchz;
    --
    FOR c_wz IN (
      SELECT a.storeid, a.cpid, a.dmsxid, a.fgsid, SUM(nvl(a.zl,0)) zsl FROM kc_wzmx a
      GROUP BY a.storeid, a.cpid, a.dmsxid, a.fgsid
    )
    LOOP
      SELECT s_kc_kchz.NEXTVAL INTO v_kchzid FROM dual;
      --插入库存汇总数据
      INSERT INTO kc_kchz(kchzid, storeid, cpid, dmsxid,     sdsl, kcsl, fgsid)
      VALUES (v_kchzid, c_wz.storeid, c_wz.cpid, c_wz.dmsxid, 0, c_wz.zsl, c_wz.fgsid);
      --
      UPDATE kc_wzmx a SET a.kchzid = v_kchzid
      WHERE  a.storeid=c_wz.storeid AND a.cpid=c_wz.cpid AND a.fgsid=c_wz.fgsid
      AND   ((c_wz.dmsxid IS NOT NULL AND a.dmsxid = c_wz.dmsxid) OR
             (c_wz.dmsxid IS NULL AND a.dmsxid IS NULL));
    END LOOP;
    --同步锁定量
    FOR c_td IN (
      SELECT t.storeid, h.cpid, h.dmsxid, t.fgsid, (SUM(nvl(h.sl,0))-SUM(nvl(h.stsl,0))) sdl
      FROM xs_td t, xs_tdhw h WHERE t.tdid=h.tdid AND nvl(h.sl,0)<>nvl(h.stsl,0)
      GROUP BY t.storeid, h.cpid, h.dmsxid, t.fgsid
    )
    LOOP
      UPDATE kc_kchz a SET a.sdsl = nvl(a.sdsl,0)- c_td.sdl
      WHERE  a.storeid=c_td.storeid AND a.cpid=c_td.cpid AND a.fgsid=c_td.fgsid
      AND   ((c_td.dmsxid IS NOT NULL AND a.dmsxid = c_td.dmsxid) OR
             (c_td.dmsxid IS NULL AND a.dmsxid IS NULL));
      IF(SQL%NOTFOUND) THEN
        INSERT INTO kc_kchz(kchzid, storeid, cpid, dmsxid,     sdsl,   kcsl, fgsid)
        VALUES (s_kc_kchz.NEXTVAL, c_td.storeid, c_td.cpid, c_td.dmsxid, c_td.sdl, 0, c_td.fgsid);
      END IF;
    END LOOP;
  END syncStoreCollect;
  */
  /**
   * 物资移库
   * @param  p_wzmxid_in  --物资明细ID
   * @param  p_sl_in  --增加或减少的数量
   * @param  p_hssl_in  --增加或减少的换算数量
   * @param  p_in_storeid_in  --移进仓库
   * @param  p_in_storeid_in  --移进库位
   *
  PROCEDURE goodsMoveStore(
    p_wzmxid_in     IN INTEGER,
    p_sl_in         IN INTEGER,
    p_hssl_in       IN INTEGER,
    p_in_storeid_in IN INTEGER,
    p_in_kwid_in    IN NUMBER
  ) IS
    v_cpid         kc_wzmx.cpid%TYPE;
    --v_out_storeid  kc_wzmx.storeid%TYPE;
    --v_out_kwid     kc_wzmx.kwid%TYPE;
    v_dmsxid       kc_wzmx.dmsxid%TYPE;
    v_ph           kc_wzmx.ph%TYPE;
    v_fgsid        kc_wzmx.fgsid%TYPE;
    --v_rkdmxid      kc_wzmx.rkdmxid%TYPE;
    v_djxz         kc_wzmx.djxz%TYPE;
    v_wjid         kc_wzmx.wjid%TYPE;
    v_bz           kc_wzmx.bz%TYPE;
    v_out_kchzid   kc_wzmx.kchzid%TYPE;
    v_in_kchzid    kc_wzmx.kchzid%TYPE;
    v_in_wzmxid    kc_wzmx.wzmxid%TYPE;
  BEGIN
    IF(p_wzmxid_in IS NULL) THEN
      raise_application_error(WZMXID_IS_NULL, '物资明细ID不能为空!');
    END IF;
    IF(p_sl_in = 0) THEN
      RETURN;
    END IF;
    --得到移出的物资信息
    SELECT k.cpid, k.dmsxid, k.ph, k.fgsid, k.kchzid, k.djxz, k.wjid, k.bz --k.rkdmxid,
    INTO   v_cpid, v_dmsxid, v_ph, v_fgsid, v_out_kchzid, v_djxz, v_wjid, v_bz --v_rkdmxid
    FROM   kc_wzmx k WHERE k.wzmxid = p_wzmxid_in
    FOR UPDATE;
    --更新移出的物资
    UPDATE kc_wzmx k SET k.zl = nvl(k.zl,0)-p_sl_in, k.hszl = nvl(k.hszl,0)-p_hssl_in
    WHERE k.wzmxid = p_wzmxid_in;
    UPDATE kc_kchz h SET h.kcsl = nvl(h.kcsl,0)-p_sl_in, h.kchssl = nvl(h.kchssl,0)-p_hssl_in
    WHERE h.kchzid = v_out_kchzid;
    --更新移入的物资
    BEGIN
      SELECT h.kchzid INTO v_in_kchzid FROM kc_kchz h
      WHERE ((v_dmsxid IS NULL AND h.dmsxid IS NULL) OR (v_dmsxid IS NOT NULL AND h.dmsxid=v_dmsxid))
      AND   h.storeid=p_in_storeid_in AND h.cpid=v_cpid AND h.fgsid=v_fgsid
      FOR UPDATE;
      UPDATE kc_kchz h SET h.kcsl = nvl(h.kcsl,0)+p_sl_in, h.kchssl = nvl(h.kchssl,0)+p_hssl_in
      WHERE h.kchzid = v_in_kchzid;
    EXCEPTION
      WHEN no_data_found THEN
        SELECT s_kc_kchz.NEXTVAL INTO v_in_kchzid FROM dual;
        --插入库存汇总数据
        INSERT INTO kc_kchz(kchzid, storeid, cpid, dmsxid,  sdsl, kcsl, hssdsl, kchssl, fgsid)
        VALUES(v_in_kchzid, p_in_storeid_in, v_cpid, v_dmsxid, 0,  p_sl_in,  0, p_hssl_in, v_fgsid);
    END;
    --
    BEGIN
      SELECT k.wzmxid INTO v_in_wzmxid FROM kc_wzmx k
      WHERE  k.fgsid = v_fgsid AND k.cpid = v_cpid AND k.storeid = p_in_storeid_in
      AND    ((p_in_kwid_in IS NOT NULL AND k.kwid = p_in_kwid_in) OR (p_in_kwid_in IS NULL AND k.kwid IS NULL))
      AND    ((v_dmsxid IS NOT NULL AND k.dmsxid = v_dmsxid) OR (v_dmsxid IS NULL AND k.dmsxid IS NULL))
      AND    ((v_ph IS NOT NULL AND k.ph = v_ph) OR (v_ph IS NULL AND k.ph IS NULL));
      UPDATE kc_wzmx k SET k.zl = nvl(k.zl,0)+p_sl_in, k.hszl=nvl(k.hszl,0)+p_hssl_in
      WHERE k.wzmxid = v_in_wzmxid;
    EXCEPTION
      WHEN no_data_found THEN
        SELECT s_kc_wzmx.NEXTVAL INTO v_in_wzmxid FROM dual;
        --插入数据到库存物资明细
        INSERT INTO kc_wzmx (wzmxid, cpid, dmsxid, storeid, kwid, --rkdmxid
          wjid, djxz, ph, zl, sdzl, hszl, hssdzl,
          bz, fgsid, kchzid)
        VALUES(v_in_wzmxid, v_cpid, v_dmsxid, p_in_storeid_in, p_in_kwid_in, --v_rkdmxid
          v_wjid, v_djxz, v_ph, p_sl_in, 0, p_hssl_in, 0,
          v_bz, v_fgsid, v_in_kchzid);
    END;
  END goodsMoveStore;
  /**
   * 更新销售货物锁定数量（kc_kchz）。开提单时候增加锁定量,出库时候减少锁定量
   * @param  p_wzmxid_in  --物资明细ID
   * @param  p_add_sl_in  --增加或减少的锁定数量
   * @param  p_add_hssl_in  --增加或减少的锁定数量
   *
  PROCEDURE updateSaleGoodsLock(
    p_wzmxid_in  IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_hssl_in  IN NUMBER
  ) IS
  BEGIN
    UPDATE kc_kchz a
    SET    a.sdsl = nvl(a.sdsl,0)+p_add_sl_in, a.hssdsl=nvl(a.hssdsl,0)+p_add_hssl_in
    WHERE  a.kchzid = (SELECT w.kchzid FROM kc_wzmx w WHERE w.wzmxid = p_wzmxid_in);
  END updateSaleGoodsLock;
  /**
   * 更新销售货物锁定数量（kc_kchz）。开提单时候增加锁定量,出库时候减少锁定量
   * @param  p_cpid_in    --产品ID
   * @param  p_dmsxid_in  --规格属性ID
   * @param  p_storeid_in --仓库ID
   * @param  p_fgsid_in   --分公司ID
   * @param  p_add_sl_in  --增加或减少的锁定数量
   * @param  p_add_hssl_in  --增加或减少的锁定数量
   *
  PROCEDURE updateSaleGoodsLock(
    p_cpid_in    IN INTEGER,
    p_dmsxid_in  IN INTEGER,
    p_storeid_in IN INTEGER,
    p_fgsid_in   IN INTEGER,
    p_add_sl_in  IN INTEGER,
    p_add_hssl_in  IN NUMBER
  ) IS
  BEGIN
    UPDATE kc_kchz a
    SET    a.sdsl = nvl(a.sdsl,0)+p_add_sl_in, a.hssdsl=nvl(a.hssdsl,0)+p_add_hssl_in
    WHERE  a.cpid = p_cpid_in AND a.storeid = p_storeid_in
    AND    ((p_dmsxid_in IS NOT NULL AND a.dmsxid=p_dmsxid_in) OR
            (p_dmsxid_in IS NULL AND a.dmsxid IS NULL))
    AND a.fgsid = p_fgsid_in
    ;
    --没有数据，则插入数据
    IF (SQL%NOTFOUND) THEN
      INSERT INTO kc_kchz(kchzid, storeid,    cpid, dmsxid,
                          kcsl, sdsl,    kchssl, hssdsl,        fgsid)
      VALUES(s_kc_kchz.NEXTVAL, p_storeid_in, p_cpid_in, p_dmsxid_in,
                          0, p_add_sl_in,     0, p_add_hssl_in, p_fgsid_in);
    END IF;
  END updateSaleGoodsLock;
  /**
   * 2004.2.28 锁定计划可供量的条件：产品id和规格属性id
   * 更新计划可供量(kc_dm）。生成计划时候减少计划可供量,自制入库单时候增加计划可供量
   * @param  p_cpid_in    --物资ID
   * @param  p_dmsx_id    --规格属性ID
   * @param  p_add_sl_in  --增加或减少的计划可供量
   *
  PROCEDURE updatePlanUsableGoods(
    p_cpid_in    IN INTEGER,
    p_dmsx_id    IN INTEGER,
    p_add_sl_in  IN NUMBER
  ) IS
  BEGIN
    UPDATE sc_jhkgl a
    SET    a.jhkgl = nvl(a.jhkgl,0) + p_add_sl_in
    WHERE  a.cpid = p_cpid_in AND (p_dmsx_id IS NULL OR a.dmsxid = p_dmsx_id);
    IF(SQL%NOTFOUND)THEN
      INSERT INTO sc_jhkgl(cpid, dmsxid, jhkgl)
      VALUES(p_cpid_in, p_dmsx_id, p_add_sl_in);
    END IF;
  END updatePlanUsableGoods;
  /**
   * 更新销售合同和提单的实出库量（xs_hthw, xs_tdhw）
   * @param  p_tdhwid_in  --提单货物ID
   * @param  p_cpid_in    --物资id
   * @param  p_add_sl_in  --增加或减少的实提数量
   * @param  p_add_hssl_in  --增加或减少的实提换算数量
   * @param  p_fgsid_in  --分公司id
   * @param  p_date_in  --出库日期
   */
  PROCEDURE updateSaleOutStoreNum(
    p_tdhwid_in   IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_fgsid_in    IN INTEGER,
    p_date_in     IN DATE
  ) IS
    v_tdid     xs_td.tdid%TYPE;
    v_zt       xs_td.zt%TYPE;
    v_xshthwid xs_hthw.hthwid%TYPE;
    v_xshtid   xs_hthw.htid%TYPE;
    --v_skdsl    xs_hthw.skdsl%TYPE;
    --v_skdhssl  xs_hthw.skdhssl%TYPE;
    v_param    VARCHAR2(32);
    v_count    INT;
    v_outcount INT; --已出库的记录数量
  BEGIN
    --更新提单的实提数量
    UPDATE xs_tdhw t
    SET t.stsl = nvl(t.stsl,0)+p_add_sl_in, t.sthssl = nvl(t.sthssl,0)+p_add_hssl_in
    WHERE t.tdhwid = p_tdhwid_in;
    SELECT t.tdid INTO v_tdid FROM xs_tdhw t WHERE t.tdhwid=p_tdhwid_in;
    SELECT d.zt   INTO v_zt   FROM xs_td d   WHERE d.tdid = v_tdid;
    --提单是否有出库的
    SELECT COUNT(*) INTO v_outcount FROM xs_tdhw t
    WHERE  (nvl(t.stsl,0)<>0 OR nvl(t.sthssl,0)<>0) AND t.tdid = v_tdid;
    --已出库状态
    IF(v_outcount > 0 AND (v_zt=1 OR v_zt=8)) THEN
      IF(v_zt=1) THEN
        UPDATE xs_td d SET d.zt=2 WHERE d.tdid = v_tdid;
      ELSIF(v_zt=8) THEN
        --提单没有全部出库的记录数
        SELECT COUNT(*) INTO v_count FROM xs_tdhw t
        WHERE  nvl(t.sl,0)<>nvl(t.stsl,0) AND nvl(t.hssl,0)<>nvl(t.sthssl,0)
        AND    t.tdid = v_tdid;
        IF(v_count > 0) THEN
          UPDATE xs_td d SET d.zt=2 WHERE d.tdid = v_tdid;
        END IF;
      END IF;
    --还原状态
    ELSIF(v_outcount = 0 AND (v_zt=2 OR v_zt=8)) THEN
      UPDATE xs_td d SET d.zt=1 WHERE d.tdid = v_tdid;
    END IF;
    --得到系统参数:
    --2=更改提单货物数量为出库数量并将数量全出库的已审单据的状态改为出库确认,
    --1=更改提单货物数量为出库数量
    v_param := pck_base.systemparam('KC_OUTSTORE_AUTO_BACK_MODE', p_fgsid_in);
    IF(v_param = '2' OR v_param = '1') THEN
      UPDATE xs_tdhw t SET t.sl = t.stsl, t.hssl = t.sthssl, t.ckrq=p_date_in,
        t.jje=t.stsl*t.dj, t.xsje=t.stsl*t.xsj
      WHERE  t.tdhwid = p_tdhwid_in;
      --
      IF(v_param = '2' AND v_zt=1) THEN
        --SELECT t.tdid INTO v_tdid FROM xs_tdhw t, xs_td d
        --WHERE  t.tdid = d.tdid AND d.zt=1 AND t.tdhwid=p_tdhwid_in;
        --提单是否已经全部出库了
        SELECT COUNT(*) INTO v_count FROM xs_tdhw t
        WHERE  nvl(t.sl,0)<>nvl(t.stsl,0) AND nvl(t.hssl,0)<>nvl(t.sthssl,0)
        AND    t.tdid = v_tdid;
        IF(v_count = 0) THEN
          UPDATE xs_td d SET d.zt=8 WHERE d.tdid = v_tdid;
        END IF;
      END IF;
    END IF;
    --得到合同货物id
    BEGIN
      SELECT h.hthwid, h.htid INTO v_xshthwid, v_xshtid
      FROM  xs_tdhw t, xs_hthw h
      WHERE t.hthwid=h.hthwid AND t.hthwid IS NOT NULL AND t.tdhwid = p_tdhwid_in;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;
    --更新合同的实际出库量
    /*SELECT nvl(SUM(CASE WHEN nvl(t.stsl,0)>0 THEN nvl(t.stsl,0) ELSE nvl(t.sl,0) END),0),
      nvl(SUM(CASE WHEN nvl(t.sthssl,0)>0 THEN nvl(t.sthssl,0) ELSE nvl(t.hssl,0) END),0)
    INTO v_skdsl, v_skdhssl
    FROM xs_tdhw t, xs_td m
    WHERE t.tdid=m.tdid AND m.zt<>0 AND m.zt<>9 AND t.hthwid = v_xshthwid;*/
    --
    UPDATE xs_hthw h
    SET h.stsl = nvl(h.stsl,0)+p_add_sl_in, h.sthssl = nvl(h.sthssl,0)+p_add_hssl_in
        --,h.skdsl = v_skdsl, h.skdhssl = v_skdhssl
    WHERE h.hthwid = v_xshthwid;
  END updateSaleOutStoreNum;
  /**
   * 更新采购合同和进货单的实入库量（cg_hthw, cg_htjhdhw)
   * @param  p_jhdhwid_in  --提单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实提数量
   * @param  p_add_hssl_in --增加或减少的实提换算数量
   * @param  p_ishssl_in   --是否是以换算数量为基本单位
   */
  PROCEDURE updateBuyInStoreNum(
    p_jhdhwid_in  IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  ) IS
    v_cgjhdid  cg_htjhd.jhdid%TYPE;
    v_zt       cg_htjhd.zt%TYPE;
    v_cghthwid cg_hthw.hthwid%TYPE;
    v_cghtid   cg_hthw.htid%TYPE;
    v_count    INT;
  BEGIN
    --更新进货单的实入库量
    UPDATE cg_htjhdhw t
    SET t.sjrkl = nvl(t.sjrkl,0)+p_add_sl_in, t.sjrkhsl = nvl(t.sjrkhsl,0)+p_add_hssl_in
    WHERE t.jhdhwid = p_jhdhwid_in;
    --2004.6.15 添加删除入库单后将入库确认的单据还原
    SELECT j.jhdid, j.zt INTO v_cgjhdid, v_zt
    FROM cg_htjhd j, cg_htjhdhw t WHERE j.jhdid=t.jhdid AND t.jhdhwid = p_jhdhwid_in;
    IF(v_zt = 8)THEN
      --提单没有入库出库的记录数
      SELECT COUNT(*) INTO v_count FROM cg_htjhdhw t
      WHERE  nvl(t.sl,0)<>nvl(t.sjrkl,0) AND nvl(t.hssl,0)<>nvl(t.sjrkhsl,0)
      AND    t.jhdid = v_cgjhdid;
      IF(v_count > 0) THEN
        UPDATE cg_htjhd d SET d.zt=1 WHERE d.jhdid = v_cgjhdid;
      END IF;
    END IF;
    --得到合同货物id
    BEGIN
      SELECT h.hthwid, h.htid  INTO v_cghthwid, v_cghtid
      FROM cg_htjhdhw t, cg_hthw h
      WHERE  t.hthwid=h.hthwid AND t.hthwid IS NOT NULL AND t.jhdhwid = p_jhdhwid_in;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;
    --更新合同的实入库量和合同的实提数量(根据采购报价方法)  1,已换算单位报价
    IF(p_ishssl_in) THEN
      UPDATE cg_hthw h
      SET h.sjrkl = nvl(h.sjrkl,0)+p_add_hssl_in
          --h.sjjhl = nvl(h.sjjhl,0)+p_add_hssl_in
          /*(SELECT nvl(SUM(CASE WHEN nvl(t.sjrkhsl,0)>0 THEN nvl(t.sjrkhsl,0)
                                    ELSE nvl(t.hssl,0) END),0)
                     FROM cg_htjhdhw t, cg_htjhd m
                     WHERE t.jhdid = m.jhdid AND m.zt=1 AND t.hthwid = v_cghthwid)*/
      WHERE h.hthwid = v_cghthwid;
    ELSE
      UPDATE cg_hthw h
      SET h.sjrkl = nvl(h.sjrkl,0)+p_add_sl_in
          --h.sjjhl = nvl(h.sjjhl,0)+p_add_sl_in
          /*(SELECT nvl(SUM(CASE WHEN nvl(t.sjrkl,0)>0 THEN nvl(t.sjrkl,0)
                                    ELSE nvl(t.sl,0) END),0)
                     FROM cg_htjhdhw t, cg_htjhd m
                     WHERE t.jhdid = m.jhdid AND m.zt=1 AND t.hthwid = v_cghthwid)*/
      WHERE h.hthwid = v_cghthwid;
    END IF;
    --更新合同的状态
    /*UPDATE cg_ht m SET m.zt = 8
    WHERE (SELECT COUNT(*) FROM cg_hthw h WHERE nvl(h.sl,0)>nvl(h.sjrkl,0) AND h.htid = v_cghtid)=0
    AND   m.htid = v_cghtid;*/
  END updateBuyInStoreNum;
  /**
   * 更新进货单的实开票数量（cg_htjhdhw)
   * @param  p_jhdhwid_in  --采购进货单货物ID
   * @param  p_cpid_in     --物资id
   * @param  p_add_sl_in   --增加或减少的实开票数量
   * @param  p_ishssl_in   --采购的单位是否用换算单位
   */
  PROCEDURE updateBuyInvoiceNum(
    p_jhdhwid_in  IN INTEGER,
    p_cpid_in      IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  ) IS
    v_hsbl kc_dm.hsbl%TYPE;
  BEGIN
    IF(p_cpid_in IS NULL) THEN
      raise_application_error(-20000, 'p_cpid_in is null!');
    END IF;
    BEGIN
      SELECT nvl(k.hsbl,0) INTO v_hsbl FROM kc_dm k WHERE k.cpid = p_cpid_in;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20001, '不存在的该产品!');
    END;
    IF(v_hsbl = 0) THEN
      v_hsbl := 1;
    END IF;
    --
    IF(p_ishssl_in) THEN
      UPDATE cg_htjhdhw h
      SET h.skpsl = nvl(h.skpsl,0)  + p_add_sl_in/v_hsbl,
          h.skphsl = nvl(h.skphsl,0)+ p_add_sl_in
      WHERE h.jhdhwid = p_jhdhwid_in;
    ELSE
      UPDATE cg_htjhdhw h
      SET h.skpsl = nvl(h.skpsl,0)  + p_add_sl_in,
          h.skphsl = nvl(h.skphsl,0)+ p_add_sl_in*v_hsbl
      WHERE h.jhdhwid = p_jhdhwid_in;
    END IF;
  END updateBuyInvoiceNum;
  /**
   * 更新销售提单的实开票数量（xs_tdhw)
   * @param  p_tdhwid_in  --采购进货单货物ID
   * @param  p_add_sl_in   --增加或减少的实开票数量
   */
  PROCEDURE updateLadingInvoiceNum(
    p_tdhwid_in  IN INTEGER,
    p_add_sl_in   IN NUMBER
  ) IS
  BEGIN
    --
    UPDATE xs_tdhw h
    SET h.skpsl = nvl(h.skpsl,0) + p_add_sl_in
    WHERE h.tdhwid = p_tdhwid_in;
  END updateLadingInvoiceNum;
  /**
   * 更新销售合同的实提单数量（xs_httd)
   * @param  p_hthwid_in   --销售合同货物ID
   * @param  p_add_sl_in   --增加或减少的提单数量
   * @param  p_add_hssl_in --增加或减少的实提单换算数量
   * @param  p_isover_in   --是否结束
   */
  PROCEDURE updateSaleOrderLadingNum(
    p_hthwid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_isover_in   IN BOOLEAN DEFAULT FALSE
  ) IS
    v_skdsl   xs_hthw.skdsl%TYPE;
    v_skdhssl xs_hthw.skdhssl%TYPE;
  BEGIN
    IF(NOT p_isover_in) THEN
      UPDATE xs_hthw h
      SET h.skdsl   = nvl(h.skdsl,0)  + p_add_sl_in,
          h.skdhssl = nvl(h.skdhssl,0)+ p_add_hssl_in
      WHERE h.hthwid = p_hthwid_in;
    /*--得到合同货物id
    BEGIN
      SELECT h.hthwid, h.htid INTO v_xshtid
      FROM  xs_tdhw t, xs_hthw h
      WHERE t.hthwid=h.hthwid AND t.hthwid IS NOT NULL AND t.tdhwid = p_tdhwid_in;
    EXCEPTION
      WHEN no_data_found THEN
        RETURN;
    END;*/
    ELSE
      --更新合同的实开提单数量
      SELECT nvl(SUM(nvl(t.stsl,0)),0), nvl(SUM(nvl(t.sthssl,0)),0)
      INTO v_skdsl, v_skdhssl
      FROM xs_tdhw t, xs_td m
      WHERE t.tdid=m.tdid AND m.zt<>0 AND m.zt<>9 AND t.hthwid = p_hthwid_in;
      --
      UPDATE xs_hthw h
      SET   h.skdsl = v_skdsl, h.skdhssl = v_skdhssl
      WHERE h.hthwid = p_hthwid_in;
    END IF;
    /*更新合同的状态
    UPDATE xs_ht m SET m.zt = 8
    WHERE (SELECT COUNT(*) FROM xs_hthw h WHERE nvl(h.sl,0)>nvl(h.stsl,0) AND h.htid = v_xshtid)=0
    AND   m.htid = v_xshtid;*/
  END updateSaleOrderLadingNum;
  /**
   * 更新采购合同的实进货单单数量（cg_htjhdhw)
   * @param  p_tdhwid_in   --采购合同货物ID
   * @param  p_add_sl_in   --增加或减少的进货单数量
   * @param  p_add_hssl_in --增加或减少的进货单换算数量
   * @param  p_ishssl_in   --采购的单位是否用换算单位
   */
  PROCEDURE updateBuyOrderInNum(
    p_hthwid_in   IN INTEGER,
    p_add_sl_in   IN INTEGER,
    p_add_hssl_in IN INTEGER,
    p_ishssl_in   IN BOOLEAN
  ) IS
  BEGIN
      --更新合同的实入库量和合同的实提数量(根据采购报价方法)  1,已换算单位报价
    IF(p_ishssl_in) THEN
      UPDATE cg_hthw h
      SET h.sjjhl = nvl(h.sjjhl,0)+p_add_hssl_in
      WHERE h.hthwid = p_hthwid_in;
    ELSE
      UPDATE cg_hthw h
      SET h.sjjhl = nvl(h.sjjhl,0)+p_add_sl_in
      WHERE h.hthwid = p_hthwid_in;
    END IF;
  END updateBuyOrderInNum;
  /**
   * 更新客户的历史产品记录（xs_khcpzk)
   * @param  p_dwtxid_in --往来单位id
   * @param  p_cpid_in   --产品id
   * @param  p_dmsx_in   --规格属性id
   * @param  p_zk_in     --折扣
   * @param  p_dj_in     --单价
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE updateCustHistoryProd(
    p_dwtxid_in   IN INTEGER,
    p_cpid_in     IN INTEGER,
    p_dmsx_in     IN INTEGER,
    p_zk_in       IN INTEGER,
    p_dj_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  ) IS
  BEGIN
    UPDATE xs_khcpzk k SET k.zk = p_zk_in, k.dj = p_dj_in
    WHERE  k.fgsid=p_fgsid_in AND k.dwtxid=p_dwtxid_in
    AND k.cpid=p_cpid_in AND (k.dmsxid=p_dmsx_in OR k.dmsxid IS NULL);
    IF(SQL%NOTFOUND)THEN
      INSERT INTO xs_khcpzk(cpid, dmsxid, dwtxid, fgsid, dj, zk)
      VALUES(p_cpid_in, p_dmsx_in, p_dwtxid_in, p_fgsid_in, p_dj_in, p_zk_in);
    END IF;
  END updateCustHistoryProd;
  /**
   * 更新客户的信誉度（xs_khxyed)
   * @param  p_dwtxid_in --往来单位id
   * @param  p_je_in     --折扣
   * @param  p_fgsid_in  --分公司id
   *
  PROCEDURE updateCustCreditNum(
    p_dwtxid_in   IN INTEGER,
    p_je_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  ) IS
  BEGIN
    UPDATE xs_khxyed k SET k.xysdl = nvl(k.xysdl,0) + p_je_in
    WHERE  k.fgsid=p_fgsid_in AND k.dwtxid=p_dwtxid_in;
    IF(SQL%NOTFOUND)THEN
      INSERT INTO xs_khxyed(xyedid, dwtxid, fgsid, xysdl)
      VALUES(s_xs_khxyed.NEXTVAL, p_dwtxid_in, p_fgsid_in, p_je_in);
    END IF;
  END updateCustCreditNum;
  /**
   * 根据提单更新客户的应收款（xs_khxyed)
   * @param  p_dwtxid_in --往来单位id
   * @param  p_je_in     --金额
   * @param  p_fgsid_in  --分公司id
   *
  PROCEDURE updateCustReceivableAccount(
    p_dwtxid_in   IN INTEGER,
    p_je_in       IN INTEGER,
    p_fgsid_in    IN NUMBER
  ) IS
  BEGIN
    UPDATE xs_khxyed k SET k.ysk = nvl(k.ysk,0) + p_je_in
    WHERE  k.fgsid=p_fgsid_in AND k.dwtxid=p_dwtxid_in;
    IF(SQL%NOTFOUND)THEN
      INSERT INTO xs_khxyed(xyedid, dwtxid, fgsid, ysk)
      VALUES(s_xs_khxyed.NEXTVAL, p_dwtxid_in, p_fgsid_in, p_je_in);
    END IF;
  END updateCustReceivableAccount;*/
  -----------------------------------------------------------------------------
  -- 月结有关
  -----------------------------------------------------------------------------
  /**
   * 库存年度月结(如果是第一次月结需要床迦氍最早单据的日期)
   * @param  p_year_in   --年份
   * @param  p_month_in  --月份
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE doMonthBalance(
    p_year_in   IN INTEGER,
    p_month_in  IN INTEGER,
    p_fgsid_in  IN NUMBER
  ) IS
    v_rq    jc_yjrq.rq%TYPE;
    v_sfyj  kc_yj.sfyj%TYPE;
    v_prev_year  INTEGER;
    v_prev_month INTEGER;
    v_startDate DATE;
    v_endDate   DATE;
    v_count     INT;
    v_needinsert BOOLEAN := FALSE;
    --v_isFirst   BOOLEAN :=FALSE;
  BEGIN
    /*--是否是第一次
    SELECT COUNT(*) INTO v_count FROM kc_yj y
    IF(v_count=0)THEN
      v_isFirst = TRUE;
      SELECT MIN(d.sfrq) INTO v_startDate FROM kc_sfdj d ;
      IF()
    END IF;*/
    --加行锁
    BEGIN
      SELECT nvl(r.rq,0) INTO v_rq FROM jc_yjrq r WHERE r.yf = p_month_in FOR UPDATE;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(MONTH_BALANCE_NO_DEFINE, '月结的月份日期没有定义！');
    END;
    --判断本月是否已经月结
    SELECT COUNT(*) INTO v_count FROM kc_yj y
    WHERE y.sfyj=1 AND y.nf=p_year_in AND y.yf=p_month_in AND y.fgsid=p_fgsid_in;
    IF(v_count > 0) THEN
      RETURN;
    END IF;
    --判断上个月是否已经月结
    SELECT COUNT(*) INTO v_count FROM kc_yj y;
    IF(v_count > 1) THEN
      --v_needinsert := TRUE;
      IF(p_month_in>1)THEN
        v_prev_year := p_year_in;
        v_prev_month := p_month_in-1;
      ELSE
        v_prev_year := p_year_in-1;
        v_prev_month := 12;
      END IF;
      BEGIN
        SELECT y.sfyj INTO v_sfyj FROM kc_yj y
        WHERE y.nf=v_prev_year AND y.yf=v_prev_month AND y.fgsid=p_fgsid_in;
        IF(v_sfyj <> 1) THEN
          raise_application_error(BEFORE_MONTH_NO_BALANCE, '上个月还没月结,不能月结！');
        END IF;
      EXCEPTION
        WHEN no_data_found THEN
          NULL;
      END;
    END IF;
    --得到月结的开始日期和结束日期
    IF(v_rq <= 0) THEN
      v_startDate := to_date(p_year_in||'-'||p_month_in||'-01','YYYY-MM-DD');
      v_endDate   := to_date(p_year_in||'-'||(p_month_in+1)||'-01','YYYY-MM-DD')-1;
    ELSE
      v_startDate := to_date(p_year_in||'-'||(p_month_in-1)||'-'||(v_rq+1),'YYYY-MM-DD');
      v_endDate   := to_date(p_year_in||'-'||p_month_in||'-'||v_rq,'YYYY-MM-DD');
    END IF;
    --判断是否还有未记帐的单据
    SELECT COUNT(*) INTO v_count FROM vw_kc_storebill_mast a
    WHERE a.zt NOT IN (2,8) --AND a.sfrq >= v_startDate
    AND a.sfrq <= v_enddate AND a.fgsid = p_fgsid_in;
    IF(v_count > 0)THEN
      raise_application_error(HAVE_UNAPPROVE_BILL, '还有未记帐的单据,不能月结！');
    END IF;
    UPDATE kc_sfdj t1 SET t1.zt=8
    WHERE /*t1.sfrq >= v_startDate AND*/ t1.sfrq <= v_enddate
    AND   t1.fgsid = p_fgsid_in AND t1.zt<>8;
    UPDATE sc_receiveprod t2 SET t2.state=8
    WHERE /*t2.receivedate >= v_startDate AND*/ t2.receivedate <= v_enddate
    AND   t2.filialeid = p_fgsid_in AND t2.state<>8;
    UPDATE sc_drawmaterial t3 SET t3.state=8
    WHERE /*t3.drawdate >= v_startDate AND*/ t3.drawdate <= v_enddate
    AND   t3.filialeid = p_fgsid_in AND t3.state<>8;
    --计算原材料
    calcMaterialPrice(p_year_in, p_month_in, v_startDate, v_enddate, p_fgsid_in);
    /*--插入上月的结存数据
    DELETE FROM kc_kcnjc_tmp;
    IF(v_needinsert) THEN
      INSERT INTO kc_kcnjc_tmp(cpid, sysl, ssl, fsl, jcsl, sydj,  jcdj,   syje, sje, fje, jcje)
      SELECT                 k.cpid, k.jcsl, 0,   0,    0, k.jcdj,NULL, k.jcje,   0,   0,   0
      FROM   kc_kcnjc k WHERE (k.jcsl<>0 OR k.jcje<>0) AND k.nf=v_prev_year AND k.yf=v_prev_month;
    END IF;
    --计算外购件加权平均价
    --1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单
    FOR c_mx IN (
      SELECT a.cpid, b.cpid jccpid, (a.zsl-nvl(b.sysl,0)) zsl, (a.zje-nvl(b.syje,0)) zje
      FROM
      (
        SELECT jd.cpid, SUM(nvl(jd.sl,0)) zsl, SUM(nvl(jd.je,0)) zje
        FROM kc_sfdj jm, kc_sfdjmx jd
        WHERE jm.sfdjid=jd.sfdjid AND jd.cpid IS NOT NULL AND jm.sfrq>=v_startDate
        AND jm.sfrq<=v_endDate AND jd.djxz=1 AND jm.fgsid=p_fgsid_in GROUP BY jd.cpid
      ) a, kc_kcnjc_tmp b
      WHERE a.cpid=b.cpid(+)
    )
    LOOP
      IF(c_mx.jccpid IS NULL) THEN
        INSERT INTO kc_kcnjc_tmp(cpid, sysl, ssl,    fsl, jcsl, sydj, jcdj, syje,
                                                sje, fje, jcje)
        VALUES(            c_mx.cpid,     0, c_mx.zsl, 0,    0,    0, NULL,    0,
          decode(c_mx.zsl, 0, 0, c_mx.zje/c_mx.zsl),   0,    0);
      ELSE
        UPDATE kc_kcnjc_tmp t
        SET t.ssl=c_mx.zsl, t.sje=c_mx.zje, t.jcdj=decode(c_mx.zsl, 0, 0, c_mx.zje/c_mx.zsl)
        WHERE  t.cpid=c_mx.cpid;
      END IF;
      --更新收发单据的单价
      UPDATE kc_sfdjmx jd SET jd.dj=decode(c_mx.zsl, 0, 0, c_mx.zje/c_mx.zsl),
        jd.je=decode(c_mx.zsl, 0, 0, jd.sl*c_mx.zje/c_mx.zsl)
      WHERE jd.cpid = c_mx.cpid AND jd.fgsid = p_fgsid_in;
    END LOOP;
    --
    calculateCost(v_startdate, v_enddate, p_fgsid_in);
    --
    INSERT INTO kc_kcnjc(nf, yf,    cpid,   sysl, ssl, fsl, jcsl,   sydj, jcdj,   syje, sje, fje, jcje, fgsid)
    SELECT p_year_in, p_month_in, t.cpid, t.jcsl,   0,   0,    0, t.jcdj,    0, t.jcje,   0,   0,    0, p_fgsid_in
    FROM   kc_kcnjc_tmp t;
    */
  END doMonthBalance;
 ----------------------------------------------------------------
  /**
   * 计算制造成本
   * @param  p_year_in   --年份
   * @param  p_month_in  --月份
   * @param  p_fgsid_in  --分公司id
   */
  PROCEDURE calculateCost(
    p_startDate_in IN DATE,
    p_endDate_in   IN DATE,
    p_fgsid_in     IN NUMBER
  ) IS
    v_costprice kc_kcnjc.jcdj%TYPE;
  BEGIN
    --1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单
      --自制入库单数据
    INSERT INTO kc_cb_tmp(jgcpid, clcpid, clsl)
    SELECT a.jgcpid, b.clcpid, decode(a.jgsl,0,0, b.clsl/a.jgsl)
    FROM
    (
      SELECT jd.cpid jgcpid, nvl(jd.sl,0) jgsl, jd.wjid jgdmxid
      FROM   kc_sfdj jm, kc_sfdjmx jd
      WHERE  jm.sfdjid=jd.sfdjid AND jd.cpid IS NOT NULL AND jm.sfrq>=p_startDate_in
      AND    jm.sfrq<=p_endDate_in AND jm.fgsid=p_fgsid_in AND jd.djxz=3
    ) a,
    --生产领料单数据
    (
      SELECT jd.cpid clcpid, nvl(jd.sl,0) clsl, jd.wjid jgdmxid
      FROM   kc_sfdj jm, kc_sfdjmx jd
      WHERE  jm.sfdjid=jd.sfdjid AND jd.cpid IS NOT NULL AND jm.sfrq>=p_startDate_in
      AND    jm.sfrq<=p_endDate_in AND jm.fgsid=p_fgsid_in AND jd.djxz=4
    ) b
    WHERE a.jgdmxid=b.jgdmxid;
    --得到成本价
    FOR c_mx IN ( SELECT DISTINCT t.jgcpid FROM kc_cb_tmp t )
    LOOP
      v_costprice := getProductCostPrice(c_mx.jgcpid, p_fgsid_in, 0);
    END LOOP;
  END calculateCost;
  /**
   * 计算半成品,成品成本
   * @param  p_jgcpid_in   --加工材料id
   * @param  p_fgsid_in  --分公司id
   * @param  p_level_in    --递归级数
   */
  FUNCTION getProductCostPrice(
    p_jgcpid_in  IN INTEGER,
    p_fgsid_in   IN INTEGER,
    p_level_in   IN INT DEFAULT 0
  ) RETURN NUMBER
  IS
    v_costprice kc_kcnjc.jcdj%TYPE := 0;
  BEGIN
    IF(p_level_in > 20) THEN
      RETURN 0;
    END IF;
    --1=合同入库单,2=销售出库单,3=自制入库单,4=生产领料单,5=外加工入库单,6=外加工发料单,7=报损单,8=移库单
    --得到该产品的加工单对应的领料单的产品
    FOR c_mx IN (
      SELECT t.clcpid, t.clsl, k.jcdj FROM kc_cb_tmp t, kc_kcnjc_tmp k
      WHERE  t.clcpid = k.cpid(+) AND t.jgcpid = p_jgcpid_in
    )
    LOOP
      IF(c_mx.jcdj IS NOT NULL) THEN
        v_costprice := v_costprice + c_mx.clsl*c_mx.jcdj;
      ELSE
        v_costprice := v_costprice + c_mx.clsl*getProductCostPrice(c_mx.clcpid, p_fgsid_in, p_level_in+1);
      END IF;
    END LOOP;
    --更新结存单价数据
    UPDATE kc_kcnjc_tmp k SET k.jcdj=v_costprice WHERE k.cpid = p_jgcpid_in;
    --更新收发单据的单价
    UPDATE kc_sfdjmx jd
    SET jd.dj=v_costprice, jd.je=jd.sl*v_costprice
    WHERE jd.cpid = p_jgcpid_in AND jd.fgsid = p_fgsid_in;
    --
    RETURN v_costprice;
  END getProductCostPrice;

  /**
   * 计算原材料单价(大发用)
   * @param  p_jgcpid_in   --加工材料id
   * @param  p_fgsid_in  --分公司id
   * @param  p_level_in    --递归级数
   */
  PROCEDURE calcMaterialPrice(

    p_year_in      IN INTEGER,
    p_month_in      IN INTEGER,
    p_startDate_in IN DATE,
    p_endDate_in   IN DATE,
    p_fgsid_in     IN NUMBER
  )
  IS
    v_prev_year  INTEGER;
    v_prev_month INTEGER;
    v_jcsl       kc_kcnjc.jcsl%TYPE;
    v_jcdj       kc_kcnjc.jcdj%TYPE;
    v_jcje       kc_kcnjc.jcje%TYPE;
    v_sysl       kc_kcnjc.sysl%TYPE;
    v_syje       kc_kcnjc.syje%TYPE;

  BEGIN
   IF(p_month_in>1)THEN
        v_prev_year := p_year_in;
        v_prev_month := p_month_in-1;
     ELSE
        v_prev_year := p_year_in-1;
        v_prev_month := 12;
    END IF;
    --1.插入上月的结存
    INSERT INTO kc_kcnjc (fgsid,storeid,dmsxid,cpid, sysl, ssl, fsl, jcsl, sydj,  jcdj,   syje, sje, fje, jcje, nf, yf)
    SELECT        k.fgsid,k.storeid,k.dmsxid,k.cpid, k.jcsl, 0, 0, k.jcsl, k.jcdj,k.jcdj, k.jcje, 0, 0,k.jcje, p_year_in, p_month_in
    FROM   kc_kcnjc k WHERE  k.nf=v_prev_year AND k.yf=v_prev_month;
    --2.插入或更新本月收入
    FOR c_mx IN (
      SELECT storeid, fgsid, cpid, dmsxid,
      SUM(nvl(srsl,0)) srsl,
      SUM(nvl(srje,0)) srje,
      SUM(nvl(jsrsl,0)) jsrsl,--净收入数量（包括进损溢单和移库单）

      SUM(nvl(jfcsl,0)) jfcsl


      FROM
      (
        --1=合同入库单
        SELECT a.storeid, a.fgsid, b.cpid, b.dmsxid, b.sl srsl, c.dj dj,  (c.dj*b.sl) srje,b.sl jsrsl,NULL jfcsl
        FROM   kc_sfdj a, kc_sfdjmx b, cg_htjhdhw c
        WHERE  a.sfdjid=b.sfdjid AND b.wjid=c.jhdhwid--1=合同入库单
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in
        AND    a.djxz=1
        -- 9=其他入库单
        UNION ALL
        SELECT a.storeid, a.fgsid, b.cpid, b.dmsxid, b.sl srsl,  b.dj dj,         b.je srje,b.sl jsrsl,NULL jfcsl
        FROM   kc_sfdj a, kc_sfdjmx b
        WHERE  a.sfdjid=b.sfdjid
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in
        AND    a.djxz=9-- 9=其他入库单
            --（销售出库单,其他出库单）
        UNION ALL
        SELECT  a.storeid, a.fgsid,b.cpid,b.dmsxid,   NULL srsl,  NULL dj,         NULL srje, NULL jsrsl,b.sl jfcsl
           --dafa

        FROM   kc_sfdj a, kc_sfdjmx b
        WHERE  a.sfdjid=b.sfdjid AND a.djxz IN(2,10)
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in
        --(3=自制收货单5=外加工入库单)
        UNION ALL
        SELECT a1.storeid,a1.filialeid,b1.cpid,b1.dmsxid,NULL srsl,null dj ,null srje,b1.drawnum jsrsl,null jfcsl
        --dafa

        FROM   sc_receiveprod a1, sc_receiveproddetail b1
        WHERE  a1.receiveid = b1.receiveid
        AND    a1.receivedate >= p_startDate_in AND a1.receivedate <= p_endDate_in
        --4=生产领料单, 6=外加工发料单
        UNION ALL
        SELECT  a2.storeid, a2.filialeid fgsid,b2.cpid,b2.dmsxid, NULL srsl,NULL dj,NULL srje,NULL jsrsl,b2.drawnum jfcsl

        FROM   sc_drawmaterial a2, sc_drawmaterialdetail b2
        WHERE  a2.drawid = b2.drawid
        AND    a2.drawdate >= p_startDate_in AND a2.drawdate <= p_endDate_in
        --(-1 调入)
        --得到该段时间移库单调入数量--kc__storeid 调入仓库, kc__kwid 调入库位id
        UNION ALL
        SELECT a.kc__storeid storeid, a.fgsid,b.cpid,b.dmsxid, NULL srsl,NULL dj,    NULL srje,b.sl jsrsl, NULL jfcsl
        FROM   kc_sfdj a, kc_sfdjmx b
        WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in
        --得到该段时间移库单调出数量 (8 调出)
        UNION ALL
        SELECT a.storeid, a.fgsid,b.cpid,b.dmsxid, NULL srsl,    NULL dj,            NULL srje,NULL jsrsl,b.sl jfcsl
        FROM   kc_sfdj a, kc_sfdjmx b
        WHERE  a.sfdjid=b.sfdjid AND a.djxz = 8
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in
        -- 7=损溢单
        UNION ALL

        SELECT a.storeid, a.fgsid,b.cpid,b.dmsxid,  NULL srsl,   NULL dj,             NULL srje,b.sl jsrsl, NULL jfcsl
        FROM   kc_sfdj a, kc_sfdjmx b
        WHERE  a.sfdjid=b.sfdjid AND a.djxz=7
        AND    a.sfrq >= p_startDate_in AND a.sfrq <= p_endDate_in


      ) p
      GROUP BY storeid, fgsid, cpid, dmsxid
    )
    LOOP
      BEGIN
        SELECT nvl(k.sysl,0), nvl(k.syje,0) INTO v_sysl, v_syje
        FROM kc_kcnjc k
        WHERE  k.cpid=c_mx.cpid AND k.nf=p_year_in AND k.yf=p_month_in
        AND    k.fgsid=c_mx.fgsid AND k.storeid=c_mx.storeid
        AND    ((c_mx.dmsxid IS NULL AND k.dmsxid IS NULL) OR (c_mx.dmsxid IS NOT NULL AND k.dmsxid=c_mx.dmsxid));
      EXCEPTION
        WHEN no_data_found THEN
          v_sysl :=0;
          v_syje :=0;

          INSERT INTO kc_kcnjc (cpid, storeid, fgsid,dmsxid, fsl,fje,ssl,sje,
                                nf,yf,sysl,sydj,syje)
          VALUES(c_mx.cpid,c_mx.storeid,c_mx.fgsid,c_mx.dmsxid, 0, 0,0,0,
                p_year_in, p_month_in, 0,  0,   0);
      END;
      --ji suan jie cun
      IF((v_sysl+c_mx.srsl)<>0) THEN
        v_jcdj := (v_syje+c_mx.srje)/(v_sysl+c_mx.srsl);

      ELSE
        v_jcdj := 0;
      END IF;
      v_jcsl := v_sysl + c_mx.jsrsl-c_mx.jfcsl;

      v_jcje := v_syje+pck_base.formartnumber(v_jcdj*c_mx.jsrsl)-pck_base.formartnumber(v_jcdj*c_mx.jfcsl);

      UPDATE kc_kcnjc k
      SET k.ssl  = c_mx.jsrsl,  k.sje = pck_base.formartnumber(v_jcdj*c_mx.jsrsl),k.fsl=c_mx.jfcsl,k.fje=pck_base.formartnumber(v_jcdj*c_mx.jfcsl),
          k.jcsl = v_jcsl,     k.jcdj= v_jcdj,
          k.jcje = v_jcje
      WHERE  k.cpid=c_mx.cpid AND k.nf=p_year_in AND k.yf=p_month_in
      AND    k.fgsid=c_mx.fgsid AND k.storeid=c_mx.storeid
      AND    ((c_mx.dmsxid IS NULL AND k.dmsxid IS NULL) OR (c_mx.dmsxid IS NOT NULL AND k.dmsxid=c_mx.dmsxid));
    END LOOP;

    END calcMaterialPrice;
     ----------------------------------------------------------------
  PROCEDURE kc_year_checkout(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,  --日期
    p_fgsid_in   IN VARCHAR2     --分公司id
    )
  IS
    v_start DATE;
    v_end   DATE;
    v_middle   DATE;
    v_checkid jc_checkout.checkid%TYPE;
    v_new_checkid jc_checkout.checkid%TYPE;
    v_count int;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD')-1;
    v_new_checkid :=-1;

    select count(*) into v_count from vw_kc_storebill t where t.zt<>2 and t.zt<>8 and t.sfrq<=v_start;
    if(v_count<>0)then
      OPEN p_data_out FOR
      SELECT '1' AS resultCode, '有未记帐的单据' AS resultCap FROM dual;
      RETURN;
    end if;

    --得到上期年结
      select max(t.checkid)checkid into v_checkid from jc_checkout t where t.jsrq<=v_start;
    if(v_checkid is not null and v_checkid<>'')then
      select t.jsrq into v_middle from jc_checkout t where t.checkid=v_checkid;
    else
      v_middle := to_date('1900-1-1', 'YYYY-MM-DD');
    end if;



    if(v_middle is not null )then
    FOR cc_lc IN (
        select t.storeid,t.deptid,t.cpid,t.fgsid,sum(nvl(t.srsl,0))srsl,
        sum(nvl(t.srhssl,0))srhssl,sum(nvl(t.fcsl,0))fcsl,
        sum(nvl(t.fchssl,0))fchssl
        from vw_kc_storebill t where t.sfrq>v_middle and
                                     t.sfrq<=v_start and
                                     t.zt in(2,8)
        group by t.storeid,t.deptid,t.cpid,t.fgsid
    )
    LOOP

      IF(v_new_checkid< 0) THEN
        select s_jc_checkout.nextval into v_new_checkid from dual;
        insert into jc_checkout(checkid,jsrq) values(v_new_checkid,v_start);
      END IF;

      insert into jc_checkdetail(checkmxid,checkid,storeid,deptid,cpid,fgsid,srsl,srhssl,fcsl,fchssl)
                  values(s_jc_checkdetail.nextval,v_new_checkid,cc_lc.storeid,cc_lc.deptid,cc_lc.cpid,cc_lc.fgsid,cc_lc.srsl,cc_lc.srhssl,cc_lc.fcsl,cc_lc.fchssl);

    END LOOP;
    commit;
    end if;

      OPEN p_data_out FOR
      SELECT '8' AS resultCode, '已成功记帐' AS resultCap FROM dual;
      RETURN;


    END kc_year_checkout;

------------------------------------------------------------------------------
    END PCK_STORE;
/

prompt
prompt Creating package body PCK_STORE_BILL
prompt ====================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_STORE_BILL IS
  /**
   * 采购入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Contract_Instore_Edit_Bill(
    p_data_out     OUT rc,      --返回的数据集
    p_sfdjid_in IN INTEGER,
    p_fgsid_in     IN VARCHAR2
   )
   IS
   BEGIN
       OPEN p_data_out FOR   --打开数据集
       SELECT a.sfdjid,
              a.sfdjdh,   --采购入库单号
              a.sfrq,    --收发日期
              d.ckmc,    --仓库名称
              c.mc AS bmmc,      --部门名称
              a.dwtxid,  --单位通信id,即:供应商id
              e.dwmc,    --供应商名称
              a.khlx,    --客户类型
              f.lbmc,    --单据类型
              g.jsfs,    --结算方式
              a.jsr,     --经手人
              (
               SELECT  e.jhdbm
               FROM
                  cg_ht c,
                  cg_hthw d,
                  cg_htjhd e,
                  cg_htjhdhw f
                WHERE a.sfdjid = b.sfdjid
                AND   b.wjid = f.jhdhwid
                AND   f.hthwid = d.hthwid
                AND   d.htid = c.htid
                AND   f.jhdid = e.jhdid
              ) AS jhdbm, --进货单编码.即页面上的 单据号
              (
               SELECT  c.htbh
               FROM
                  cg_ht c,
                  cg_hthw d,
                  cg_htjhd e,
                  cg_htjhdhw f
               WHERE a.sfdjid = b.sfdjid
               AND   b.wjid = f.jhdhwid
               AND   f.hthwid = d.hthwid
               AND   d.htid = c.htid
               AND   f.jhdid = e.jhdid
              ) AS htbh, --合同编号
              (
               SELECT g.cpbm
               FROM
                   kc_dm g
               WHERE b.cpid = g.cpid
              ) AS cpbm,
              (
               SELECT g.pm
               FROM
                    kc_dm g
                WHERE b.cpid = g.cpid
               ) AS pm,
               (
                SELECT g.gg
                FROM
                    kc_dm g
                WHERE b.cpid = g.cpid
               ) AS gg,  --产品编码, 品名, 规格等
               (
                SELECT g.jldw
                FROM
                    kc_dm g
                WHERE b.cpid = g.cpid
               ) AS jldw,  --产品编码, 品名, 规格等
               b.ph,      --批号
               b.hssl,    --换算数量
               b.sl,      --数量
               b.dj,      --单价
               b.je,      --金额
               h.mc AS kwmc,      --库存名称
               (
                SELECT h.sxz
                FROM  kc_dmsx h --物资规格属性 (
                WHERE h.dmsxid = b.dmsxid
                AND   b.cpid = h.cpid
                ) AS wzggsx, --物资规格属性
                a.zdr,    --制单人
                decode (a.zt, 2, a.zdr, '') jzr,
                i.xm,
                a.bz,     --备注
                a.fgsid   --分公司id
                FROM
                    kc_sfdj a,
                    kc_sfdjmx b,
                    bm c,
                    kc_ck d, --仓库设置 (
                    dwtx e, --往来单位通信录 (
                    kc_sfdjlb f, --收发单据类别 (
                    jsfs g, --结算方式 (
                    kc_kw h, --库位设置 (
                    emp i
                WHERE a.sfdjid = b.sfdjid
                AND   a.storeid = d.storeid(+)
                AND   a.deptid = c.deptid(+)
                AND   a.dwtxid = e.dwtxid(+)
                AND   a.sfdjlbID = f.sfdjlbID(+)
                AND   a.jsfsid = g.jsfsid(+)
                AND   b.kwid = h.kwid(+)
                AND   a.sprid = i.personid(+)
                AND   a.djxz = 1 --采购入库单
                AND   a.sfdjid = p_sfdjid_in
                AND   a.fgsid = p_fgsid_in;
END Contract_Instore_Edit_Bill;
  /**
   * 销售出库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Outputlist_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
       SELECT
               a.sfdjdh, -- 收发单据号,
               a.sfrq, -- 收发日期
               b.ckmc,    --仓库名称
               c.mc AS bmmc, --部门名称
               g.dwmc,    --供应商名称
               a.khlx, --客户类型
               a.jsr, --经手人
               e.jsfs, --结算方式
               f.lbmc,    --单据类型
               a.bz, --备注
               a.zdr, --制单人
               decode (a.zt, 2, a.zdr, '') jzr,
               d.xm, --审批人
               a.fgsid,    --分公司id
               a.sfdjid    --收发单据id
        FROM kc_sfdj a,
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             jsfs e, --结算方式 (
             kc_sfdjlb f, --收发单据类别 (
             dwtx g -- 往来单位通信录 (
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid
        AND   a.jsfsid = e.jsfsid(+)
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.sprid = d.personid(+)
        AND   a.dwtxid = g.dwtxid
        AND   a.djxz = 2
        AND   a.fgsid = p_fgsid_in
        AND   a.sfdjid = p_sfdjid_in
       ) a, --销售出库单单据打印主表资料选取
       (
        SELECT
          (SELECT t.tdbh FROM xs_td t WHERE t.tdid = d.tdid) tdbh,--提单编号
          (SELECT h.htbh FROM xs_ht h, xs_hthw w WHERE h.htid= w.htid AND w.hthwid = d.hthwid) htbh,--销售合同号
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          k.hsdw, --换算单位
          l.sxz AS wzggsx,  --规格属性
          b.sl,   --数量
          b.hssl, --换算数量
          b.ph,   --批号
          b.dj, --单价
          b.je, --金额
          m.mc AS kwmc, --库位名称
          b.bz AS mxbz, --备注
          b.sfdjid -- 收发单据id
    FROM
         kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
         xs_tdhw d, --销售提单货物 (xs_tdhw)
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
   WHERE b.wjid = d.tdhwid(+)
   AND   b.cpid = k.cpid
   AND   b.dmsxid = l.dmsxid(+)
   AND   b.kwid = m.kwid(+)
   AND   b.sfdjid = p_sfdjid_in
   AND   b.fgsid = p_fgsid_in
   ) b
   WHERE a.sfdjid = b.sfdjid;
  END Outputlist_Edit_Bill;
  /**
   * 生产领料单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Receive_Material_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
       SELECT
               a.drawCode  sfdjdh, -- 收发单据号,
               a.drawDate  sfrq , -- 领料日期
               b.ckmc,    --仓库名称
               f.lbmc,    --单据类型
               c.mc AS bmmc, --部门名称
               e.ytmc,       --用途名称
               a.handlePerson jsr, --经手人
               a.memo bz, --备注
               a.creator zdr, --制单人
               d.xm, --审批人
               a.filialeID ,    --分公司id
               a.drawID,    --领料单ID
               decode (a.state, 2, a.creator, '') jzr,
               a.dwtxid,
               g.dwdm||'  '||g.dwmc dwmc
        FROM
             sc_drawMaterial a, --生产领料单
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_csdjyt e, --生产单据用途
             kc_sfdjlb f, --收发单据类别 (
             dwtx g
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.approveID = d.personid(+)
        AND   a.ytid = e.ytid(+)
        --AND   a.djxz = 4 --生产领料单
        AND   a.drawID = p_sfdjid_in
        AND   a.filialeID = p_fgsid_in
        AND   a.dwtxid = g.dwtxid(+)
      ) a, -- 生产领料单单据打印主表资料选取
     (
      SELECT
          (SELECT DISTINCT q.jgdh FROM sc_jgdmx d, sc_jgd q WHERE d.jgdmxid = f.jgdmxid AND d.jgdID = q.jgdid) jgdh,  --生产加工单号
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.drawNum sl,   --数量
          b.drawBigNum hssl, --换算数量
          b.batchNo ph,   --批号
          m.mc AS kwmc, --库位名称
          b.memo  AS mxbz, --备注
          b.drawID,  -- 收发单据id  VW_SELECT_PROCESSMATERAIL
          b.drawPrice,b.drawSum
     FROM
         sc_drawMaterialDetail b, --生产领料单明细
         sc_jgdmx f, --生产加工单明细
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.jgdmxid = f.jgdmxid(+)
     AND   b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.drawID = p_sfdjid_in
     ) b
   WHERE a.drawID = b.drawID;
  END Receive_Material_Edit_Bill;
  /**
   * 自制收货单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Self_Gain_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
       SELECT
               a.receiveCode sfdjdh, -- 收货单号
               a.receiveDate sfrq, -- 收发日期
               b.ckmc,    --仓库名称
               f.lbmc,    --单据类型
               c.mc AS bmmc, --部门名称
               e.ytmc,       --用途名称
               a.handlePerson jsr, --经手人
               a.memo bz, --备注
               a.creator zdr, --制单人
               d.xm, --审批人
               a.filialeID fgsid,    --分公司id
               a.receiveID,           --收发单据id
               decode (a.state, 2, a.creator, '') jzr,
               a.dwtxid,
               g.dwdm||'  '||g.dwmc dwmc
        FROM sc_receiveProd a, --自制收货单
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_csdjyt e, --生产单据用途
             kc_sfdjlb f, --收发单据类别 (
             dwtx g
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.approveID = d.personid(+)
        AND   a.ytid = e.ytid(+)
        --AND   a.djxz = 3 --生产领料单
        AND   a.receiveID = p_sfdjid_in
        AND   a.filialeID = p_fgsid_in
        AND   a.dwtxid = g.dwtxid(+)
      ) a, --自制收货单据单据打印主表资料选取
     (
      SELECT
          (SELECT DISTINCT q.jgdh FROM sc_jgdmx d, sc_jgd q WHERE d.jgdmxid = f.jgdmxid AND d.jgdID = q.jgdid) jgdh,  --生产加工单号
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.drawNum sl,   --数量
          b.drawBigNum hssl, --换算数量
          b.batchNo ph,   --批号
          m.mc AS kwmc, --库位名称
          b.memo AS mxbz, --备注
          b.receiveID, -- 收发单据id
          b.drawPrice, b.drawSum
     FROM
         sc_receiveProdDetail b, --自制收货单明细
         sc_jgdmx f, --生产加工单明细
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.jgdmxid = f.jgdmxid(+)
     AND   b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.receiveID  = p_sfdjid_in
     ) b
   WHERE a.receiveID  = b.receiveID; --自制收货单
  END Self_Gain_Edit_Bill;
  /**
   * 外加工入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Process_Instore_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
       SELECT
               a.sfdjdh, -- 收发单据号,
               a.sfrq, -- 收发日期
               a.dwtxid,  --单位通信id,即:供应商id
               g.dwmc,    --供应商名称
               b.ckmc,    --仓库名称
               c.mc AS bmmc, --部门名称
               f.lbmc,    --单据类型
               a.jsr, --经手人
               h.jsfs, --结算方式
               a.bz, --备注
               a.zdr, --制单人
               decode (a.zt, 2, a.zdr, '') jzr,
               d.xm, --审批人
               a.fgsid,    --分公司id
               a.sfdjid    --收发单据id
        FROM kc_sfdj a,
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_sfdjlb f, --收发单据类别 (
             dwtx g, --往来单位通信录 (
             jsfs h --结算方式 (
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid(+)
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.dwtxid = g.dwtxid
        AND   a.jsfsid = h.jsfsid(+)
        AND   a.sprid = d.personid(+)
        AND   a.djxz = 5 --外加工入库单
        AND   a.sfdjid = p_sfdjid_in
        AND   a.fgsid = p_fgsid_in
      ) a, --外加工入库单单据打印主表资料选取
     (
      SELECT
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.sl,   --数量
          b.hssl, --换算数量
          b.ph,   --批号
          m.mc AS kwmc, --库位名称
          b.bz AS mxbz, --备注
          b.sfdjid -- 收发单据id
     FROM
         kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
         sc_jgdmx f, --生产加工单明细
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.wjid = f.jgdmxid(+)
     AND   b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.sfdjid = p_sfdjid_in
     AND   b.fgsid = p_fgsid_in
     ) b
   WHERE a.sfdjid = b.sfdjid; --生产领料单
  END Process_Instore_Edit_Bill;
    /**
   * 外加工发料单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Process_Issue_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in     IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
       SELECT
               a.sfdjdh, -- 收发单据号,
               a.sfrq, -- 收发日期
               a.dwtxid,  --单位通信id,即:供应商id
               g.dwmc,    --供应商名称
               b.ckmc,    --仓库名称
               c.mc AS bmmc, --部门名称
               f.lbmc,    --单据类型
               a.jsr, --经手人
               h.jsfs, --结算方式
               a.bz, --备注
               a.zdr, --制单人
               decode (a.zt, 2, a.zdr, '') jzr,
               d.xm, --审批人
               a.fgsid,    --分公司id
               a.sfdjid    --收发单据id
        FROM kc_sfdj a,
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_sfdjlb f, --收发单据类别 (
             dwtx g, --往来单位通信录 (
             jsfs h --结算方式 (
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid(+)
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.dwtxid = g.dwtxid
        AND   a.jsfsid = h.jsfsid(+)
        AND   a.sprid = d.personid(+)
        AND   a.djxz = 6 --外加工发料单
        AND   a.sfdjid = p_sfdjid_in
        AND   a.fgsid = p_fgsid_in
      ) a, --外加工入库单单据打印主表资料选取
     (
      SELECT
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.sl,   --数量
          b.hssl, --换算数量
          b.ph,   --批号
          m.mc AS kwmc, --库位名称
          b.bz AS mxbz, --备注
          b.sfdjid -- 收发单据id
     FROM
         kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
         sc_jgdmx f, --生产加工单明细
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.wjid = f.jgdmxid(+)
     AND   b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.sfdjid = p_sfdjid_in
     AND   b.fgsid = p_fgsid_in
     ) b
   WHERE a.sfdjid = b.sfdjid; --生产领料单
  END Process_Issue_Edit_Bill;
  /**
   * 移库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Move_Store_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in  IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
       SELECT * FROM
      (
       SELECT
               a.sfdjdh, -- 收发单据号,
               a.sfrq, -- 收发日期
               a.dwtxid,  --单位通信id,即:供应商id
               b.ckmc,    --调出仓库名称
               (SELECT ckmc FROM kc_ck z WHERE z.storeid = a.kc__storeid) AS drckmc, --调入仓库名称
               c.mc AS bmmc, --部门名称
               f.lbmc,    --单据类型
               a.ykdrdh, --移库调入单号
               a.jsr, --经手人
               a.bz, --备注
               a.zdr, --制单人
               decode (a.zt, 2, a.zdr, '') jzr,
               d.xm, --审批人
               a.fgsid,    --分公司id
               a.sfdjid    --收发单据id
        FROM kc_sfdj a,
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_sfdjlb f --收发单据类别 (
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid(+)
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.sprid = d.personid(+)
        AND   a.djxz = 8 --移库单
        AND   a.sfdjid = p_sfdjid_in
        AND   a.fgsid = p_fgsid_in
      ) a, --外加工入库单单据打印主表资料选取
     (
      SELECT
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.sl,   --数量
          b.hssl, --换算数量
          b.ph,   --批号
          m.mc AS kwmc, --库位名称调出库位(移库)
          (SELECT mc FROM kc_kw z WHERE z.kwid = b.kc__kwid ) AS drkwmc, --调入库位id
          b.bz AS mxbz, --备注
          b.sfdjid -- 收发单据id
     FROM
         kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.sfdjid = p_sfdjid_in
     AND   b.fgsid = p_fgsid_in
     ) b
   WHERE a.sfdjid = b.sfdjid; --生产领料单
  END Move_Store_Edit_Bill;
  /**
   * 损溢单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Report_Destroy_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in  IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
       SELECT * FROM
      (
       SELECT
               a.sfdjdh, -- 收发单据号,
               a.sfrq, -- 收发日期
               b.ckmc,    --调出仓库名称
               c.mc AS bmmc, --部门名称
               f.lbmc,    --单据类型
               a.jfkm, --借方科目
               a.jsr, --经手人
               a.bz, --备注
               a.zdr, --制单人
               decode (a.zt, 2, a.zdr, '') jzr,
               d.xm, --审批人
               a.fgsid,    --分公司id
               a.sfdjid    --收发单据id
        FROM kc_sfdj a,
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d, --人员信息 (emp) 主要想取出经手人
             kc_sfdjlb f --收发单据类别 (
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid(+)
        AND   a.sfdjlbid = f.sfdjlbid(+)
        AND   a.sprid = d.personid(+)
        AND   a.djxz = 7 --报损单
        AND   a.sfdjid = p_sfdjid_in
        AND   a.fgsid = p_fgsid_in
      ) a, --外加工入库单单据打印主表资料选取
     (
      SELECT
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.sl,   --数量
          b.hssl, --换算数量
          b.ph,   --批号
          m.mc AS kwmc, --库位名称调出库位(移库)
          b.bz AS mxbz, --备注
          b.sfdjid -- 收发单据id
     FROM
         kc_sfdjmx b, --收发单据明细 (kc_sfdjmx)
         kc_dm k, --库存代码
         kc_dmsx l, --代码属性
         kc_kw m --库位设置 (
     WHERE
           b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.kwid = m.kwid(+)
     AND   b.sfdjid = p_sfdjid_in
     AND   b.fgsid = p_fgsid_in
     ) b
   WHERE a.sfdjid = b.sfdjid; --生产领料单
  END Report_Destroy_Edit_Bill;
  /**
   * 库存盘点单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Store_Check_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_pdid_in IN INTEGER,
     p_fgsid_in  IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
       SELECT * FROM
      (
       SELECT
               a.pdhm , -- 盘点单号 ,
               a.rq, -- 收发日期
               b.ckmc,    --调出仓库名称
               c.mc AS bmmc, --部门名称
               a.pdr, --盘点人
               (SELECT xm FROM emp z WHERE z.personid = a.zdrid ) AS zdr, --制单人
               d.xm, --审批人
               decode(a.zt,0,'未审核',1,'审核',2,'已入库',9,'已完成') AS zt, --状态
               a.fgsid,    --分公司id
               a.pdid    --收发单据id
        FROM kc_pd a,      --库存盘点单表
             kc_ck b, --仓库设置 (
             bm c, --部门 (
             emp d --人员信息 (emp) 主要想取出经手人
        WHERE
              a.storeid = b.storeid
        AND   a.deptid = c.deptid
        AND   a.sprid = d.personid(+)
        AND   a.pdid = p_pdid_in
        AND   a.fgsid = p_fgsid_in
      ) a, --外加工入库单单据打印主表资料选取
     (
      SELECT
          k.cpbm, --产品编码
          k.pm,   --品名
          k.gg,   --规格
          k.jldw, --计量单位
          l.sxz AS wzggsx,  --规格属性
          b.zcsl ,   --帐存数量
          b.scsl, -- 实存数量
          decode(sign(b.scsl-b.zcsl), -1, '亏', 0, '平', 1, '盈') AS yk,--盈亏
          (b.scsl-b.zcsl) AS ce, --差额
          b.ph,   --批号
          b.pdid -- 盘点id
     FROM
         kc_pdmx  b, --库存盘点明细 (kc_pdmx)
         kc_dm k, --库存代码
         kc_dmsx l --代码属性
     WHERE
           b.cpid = k.cpid
     AND   b.dmsxid = l.dmsxid(+)
     AND   b.pdid = p_pdid_in
     ) b
   WHERE a.pdid = b.pdid; --生产领料单
  END Store_Check_Edit_Bill;
  /**
   * 其它入库单单据打印
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_sfdjid_in IN INTEGER 收发单据id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE Other_Instore_Edit_Bill(
     p_data_out     OUT rc,      --返回的数据集
     p_sfdjid_in IN INTEGER,
     p_fgsid_in  IN VARCHAR2
  )
  IS
  BEGIN
    --打开数据集
      OPEN p_data_out FOR
       SELECT a.sfdjid,
       a.sfdjdh,   --采购入库单号
       a.sfrq,    --收发日期
       d.ckmc,    --仓库名称
       c.mc AS bmmc,      --部门名称
       a.dwtxid,  --单位通信id,即:供应商id
       e.dwmc,    --供应商名称
       a.khlx,    --客户类型
       f.lbmc,    --单据类型
       g.jsfs,    --结算方式
       a.jsr,     --经手人
       (
        SELECT g.cpbm
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS cpbm,
       (
        SELECT g.pm
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS pm,
       (
        SELECT g.gg
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS gg,  --产品编码, 品名, 规格等
       (
        SELECT g.jldw
        FROM
             kc_dm g
        WHERE b.cpid = g.cpid
       ) AS jldw,  --产品编码, 品名, 规格等
       b.ph,      --批号
       b.hssl,    --换算数量
       b.sl,      --数量
       b.dj, --单价
       b.je, --金额
       h.mc AS kwmc,      --库存名称
       (
        SELECT h.sxz
        FROM  kc_dmsx h --物资规格属性 (
        WHERE h.dmsxid = b.dmsxid
              AND b.cpid = h.cpid
       ) AS wzggsx, --物资规格属性
       a.zdr,    --制单人
       decode (a.zt, 2, a.zdr, '') jzr,
       i.xm,
       a.bz,     --备注
       a.fgsid   --分公司id
FROM
     kc_sfdj a,
     kc_sfdjmx b,
     bm c,
     kc_ck d, --仓库设置 (
     dwtx e, --往来单位通信录 (
     kc_sfdjlb f, --收发单据类别 (
     jsfs g, --结算方式 (
     kc_kw h, --库位设置 (
     emp i
WHERE a.sfdjid = b.sfdjid
      AND a.storeid = d.storeid(+)
      AND a.deptid = c.deptid(+)
      AND a.dwtxid = e.dwtxid(+)
      AND a.sfdjlbID = f.sfdjlbID(+)
      AND a.jsfsid = g.jsfsid(+)
      AND b.kwid = h.kwid(+)
      AND   a.sprid = i.personid(+)
      AND a.djxz = 9 --其它入库单
      AND a.sfdjid = p_sfdjid_in
      AND a.fgsid = p_fgsid_in;
  END Other_Instore_Edit_Bill;
 ----------------------------------------------------------------
END PCK_STORE_BILL;
/

prompt
prompt Creating package body PCK_STORE_REP
prompt ===================================
prompt
CREATE OR REPLACE PACKAGE BODY PCK_STORE_REP IS
  /**
   * 存货收发单据明细帐报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_sxz_in IN VARCHAR2 规格属性模糊查询
   * @param p_dmsxid_in IN VARCHAR2  代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_detail(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_sxz_in     IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_dmsxid_in     IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_sxz   VARCHAR2(100);
    v_pm    VARCHAR2(100);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_sxz   :='%'||p_sxz_in||'%';
    v_pm    :='%'||p_pm_in||'%';
    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
        SELECT NULL id, v_start rq, cpbm, pm,gg,jldw,hsdw, NULL djlx,  NULL djh, '期初余额' zy, 0 inouttype, srsl, NULL srdj, NULL srje,
               fcsl,NULL fcdj, NULL fcje, nvl(srsl,0)-nvl(fcsl,0) jcsl, NULL jcdj, NULL jcje,
               NULL sxz, srhssl, fchssl, nvl(srhssl,0)-nvl(fchssl,0) jchssl
        FROM
        (SELECT
          --得到期初余额
          (SELECT sum(nvl(srsl,0)) srsl FROM(
          SELECT c.cpbm, c.pm, c.gg,c.jldw,c.hsdw, e.sxz, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.fcsl,0)) fcsl --收入数量,发出数量
          FROM   vw_kc_storebill a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid AND a.sfrq < v_start
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
          )
          ) srsl,
          --得到期初余额
          (SELECT sum(nvl(srhssl,0)) srhssl FROM(
          SELECT c.cpbm, c.pm, c.gg,c.jldw,c.hsdw, e.sxz, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl --收入数量,发出数量
          FROM   vw_kc_storebill a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid AND a.sfrq < v_start
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
          )
          ) srhssl,
          --得到期初余额
          (SELECT sum(nvl(fchssl,0)) srhssl FROM(
          SELECT c.cpbm, c.pm, c.gg,c.jldw,c.hsdw, e.sxz, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl --收入数量,发出数量
          FROM   vw_kc_storebill a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid AND a.sfrq < v_start
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
          )
          ) fchssl,
          (SELECT sum(nvl(fcsl,0)) fcsl FROM(
          SELECT c.cpbm, c.pm, c.gg, c.jldw,c.hsdw, e.sxz, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.fcsl,0)) fcsl --收入数量,发出数量
          FROM   vw_kc_storebill a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid AND a.sfrq < v_start
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
          )
          ) fcsl,
          (SELECT cpbm FROM kc_dm WHERE cpid=p_productid_in) cpbm,
          (SELECT pm FROM kc_dm WHERE cpid=p_productid_in) pm,
          (SELECT gg FROM kc_dm WHERE cpid=p_productid_in) gg,
          (SELECT jldw FROM kc_dm WHERE cpid=p_productid_in) jldw,
          (SELECT hsdw FROM kc_dm WHERE cpid=p_productid_in) hsdw
          FROM dual
        ) e
        --库存收发单据入库数据
        --库存收发单据出入库数据
        UNION ALL
        SELECT id,sfrq,cpbm,pm,gg, jldw, hsdw, djlx, sfdjdh,zy,inouttype,srsl,srdj,srje,fcsl,fcdj,fcje,
               nvl(srsl,0)-nvl(fcsl,0) jcsl, NULL jcdj,--decode((nvl(srsl,0)-nvl(fcsl,0)),0,0,(nvl(srje,0)-nvl(fcje,0))/nvl(srsl,0)-nvl(fcsl,0)) jcdj,
               nvl(srje,0)-nvl(fcje,0) jcje,
               sxz, srhssl,fchssl,nvl(srhssl,0)-nvl(fchssl,0) jchssl
        FROM(
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,
          decode(a.djxz, 1, '采购入库单', 2, '销售出库单', 3, '自制收货单', 4, '生产领料单',5, '外加工入库单', 6, '外加工发料单',9, '其它入库单','') djlx,
          a.sfdjdh,
          decode(a.djxz, 1, '入库', 2, '出库', 3, '入库', 4, '出库',5, '入库', 6, '出库',9, '入库','')  zy,
          decode(a.djxz, 1, 1, 2, -1, 3, 1, 4, -1,5, 1,
                              6, -1, 7, 1, 8, -1, 9, 1, -1, 1,
                              -2, 1, 11, -1, 54, -1, 55, -1, 56, 1, ''
               )  inouttype, --04.09.29 新增 新增inouttype.以前类的监听器中是用zy判断出/入库方面.计算jcsl的.现在改成inouttype传给类作判断 yjg
               SUM(nvl(a.srsl,0)) srsl,SUM(nvl(a.srdj,0)) srdj, SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, decode(SUM(nvl(a.fcsl,0)), 0, 0, (SUM(nvl(a.fcje,0))/SUM(nvl(a.fcsl,0)))) fcdj,
               SUM(nvl(a.fcje,0)) fcje,f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE  a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz IN(1,2,3,4,5,6,9)
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.sfdjid, a.sfrq, a.djxz, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --移库单调入仓库等于查询仓库为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '移库单' djlx,  a.sfdjdh,
               '入库' zy,  1 inouttype, SUM(nvl(a.srsl,0)) srsl, decode(SUM(nvl(a.srsl,0)), 0, 0, (SUM(nvl(a.srje,0))/SUM(nvl(a.srsl,0)))) srdj,
               SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.fcdj,0)) fcdj, SUM(nvl(a.fcje,0)) fcje,
               f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz=-1
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.sfdjid, a.sfrq, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --移库单调出仓库等于查询仓库为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '移库单' djlx, a.sfdjdh,
               '出库' zy, 1 inouttype, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.srdj,0)) srdj, SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, decode(SUM(nvl(a.fcsl,0)), 0, 0, (SUM(nvl(a.fcje,0))/SUM(nvl(a.fcsl,0)))) fcdj,
               SUM(nvl(a.fcje,0)) fcje, f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz=8
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.sfdjid, a.sfrq, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --报损单数量大于零时为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '损益单' djlx, a.sfdjdh,
               '损益' zy, 1 inouttype,  SUM(nvl(a.srsl,0)) srsl, decode(SUM(nvl(a.srsl,0)), 0, 0, (SUM(nvl(a.srje,0))/SUM(nvl(a.srsl,0)))) srdj,
               SUM(nvl(a.srje,0)) srje,
               NULL fcsl, NULL fcdj, NULL fcje, f.sxz,SUM(nvl(a.srhssl,0)) srhssl, NULL fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND  a.djxz=7 --AND a.srsl>0
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.sfdjid, a.sfrq,a.sfdjdh, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, f.sxz
        ) g
      ) h
      ORDER BY rq;
  END store_detail;
-----------------------------------------------------------------------
  /**
   * 存货收发单据明细帐报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_sxz_in IN VARCHAR2 规格属性模糊查询
   * @param p_dmsxid_in IN VARCHAR2  代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_detail_new(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_sxz_in     IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_dmsxid_in     IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_sxz   VARCHAR2(100);
    v_pm    VARCHAR2(100);
    --new
    v_middle   DATE;
    v_checkid jc_checkout.checkid%type;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_sxz   :='%'||p_sxz_in||'%';
    v_pm    :='%'||p_pm_in||'%';

    --new
    select max(t.checkid) into v_checkid  from jc_checkout t where t.jsrq<=v_start ;
    if(v_checkid>0)then
    select t.jsrq into v_middle  from jc_checkout t where checkid=v_checkid;
   -- else
    --v_middle:=to_date('1900-1-1', 'YYYY-MM-DD');
    end if;

    --打开数据集
      OPEN p_data_out FOR
      SELECT * FROM
      (
      --得到期初余额
        SELECT NULL id, v_start rq, cpbm, pm,gg,jldw,hsdw, NULL djlx,  NULL djh, '期初余额' zy, 0 inouttype, srsl, NULL srdj, NULL srje,
               fcsl,NULL fcdj, NULL fcje, nvl(srsl,0)-nvl(fcsl,0) jcsl, NULL jcdj, NULL jcje,
               NULL sxz, srhssl, fchssl, nvl(srhssl,0)-nvl(fchssl,0) jchssl
        FROM
        (
        -----------------------------------------------------------------
        SELECT c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz,sum(nvl(srsl,0)) srsl,sum(nvl(srhssl,0)) srhssl
               ,sum(nvl(fchssl,0)) fchssl,sum(nvl(fcsl,0)) fcsl
          FROM   jc_checkdetail a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid
          AND a.checkid=v_checkid
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
        union all
        SELECT c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz,sum(nvl(srsl,0)) srsl,sum(nvl(srhssl,0)) srhssl
               ,sum(nvl(fchssl,0)) fchssl,sum(nvl(fcsl,0)) fcsl
          FROM   vw_kc_storebill a, vw_kc_dm c, kc_dmsx e
          WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid
          AND a.sfrq < v_start and (v_checkid>0 and a.sfrq>v_middle)
          AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
          AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
          AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
          AND (p_sxz_in IS NULL OR e.sxz LIKE v_sxz)
          AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
          AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
          AND    a.fgsid=p_fgsid_in
          AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
          GROUP BY c.cpbm, c.pm,c.gg,c.jldw,c.hsdw, e.sxz
          --------------------------
        ) e
        --库存收发单据入库数据
        --库存收发单据出入库数据
        UNION ALL
        SELECT id,sfrq,cpbm,pm,gg, jldw, hsdw, djlx, sfdjdh,zy,inouttype,srsl,srdj,srje,fcsl,fcdj,fcje,
               nvl(srsl,0)-nvl(fcsl,0) jcsl, NULL jcdj,--decode((nvl(srsl,0)-nvl(fcsl,0)),0,0,(nvl(srje,0)-nvl(fcje,0))/nvl(srsl,0)-nvl(fcsl,0)) jcdj,
               nvl(srje,0)-nvl(fcje,0) jcje,
               sxz, srhssl,fchssl,nvl(srhssl,0)-nvl(fchssl,0) jchssl
        FROM(
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,
          decode(a.djxz, 1, '采购入库单', 2, '销售出库单', 3, '自制收货单', 4, '生产领料单',5, '外加工入库单', 6, '外加工发料单',9, '其它入库单','') djlx,
          a.sfdjdh,
          decode(a.djxz, 1, '入库', 2, '出库', 3, '入库', 4, '出库',5, '入库', 6, '出库',9, '入库','')  zy,
          decode(a.djxz, 1, 1, 2, -1, 3, 1, 4, -1,5, 1,
                              6, -1, 7, 1, 8, -1, 9, 1, -1, 1,
                              -2, 1, 11, -1, 54, -1, 55, -1, 56, 1, ''
               )  inouttype, --04.09.29 新增 新增inouttype.以前类的监听器中是用zy判断出/入库方面.计算jcsl的.现在改成inouttype传给类作判断 yjg
               SUM(nvl(a.srsl,0)) srsl,SUM(nvl(a.srdj,0)) srdj, SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, decode(SUM(nvl(a.fcsl,0)), 0, 0, (SUM(nvl(a.fcje,0))/SUM(nvl(a.fcsl,0)))) fcdj,
               SUM(nvl(a.fcje,0)) fcje,f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE  a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz IN(1,2,3,4,5,6,9)
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.sfdjid, a.sfrq, a.djxz, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --移库单调入仓库等于查询仓库为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '移库单' djlx,  a.sfdjdh,
               '入库' zy,  1 inouttype, SUM(nvl(a.srsl,0)) srsl, decode(SUM(nvl(a.srsl,0)), 0, 0, (SUM(nvl(a.srje,0))/SUM(nvl(a.srsl,0)))) srdj,
               SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.fcdj,0)) fcdj, SUM(nvl(a.fcje,0)) fcje,
               f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz=-1
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.sfdjid, a.sfrq, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --移库单调出仓库等于查询仓库为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '移库单' djlx, a.sfdjdh,
               '出库' zy, 1 inouttype, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.srdj,0)) srdj, SUM(nvl(a.srje,0)) srje,
               SUM(nvl(a.fcsl,0)) fcsl, decode(SUM(nvl(a.fcsl,0)), 0, 0, (SUM(nvl(a.fcje,0))/SUM(nvl(a.fcsl,0)))) fcdj,
               SUM(nvl(a.fcje,0)) fcje, f.sxz,SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND a.djxz=8
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.sfdjid, a.sfrq, a.sfdjdh, e.cpbm,e.pm,e.gg, e.jldw,e.hsdw,f.sxz
        UNION ALL --报损单数量大于零时为入库
        SELECT a.sfdjid id, a.sfrq, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, '损益单' djlx, a.sfdjdh,
               '损益' zy, 1 inouttype,  SUM(nvl(a.srsl,0)) srsl, decode(SUM(nvl(a.srsl,0)), 0, 0, (SUM(nvl(a.srje,0))/SUM(nvl(a.srsl,0)))) srdj,
               SUM(nvl(a.srje,0)) srje,
               NULL fcsl, NULL fcdj, NULL fcje, f.sxz,SUM(nvl(a.srhssl,0)) srhssl, NULL fchssl
        FROM vw_kc_storebill a, kc_dm e, kc_dmsx f
        WHERE a.cpid=e.cpid AND a.dmsxid=f.dmsxid(+) AND  a.djxz=7 --AND a.srsl>0
        AND   a.sfrq >= v_start AND a.sfrq <= v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_sxz_in IS NULL OR f.sxz LIKE v_sxz)
        AND (p_pm_in IS NULL OR e.pm LIKE v_pm)
        AND (p_fgsid_in IS NULL OR a.fgsid = p_fgsid_in)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.sfdjid, a.sfrq,a.sfdjdh, e.cpbm,e.pm,e.gg,e.jldw,e.hsdw, f.sxz
        ) g
      ) h
      ORDER BY rq;
  END store_detail_new;
-----------------------------------------------------------------------
   /**
   * 存货收发汇总报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_dmsxid_in IN VARCHAR2   代码属性id
   * @param p_sfdjcheck_in IN VARCHAR2  库存收发单据是否包括未记帐 1,0
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_pm    VARCHAR2(100);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_pm    :='%'||p_pm_in||'%';
    --打开数据集
      OPEN p_data_out FOR
     SELECT dmsxid, cpid, cpbm, pm, gg, product,  jldw, SUM(nvl(qcjc,0)) qcjc,
            decode(SUM(nvl(qcjc,0)), 0, 0, SUM(nvl(qcje,0))/SUM(nvl(qcjc,0))) qcdj,
            SUM(nvl(qcje,0)) qcje,
            SUM(nvl(srsl,0)) srsl,
            decode(SUM(nvl(srsl,0)), 0, 0, SUM(nvl(srje,0))/SUM(nvl(srsl,0))) srdj,
            SUM(nvl(srje,0)) srje,
            SUM(nvl(fcsl,0)) fcsl,
            decode(SUM(nvl(fcsl,0)), 0, 0, SUM(nvl(fcje,0))/SUM(nvl(fcsl,0))) fcdj,
            SUM(nvl(fcje,0)) fcje,
            SUM(nvl(qcjc,0))+SUM(nvl(qmsl,0)) qmsl,
            decode((SUM(nvl(qcjc,0))+SUM(nvl(qmsl,0))),0,0,(SUM(nvl(qcje,0))+SUM(nvl(qmje,0)))/(SUM(nvl(qcjc,0))+SUM(nvl(qmsl,0)))) qmdj,
            SUM(nvl(qcje,0))+SUM(nvl(qmje,0)) qmje, sxz
     FROM
     (
     --得到期初结存
     SELECT  dmsxid, cpid, cpbm, pm, gg, product, jldw, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) qcjc,
             NULL qcdj,
             (SUM(nvl(srje,0))-SUM(nvl(fcje,0))) qcje, NULL srsl, NULL srdj, NULL srje, NULL fcsl, NULL fcdj,
             NULL fcje, NULL qmsl, NULL qmdj, NULL qmje, sxz
      FROM
      (
      SELECT a.dmsxid, c.cpid, c.cpbm, c.pm, c.gg, c.product, c.jldw, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.srje,0)) srje,
             SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.fcje,0)) fcje, e.sxz
        FROM vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e --得到期初结存入库数量
        WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND c.chlbid=d.chlbid(+)
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.dmsxid, c.cpid,c.cpbm, c.pm, c.gg, c.jldw,e.sxz, c.product
        /**
      UNION ALL
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, NULL srsl, NULL srje,
             SUM(nvl(b.sl,0)) fcsl, SUM(nvl(b.je,0)) fcje, e.sxz
        FROM kc_sfdj a, kc_sfdjmx b, kc_dm c, kc_chlb d, kc_dmsx e --得到期初结存出库数量
        WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND b.dmsxid=e.dmsxid(+) AND  a.djxz IN(2,4,6) AND c.chlbid=d.chlbid(+)
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR b.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        GROUP BY c.cpid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz
      UNION ALL
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, SUM(nvl(b.sl,0)) srsl, SUM(nvl(b.je,0)) srje,
             NULL fcsl, NULL fcje, e.sxz
        FROM kc_sfdj a, kc_sfdjmx b, kc_dm c, kc_chlb d, kc_dmsx e --得到期初结存移库单入库数量
        WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND b.dmsxid=e.dmsxid(+) AND a.djxz=8 AND c.chlbid=d.chlbid(+)
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.kc__storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR b.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        GROUP BY c.cpid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz
      UNION ALL
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, NULL srsl, NULL srje,
             SUM(nvl(b.sl,0)) fcsl, SUM(nvl(b.je,0)) fcje, e.sxz
        FROM kc_sfdj a, kc_sfdjmx b, kc_dm c, kc_chlb d, kc_dmsx e --得到期初结存移库单出库数量
        WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND b.dmsxid=e.dmsxid AND  a.djxz=8 AND c.chlbid=d.chlbid(+)
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR b.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        GROUP BY c.cpid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz
        */
      ) e
      GROUP BY dmsxid,cpid, cpbm, pm, gg, jldw, sxz, product
    UNION ALL
    SELECT  dmsxid, cpid, cpbm, pm, gg, product, jldw, NULL qcjc, NULL qcdj, NULL qcje, srsl, srdj, srje, fcsl, fcdj, fcje,
            nvl(srsl,0)-nvl(fcsl,0) qmsl, NULL qmdj, nvl(srje,0)-nvl(fcje,0) qmje, sxz
     FROM --得到该时间段输入输出数据
      (
      SELECT a.dmsxid, c.cpid, c.cpbm, c.pm, c.gg, c.product, c.jldw, SUM(nvl(a.srsl,0)) srsl, NULL srdj,
         --decode(SUM(nvl(a.sl,0)), 0, 0, SUM(nvl(b.je,0))/SUM(nvl(b.sl,0))) srdj,
         SUM(nvl(a.srje,0)) srje, SUM(nvl(a.fcsl,0)) fcsl, NULL fcdj, SUM(nvl(a.fcsl,0)) fcje, e.sxz
         FROM vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e
         WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND  c.chlbid=d.chlbid(+)
         AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in
         AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
         AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
         AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
         AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
         AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
         AND (p_sfdjcheck_in = '1' OR a.zt=2 OR a.zt=8)
         GROUP BY a.dmsxid, c.cpid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz, c.product
       ) f
      ) g
      GROUP BY dmsxid, cpid, cpbm, pm, gg, jldw, sxz, product
      ORDER BY cpbm;
  END stock_collect;
   /**
   * 存货收发日报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_date_in IN VARCHAR2      日期
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_property_in IN VARCHAR2 规格属性id
   * @param p_sfdjcheck_in IN VARCHAR2   是否包括未记账
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE store_inout_day(    --库存日报表存储过程
    p_data_out     OUT rc,      --返回的数据集
    p_date_in IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_stocksort_in IN VARCHAR2,
    p_productid_in IN VARCHAR2,
    p_property_in IN VARCHAR2,
    p_sfdjcheck_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  )
  IS
    v_date DATE;
  BEGIN
    v_date := to_date(p_date_in, 'YYYY-MM-DD');
    --打开数据集
      OPEN p_data_out FOR
      SELECT cpbm, pm, gg, jldw, sxz,srjc,brsr,brfc,brjc
      FROM(
      SELECT cpbm, pm, gg, jldw, sxz, SUM(nvl(srjc,0)) srjc, SUM(nvl(brsr,0)) brsr, SUM(nvl(brfc,0)) brfc,
             SUM(nvl(srjc,0)+nvl(brjc,0)) brjc
     FROM
     (
     --得到上日结存
     SELECT  dmsxid, cpbm, pm, gg, jldw, sxz, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) srjc,
             NULL brsr, NULL brfc, NULL brjc
      FROM
      (
      SELECT a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz, SUM(nvl(a.srsl,0)) srsl,SUM(nvl(a.fcsl,0)) fcsl
        FROM vw_kc_storebill a, kc_dm c, kc_chlb d, kc_dmsx e --得到上日结存入库数量
        WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND c.chlbid=d.chlbid(+)
        AND a.sfrq<v_date AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_property_in IS NULL OR a.dmsxid = p_property_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_sfdjcheck_in='1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz
      ) e
      GROUP BY dmsxid, cpbm, pm, gg, jldw, sxz
    UNION ALL
    SELECT  dmsxid, cpbm, pm, gg, jldw, sxz, NULL srjc, SUM(nvl(srsl,0)) brsr, SUM(nvl(fcsl,0)) brfc,
            SUM(nvl(srsl,0)-nvl(fcsl,0)) brjc
     FROM --得到本日输入输出数据
      (
        SELECT a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz, SUM(nvl(a.srsl,0)) srsl,SUM(nvl(a.fcsl,0)) fcsl
        FROM vw_kc_storebill a, kc_dm c, kc_chlb d, kc_dmsx e --得到本日结存入库数量
        WHERE a.cpid=c.cpid AND a.dmsxid=e.dmsxid(+) AND c.chlbid=d.chlbid(+)
        AND a.sfrq=v_date AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_property_in IS NULL OR a.dmsxid = p_property_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_sfdjcheck_in='1' OR a.zt=2 OR a.zt=8)
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        GROUP BY a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, e.sxz
      ) e
      GROUP BY dmsxid, cpbm, pm, gg, jldw, sxz
      ) g
      GROUP BY dmsxid, cpbm, pm, gg, jldw, sxz
      ORDER BY cpbm, sxz)WHERE (nvl(brsr,0)<>0 OR nvl(brfc,0)<>0);
  END store_inout_day;
  /**
   * 存货单据分类查询
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2   规格属性
   * @param p_djxz_in IN VARCHAR2      单据类别
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_deptid_in IN VARCHAR2   部门id
   * @param p_dwtxid_in IN VARCHAR2   往来单位ID
   * @param p_checkin_in IN VARCHAR2   是否包括未记账
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE kc_bill_inout_collect(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_djxz_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_deptid_in  IN VARCHAR2,
    p_dwtxid_in  IN VARCHAR2,
    p_checkin_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2,
    p_personid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --打开数据集
    IF(p_storeid_in=8) THEN --选择移库单
      OPEN p_data_out FOR
      SELECT dmsxid,cpbm,pm,gg,jldw,sxz, nvl(srsl,0)-nvl(fcsl,0) sl, nvl(srje,0)-nvl(fcje,0) je,
             decode((nvl(srsl,0)-nvl(fcsl,0)), 0 ,0 , ((nvl(srje,0)-nvl(fcje,0) )/nvl(srsl,0)-nvl(fcsl,0))) dj
      FROM (
      SELECT a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.srje,0)) srje,
             SUM(nvl(a.fcje,0)) fcsl,SUM(nvl(a.fcje,0)) fcje
      FROM vw_kc_storebill a, kc_dm c, kc_dmsx d
      WHERE a.cpid=c.cpid AND a.dmsxid=d.dmsxid(+) AND a.djxz IN (8,-1)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_checkin_in='1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz
        ORDER BY c.cpbm
        ) ORDER BY cpbm;
    ELSE
      OPEN p_data_out FOR
      SELECT dmsxid, cpbm, pm,gg,jldw,sxz, nvl(srsl,0) sl,nvl(srje,0) je,
      decode(nvl(srsl,0),0,0, nvl(srje,0)/nvl(srsl,0)) dj
      FROM (
      SELECT a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.srje,0)) srje
      FROM vw_kc_storebill a, kc_dm c, kc_dmsx d
      WHERE a.cpid=c.cpid AND a.dmsxid=d.dmsxid(+) AND a.djxz IN (1,3,5,7,9)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_checkin_in='1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz
        ORDER BY c.cpbm
        )
       UNION ALL
        SELECT dmsxid, cpbm, pm,gg,jldw,sxz, nvl(fcsl,0) sl,nvl(fcje,0) je,
        decode(nvl(fcsl,0),0,0, nvl(fcje,0)/nvl(fcsl,0)) dj
        FROM (
        SELECT a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz, SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.fcje,0)) fcje
        FROM vw_kc_storebill a, kc_dm c, kc_dmsx d
        WHERE a.cpid=c.cpid AND a.dmsxid=d.dmsxid(+) AND a.djxz IN (2,4,6)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND a.storeid IN ( SELECT storeid FROM jc_ckqx WHERE personid = p_personid_in )
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_checkin_in='1' OR a.zt=2 OR a.zt=8)
        GROUP BY a.dmsxid, c.cpbm, c.pm, c.gg, c.jldw, d.sxz
        ORDER BY c.cpbm
        )
        ORDER BY cpbm;
        END IF;
  END kc_bill_inout_collect;
 ----------------------------------------------------------------
 --02.26 14:26 新增 为存货批号收发结存表而新增的存储过程. yjg
   /**
   * 存货批号收发结存表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_djxz_in IN VARCHAR2      单据类别
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_deptid_in IN VARCHAR2   部门id
   * @param p_dwtxid_in IN VARCHAR2   往来单位ID
   * @param p_person_in IN VARCHAR2   经手人
   * @param p_checkin_in IN VARCHAR2   是否包括未记账
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE rep_kc_batno_inout(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_djxz_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_deptid_in  IN VARCHAR2,
    p_dwtxid_in  IN VARCHAR2,
    p_person_in  IN VARCHAR2,
    p_checkin_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --打开数据集
    IF(p_storeid_in IS NULL) THEN
      OPEN p_data_out FOR
      SELECT c.cpbm, c.pm, c.gg, c.jldw, SUM(nvl(b.sl,0)) sl, SUM(nvl(b.je,0)) je,
             decode(SUM(nvl(b.sl,0)), 0, 0, SUM(nvl(b.je,0))/SUM(nvl(b.sl,0))) dj
      FROM kc_sfdj a, kc_sfdjmx b, kc_dm c
      WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_person_in IS NULL OR a.jsr = p_person_in)
        AND (p_checkin_in='1' OR a.zt=1 OR a.zt=8)
        GROUP BY c.cpbm, c.pm, c.gg, c.jldw
        ORDER BY c.cpbm;
      ELSE
      OPEN p_data_out FOR
      SELECT *
      FROM(
      SELECT c.cpbm, c.pm, c.gg, c.jldw, SUM(nvl(b.sl,0)) sl, SUM(nvl(b.je,0)) je,
             decode(SUM(nvl(b.sl,0)), 0, 0, SUM(nvl(b.je,0))/SUM(nvl(b.sl,0))) dj
      FROM kc_sfdj a, kc_sfdjmx b, kc_dm c
      WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND a.djxz<>8
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_person_in IS NULL OR a.jsr = p_person_in)
        AND (p_checkin_in='1' OR a.zt=1 OR a.zt=8)
        GROUP BY c.cpbm, c.pm, c.gg, c.jldw
      UNION ALL
      SELECT c.cpbm, c.pm, c.gg, c.jldw, SUM(nvl(b.sl,0)) sl, SUM(nvl(b.je,0)) je,
             decode(SUM(nvl(b.sl,0)), 0, 0, SUM(nvl(b.je,0))/SUM(nvl(b.sl,0))) dj
      FROM kc_sfdj a, kc_sfdjmx b, kc_dm c
      WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND a.djxz=8
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (a.storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_person_in IS NULL OR a.jsr = p_person_in)
        AND (p_checkin_in='1' OR a.zt=1 OR a.zt=8)
        GROUP BY c.cpbm, c.pm, c.gg, c.jldw
      UNION ALL
      SELECT c.cpbm, c.pm, c.gg, c.jldw, SUM(nvl(b.sl,0)) sl, SUM(nvl(b.je,0)) je,
             decode(SUM(nvl(b.sl,0)), 0, 0, SUM(nvl(b.je,0))/SUM(nvl(b.sl,0))) dj
      FROM kc_sfdj a, kc_sfdjmx b, kc_dm c
      WHERE a.sfdjid=b.sfdjid AND b.cpid=c.cpid AND  a.sfrq>=v_start AND a.sfrq<=v_end
        AND a.djxz=8
        AND (p_productid_in IS NULL OR b.cpid = p_productid_in)
        AND a.fgsid=p_fgsid_in
        AND (p_djxz_in IS NULL OR a.djxz = p_djxz_in)
        AND (a.kc__storeid = p_storeid_in)
        AND (p_deptid_in IS NULL OR a.deptid = p_deptid_in)
        AND (p_dwtxid_in IS NULL OR a.dwtxid = p_dwtxid_in)
        AND (p_person_in IS NULL OR a.jsr = p_person_in)
        AND (p_checkin_in='1' OR a.zt=1 OR a.zt=8)
        GROUP BY c.cpbm, c.pm, c.gg, c.jldw
        ) f
        ORDER BY cpbm;
        END IF;
  END rep_kc_batno_inout;
  --2004.04.12 20:52 新增 为收发类别分类汇总表(物资类别分类汇总)而新增的存储过程. jac
   /**
   * 收发类别分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库ID
   * @param p_chlbid_in  in VARCHAR2   存货类别ID
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE AssortCollect(
    p_data_out      OUT rc,      --返回的数据集
    p_startdate_in  IN VARCHAR2,
    p_enddate_in    IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_chlbid_in     IN VARCHAR2,
    p_fgsid_in      IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    --p_chlbid_in VARCHAR2(32);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --打开数据集
    OPEN p_data_out FOR
    SELECT a.*, b.bm cpbm, b.mc product FROM
    (
      --得到期初结存
      --cpid, cpbm, product, sxz, beforetotal, billtype(i/o), sfdjlbid, lbmc, sl
      SELECT  wzlbid cpid, (srsl-fcsl) beforetotal,
              'a' billtype, 0 sl, NULL sfdjlbid, NULL lbmc
      FROM
      (
        --得到期初结存入库数量,出库数量
        SELECT c.wzlbid, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.fcsl,0)) fcsl --收入数量,发出数量
        FROM   vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e
        WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid
        AND    c.chlbid=d.chlbid    AND a.sfrq < v_start
        AND    (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND    (p_chlbid_in IS NULL  OR c.chlbid = p_chlbid_in)
        AND    a.fgsid=p_fgsid_in
        GROUP BY c.wzlbid
      ) e
      --提取收入与发出的数量     (-1,1,3,5,7,9)
      --cpid, cpbm, product, sxz, beforetotal, billtype(i/o), sfdjlbid, lbmc, sl
      UNION ALL
      SELECT t.wzlbid cpid, NULL beforetotal,
             t.billtype, SUM(nvl(t.sl,0)) sl, t.sfdjlbid, l.lbmc
      FROM
      (
        --得到该时间段收入数据,支出数据
        SELECT c.wzlbid, a.sfdjlbid,
               decode(a.djxz, 2, 'o', 4, 'o', 6, 'o', 8, 'o', 'i')  billtype,
               decode(a.djxz, 2, a.fcsl, 4, a.fcsl, 6, a.fcsl, 8, a.fcsl, a.srsl) sl
        FROM   vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e
        WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid  AND c.chlbid=d.chlbid
        AND    a.sfrq>=v_start      AND a.sfrq<=v_end
        AND    (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND    (p_chlbid_in IS NULL  OR c.chlbid = p_chlbid_in)
        AND    a.fgsid=p_fgsid_in
      ) t, kc_sfdjlb l
      WHERE t.sfdjlbid = l.sfdjlbid(+)
      GROUP BY t.wzlbid, t.billtype, t.sfdjlbid, l.lbmc
    ) a, kc_dmlb b
    WHERE a.cpid = b.wzlbid
    ORDER BY a.billtype, b.bm
    ;
  END AssortCollect;
  --2004.03.23 22:38 新增 为收发类别分类汇总表（按产品汇总）而新增的存储过程. jac
   /**
   * 收发类别分类汇总表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_storeid_in IN VARCHAR2   仓库ID
   * @param p_chlbid_in  in VARCHAR2   存货类别ID
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE AssortCollectDetail(
    p_data_out      OUT rc,      --返回的数据集
    p_startdate_in  IN VARCHAR2,
    p_enddate_in    IN VARCHAR2,
    p_storeid_in    IN VARCHAR2,
    p_chlbid_in     IN VARCHAR2,
    p_fgsid_in      IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    --p_chlbid_in VARCHAR2(32);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    --打开数据集
    OPEN p_data_out FOR
    SELECT * FROM
    (
      --得到期初结存
      --cpid, cpbm, product, sxz, beforetotal, billtype(i/o), sfdjlbid, lbmc, sl
      SELECT  cpid, cpbm, product, sxz, (srsl-fcsl) beforetotal,
              'a' billtype, 0 sl, NULL sfdjlbid, NULL lbmc
      FROM
      (
        --得到期初结存入库数量,出库数量
        SELECT c.cpid, c.cpbm, c.product, e.sxz, SUM(nvl(a.srsl,0)) srsl, SUM(nvl(a.fcsl,0)) fcsl --收入数量,发出数量
        FROM   vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e
        WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid
        AND    c.chlbid=d.chlbid    AND a.sfrq < v_start
        AND    (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND    (p_chlbid_in IS NULL  OR c.chlbid = p_chlbid_in)
        AND    a.fgsid=p_fgsid_in
        GROUP BY c.cpid, c.cpbm, c.product, e.sxz
      ) e
      --提取收入与发出的数量     (-1,1,3,5,7,9)
      --cpid, cpbm, product, sxz, beforetotal, billtype(i/o), sfdjlbid, lbmc, sl
      UNION ALL
      SELECT t.cpid, t.cpbm, t.product, t.sxz, NULL beforetotal,
             t.billtype, SUM(nvl(t.sl,0)) sl, t.sfdjlbid, l.lbmc
      FROM
      (
        --得到该时间段收入数据,支出数据
        SELECT c.cpid, c.cpbm, c.product, e.sxz, a.sfdjlbid,
               decode(a.djxz, 2, 'o', 4, 'o', 6, 'o', 8, 'o', 'i')  billtype,
               decode(a.djxz, 2, a.fcsl, 4, a.fcsl, 6, a.fcsl, 8, a.fcsl, a.srsl) sl
        FROM   vw_kc_storebill a, vw_kc_dm c, kc_chlb d, kc_dmsx e
        WHERE  a.dmsxid=e.dmsxid(+) AND a.cpid=c.cpid  AND c.chlbid=d.chlbid
        AND    a.sfrq>=v_start      AND a.sfrq<=v_end
        AND    (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND    (p_chlbid_in IS NULL  OR c.chlbid = p_chlbid_in)
        AND    a.fgsid=p_fgsid_in
      ) t, kc_sfdjlb l
      WHERE t.sfdjlbid = l.sfdjlbid(+)
      GROUP BY t.cpid, t.cpbm, t.product, t.sxz, t.billtype, t.sfdjlbid, l.lbmc
    ) a
    ORDER BY billtype, cpbm, sxz
    ;
  END AssortCollectDetail;
   /**
   * 存货库存量报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_wztype_in IN VARCHAR2   物资类别id
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_number(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    --p_wztype_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_pm VARCHAR2(100);
    v_gg VARCHAR2(100);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_pm   :='%'||p_pm_in||'%';
    v_gg   :='%'||p_gg_in||'%';
    --打开数据集
     OPEN p_data_out FOR
     SELECT cpid, cpbm, pm, gg, jldw,hsdw, sum(nvl(kcsl,0)) kcsl,sum(nvl(kchssl,0)) kchssl, sum(nvl(wjzssl,0)) wjzssl,
            sum(nvl(wjzfsl,0)) wjzfsl, sum(nvl(kcsl,0))+sum(nvl(hjsl,0)) hjsl,
            sum(nvl(kchssl,0))+sum(nvl(hjhssl,0)) hjhssl
     FROM
     (
     --得到期初结存期初未记帐的单据也计算
     SELECT  cpid, cpbm, pm, gg, jldw, hsdw, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
             (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
             NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl
      FROM
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,c.hsdw, SUM(nvl(a.srsl,0)) srsl,
             SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm c
        WHERE a.cpid=c.cpid
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
         AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw
      ) e
      GROUP BY cpid, cpbm, pm, gg, jldw,hsdw
    UNION ALL
     --得到查询段时间记帐数量
     SELECT  cpid, cpbm, pm, gg, jldw, hsdw, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
             (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
             NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl
      FROM
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,c.hsdw, SUM(nvl(a.srsl,0)) srsl,
             SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm c--得到查询段时间记帐数量
        WHERE a.cpid=c.cpid AND (a.zt=2 OR  a.zt=8)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        --AND (p_wztype_in IS NULL OR c.wzlbid = p_wztype_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
         AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw
      ) e
      GROUP BY cpid, cpbm, pm, gg, jldw,hsdw
    UNION ALL
    SELECT  cpid, cpbm, pm, gg, jldw,hsdw, NULL kcsl, NULL kchssl, wjzssl, wjzfsl, nvl(wjzssl,0)-nvl(wjzfsl,0) hjsl,
            nvl(wjzsrhssl,0)-nvl(wjzfchssl,0) hjhssl
     FROM --得到该时间段输入输出数据
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,c.hsdw, SUM(nvl(a.srsl,0)) wjzssl,
             SUM(nvl(a.fcsl,0)) wjzfsl, SUM(nvl(a.srhssl,0)) wjzsrhssl,
             SUM(nvl(a.fchssl,0)) wjzfchssl
         FROM vw_kc_storebill a, kc_dm c
         WHERE a.cpid=c.cpid AND a.zt<>2 AND a.zt<>8
         AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in
         AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
         AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
         AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
         --AND (p_wztype_in IS NULL OR c.wzlbid = p_wztype_in)
         AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
         AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
         AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
         AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
         GROUP BY c.cpid, c.cpbm, c.pm, c.gg, c.jldw,c.hsdw
       ) f
      ) g GROUP BY cpid, cpbm, pm, gg, jldw,hsdw
      ORDER BY cpbm;
      END stock_number;
  /**
   * 存货明细报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2 规格属性id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_ph_in IN VARCHAR2   批号
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_product_number(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    p_ph_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_pm VARCHAR2(100);
    v_gg VARCHAR2(100);
    v_ph VARCHAR2(100);
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_pm   :='%'||p_pm_in||'%';
    v_gg   :='%'||p_gg_in||'%';
    v_ph   :='%'||p_ph_in||'%';
    --打开数据集
     OPEN p_data_out FOR
     SELECT cpid, cpbm, pm, gg, jldw,ph,sxz, sum(nvl(kcsl,0)) kcsl,sum(nvl(kchssl,0)) kchssl, sum(nvl(wjzssl,0)) wjzssl,
            sum(nvl(wjzfsl,0)) wjzfsl, sum(nvl(kcsl,0))+sum(nvl(hjsl,0)) hjsl,
            sum(nvl(kchssl,0))+sum(nvl(hjhssl,0)) hjhssl
     FROM
     (
     --得到期初结存期初未记帐的单据也计算
     SELECT  cpid, cpbm, pm, gg, jldw,ph,sxz, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
             (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
             NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl
      FROM
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz, SUM(nvl(a.srsl,0)) srsl,
             SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm c, kc_dmsx b
        WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+)
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        AND (p_ph_in IS NULL OR a.ph LIKE v_ph)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz
      ) e
      GROUP BY cpid, cpbm, pm, gg, jldw,ph,sxz
    UNION ALL
     --得到查询段时间记帐数量
     SELECT  cpid, cpbm, pm, gg, jldw, ph,sxz, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
             (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
             NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl
      FROM
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz, SUM(nvl(a.srsl,0)) srsl,
             SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm c,kc_dmsx b--得到查询段时间记帐数量
        WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+) AND (a.zt=2 OR  a.zt=8)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        AND (p_ph_in IS NULL OR a.ph LIKE v_ph)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz
      ) e
      GROUP BY cpid, cpbm, pm, gg, jldw,ph,sxz
    UNION ALL
    SELECT  cpid, cpbm, pm, gg, jldw,ph,sxz, NULL kcsl, NULL kchssl, wjzssl, wjzfsl, nvl(wjzssl,0)-nvl(wjzfsl,0) hjsl,
            nvl(wjzsrhssl,0)-nvl(wjzfchssl,0) hjhssl
     FROM --得到该时间段输入输出数据
      (
      SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz, SUM(nvl(a.srsl,0)) wjzssl,
             SUM(nvl(a.fcsl,0)) wjzfsl, SUM(nvl(a.srhssl,0)) wjzsrhssl,
             SUM(nvl(a.fchssl,0)) wjzfchssl
         FROM vw_kc_storebill a, kc_dm c,kc_dmsx b
         WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+) AND a.zt<>2 AND a.zt<>8
         AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        AND (p_ph_in IS NULL OR a.ph LIKE v_ph)
         GROUP BY c.cpid, c.cpbm, c.pm, c.gg, c.jldw,a.ph,b.sxz
       ) f
      ) g GROUP BY cpid, cpbm, pm, gg, jldw,ph,sxz
      ORDER BY cpbm;
      END stock_product_number;
 ----------------------------------------------------------------
  /**
   * 存货明细报表
   * @param p_data_out  OUT rc,        返回的数据集
   * @param p_startdate_in IN VARCHAR2 开始日期
   * @param p_enddate_in IN VARCHAR2   结束日期
   * @param p_productid_in IN VARCHAR2 产品id
   * @param p_dmsxid_in IN VARCHAR2 规格属性id
   * @param p_storeid_in IN VARCHAR2   仓库id
   * @param p_stocksort_in IN VARCHAR2   存货类别id
   * @param p_startcpbm_in IN VARCHAR2 开始产品编码
   * @param p_endcpbm_in IN VARCHAR2   结束产品编码
   * @param p_pm_in IN VARCHAR2   品名
   * @param p_gg_in IN VARCHAR2  规格
   * @param p_ph_in IN VARCHAR2   批号
   * @param p_fgsid_in IN VARCHAR2     分公司ID
   */
  PROCEDURE stock_product_number_new(
    p_data_out     OUT rc,      --返回的数据集
    p_startdate_in IN VARCHAR2,
    p_enddate_in   IN VARCHAR2,
    p_productid_in  IN VARCHAR2,
    p_dmsxid_in  IN VARCHAR2,
    p_storeid_in  IN VARCHAR2,
    p_stocksort_in  IN VARCHAR2,
    p_startcpbm_in  IN VARCHAR2,
    p_endcpbm_in  IN VARCHAR2,
    p_pm_in  IN VARCHAR2,
    p_gg_in  IN VARCHAR2,
    --p_ph_in  IN VARCHAR2,
    p_fgsid_in     IN VARCHAR2
  )
  IS
    v_start DATE;
    v_end   DATE;
    v_pm VARCHAR2(100);
    v_gg VARCHAR2(100);
    --new
    v_middle   DATE;
    v_checkid jc_checkout.checkid%type;
  BEGIN
    v_start := to_date(p_startdate_in, 'YYYY-MM-DD');
    v_end   := to_date(p_enddate_in, 'YYYY-MM-DD');
    v_pm   :='%'||p_pm_in||'%';
    v_gg   :='%'||p_gg_in||'%';

    --new
    select max(t.checkid) into v_checkid  from jc_checkout t where t.jsrq<=v_start ;
    if(v_checkid>0)then
    select t.jsrq into v_middle  from jc_checkout t where checkid=v_checkid;
    else
    v_middle:=to_date('1900-1-1', 'YYYY-MM-DD');
    end if;

    --打开数据集
     OPEN p_data_out FOR
     ---------------------------------------------------------
      SELECT * FROM (
      SELECT cpid, cpbm, pm, gg, jldw, hsdw, sxz, sum(nvl(kcsl,0)) kcsl,
             sum(nvl(kchssl,0)) kchssl, sum(nvl(wjzssl,0)) wjzssl,
             sum(nvl(wjzfsl,0)) wjzfsl, sum(nvl(kcsl,0))+sum(nvl(hjsl,0)) hjsl,
             sum(nvl(kchssl,0))+sum(nvl(hjhssl,0)) hjhssl,
             sum(nvl(wjzsrhssl,0)) wjzsrhssl,
             sum(nvl(wjzfchssl,0)) wjzfchssl
      FROM
          (
           --得到期初结存期初未记帐的单据也计算
           SELECT  cpid, cpbm, pm, gg, jldw, hsdw, sxz, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
                  (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
                  NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl, NULL wjzsrhssl, NULL  wjzfchssl
            FROM
        (
        --new
           SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, b.sxz, SUM(nvl(a.srsl,0)) srsl,
                  SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
             FROM jc_checkdetail a, kc_dm c, kc_dmsx b
            WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+)
            AND a.checkid=v_checkid AND a.fgsid=p_fgsid_in
            AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
            AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
            AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
            AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
            AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
            AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
            AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
            AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
            GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw,b.sxz
          union all
           SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, b.sxz, SUM(nvl(a.srsl,0)) srsl,
                  SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
        FROM vw_kc_storebill a, kc_dm c, kc_dmsx b
        WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+) and a.sfrq>v_middle
        AND a.sfrq<v_start AND a.fgsid=p_fgsid_in
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw,b.sxz
        ) e
        GROUP BY cpid, cpbm, pm, gg, jldw, hsdw, sxz
        UNION ALL
      --得到查询段时间记帐数量
       SELECT  cpid, cpbm, pm, gg, jldw, hsdw, sxz, (SUM(nvl(srsl,0))-SUM(nvl(fcsl,0))) kcsl,
          (SUM(nvl(srhssl,0))-SUM(nvl(fchssl,0))) kchssl,
          NULL wjzssl, NULL wjzfsl, NULL hjsl, NULL hjhssl, NULL wjzsrhssl, NULL  wjzfchssl
       FROM
       (
         SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, b.sxz, SUM(nvl(a.srsl,0)) srsl,
            SUM(nvl(a.fcsl,0)) fcsl, SUM(nvl(a.srhssl,0)) srhssl, SUM(nvl(a.fchssl,0)) fchssl
            FROM vw_kc_storebill a, kc_dm c,kc_dmsx b

        WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in AND (a.zt=2 OR  a.zt=8)
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw,b.sxz
       ) e
       GROUP BY cpid, cpbm, pm, gg, jldw, hsdw, sxz
        UNION ALL
       SELECT  cpid, cpbm, pm, gg, jldw, hsdw,sxz, NULL kcsl, NULL kchssl, wjzssl, wjzfsl, nvl(wjzssl,0)-nvl(wjzfsl,0) hjsl,
         nvl(wjzsrhssl,0)-nvl(wjzfchssl,0) hjhssl, nvl(wjzsrhssl,0) wjzsrhssl,nvl(wjzfchssl,0) wjzfchssl
       FROM
        --得到该时间段未记帐数据
       (
         SELECT c.cpid, c.cpbm, c.pm, c.gg, c.jldw, c.hsdw, b.sxz, SUM(nvl(a.srsl,0)) wjzssl,
           SUM(nvl(a.fcsl,0)) wjzfsl, SUM(nvl(a.srhssl,0)) wjzsrhssl,
           SUM(nvl(a.fchssl,0)) wjzfchssl
        FROM vw_kc_storebill a, kc_dm c,kc_dmsx b

        WHERE a.cpid=c.cpid AND a.dmsxid=b.dmsxid(+)
        AND  a.sfrq>=v_start AND a.sfrq<=v_end AND a.fgsid=p_fgsid_in AND a.zt<>2 AND a.zt<>8
        AND (p_productid_in IS NULL OR a.cpid = p_productid_in)
        AND (p_storeid_in IS NULL OR a.storeid = p_storeid_in)
        AND (p_dmsxid_in IS NULL OR a.dmsxid = p_dmsxid_in)
        AND (p_stocksort_in IS NULL OR c.chlbid = p_stocksort_in)
        AND (p_startcpbm_in IS NULL OR c.cpbm >= p_startcpbm_in)
        AND (p_endcpbm_in IS NULL OR c.cpbm <= p_endcpbm_in)
        AND (p_pm_in IS NULL OR c.pm LIKE v_pm)
        AND (p_gg_in IS NULL OR c.gg LIKE v_gg)
        GROUP BY c.cpid,c.cpbm, c.pm, c.gg, c.jldw,c.hsdw,b.sxz
       ) f
      ) g GROUP BY cpid, cpbm, pm, gg, jldw, hsdw, sxz ORDER BY cpbm
      ) T ;


      END stock_product_number_new;
 ----------------------------------------------------------------

 ----------------------------------------------------------------
END PCK_STORE_REP;
/

prompt
prompt Creating trigger TG_CG_HT
prompt =========================
prompt
CREATE OR REPLACE TRIGGER TG_CG_HT
  BEFORE INSERT OR UPDATE ON CG_HT
  FOR EACH ROW
DECLARE
  -- local variables here
  --采购合同触发器，更新更新需求计划的已购量
  v_sl     cg_hthw.sl%TYPE;
  v_approvecode VARCHAR2(32) := 'buy_order';
  v_ishssl BOOLEAN;
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', :old.fgsid) = '1';
    FOR c_mx IN( SELECT d.cgsqdhwid, d.cpid, nvl(d.sl,0) sl
                 FROM cg_hthw d WHERE d.cgsqdhwid IS NOT NULL AND d.htid =:new.htid)
    LOOP
      --回填已购量
      pck_produce.updateMRPBuyNum(c_mx.cgsqdhwid, c_mx.cpid, c_mx.sl, v_ishssl);
    END LOOP;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', :old.fgsid) = '1';
    FOR c_mx IN( SELECT d.cgsqdhwid, d.cpid, nvl(d.sl,0) sl
                 FROM cg_hthw d WHERE d.cgsqdhwid IS NOT NULL AND d.htid= :new.htid)
    LOOP
      --回填已购量
      pck_produce.updateMRPBuyNum(c_mx.cgsqdhwid, c_mx.cpid, -1*c_mx.sl, v_ishssl);
    END LOOP;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
  END IF;
END TG_CG_HT;
/

prompt
prompt Creating trigger TG_CG_HTHW
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_CG_HTHW
  AFTER INSERT OR UPDATE OR DELETE ON CG_HTHW
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步库存数量
  -- local variables here
  v_zt    cg_ht.zt%TYPE;
  v_fgsid cg_ht.fgsid%TYPE;
  v_isrefer cg_ht.isrefer%TYPE;
  v_oldsl cg_hthw.sl%TYPE;
  v_sl    cg_hthw.sl%TYPE;
  v_htid  cg_hthw.htid%TYPE;
  v_ishssl BOOLEAN;
BEGIN
  IF((inserting AND :new.cgsqdhwid IS NULL) OR (NOT inserting AND :old.cgsqdhwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_htid := :new.htid;
  ELSE
    v_htid := :old.htid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.isrefer INTO v_zt, v_fgsid, v_isrefer
  FROM cg_ht m WHERE m.htid = v_htid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sl := nvl(:new.sl,0);
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    --回填已购量
    pck_produce.updateMRPBuyNum(:new.cgsqdhwid, :new.cpid, v_sl, v_ishssl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.sl,0);
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    --回填已购量
    pck_produce.updateMRPBuyNum(:old.cgsqdhwid, :old.cpid, -1*v_oldsl, v_ishssl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_sl := nvl(:new.sl,0);
    IF(:old.cgsqdhwid = :new.cgsqdhwid AND v_oldsl = v_sl) THEN
      RETURN;
    END IF;
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    --回填已购量
    IF(:old.cgsqdhwid <> :new.cgsqdhwid) THEN
      pck_produce.updateMRPBuyNum(:new.cgsqdhwid, :new.cpid, v_sl, v_ishssl);
      pck_produce.updateMRPBuyNum(:old.cgsqdhwid, :old.cpid, -1*v_oldsl, v_ishssl);
    ELSE
      pck_produce.updateMRPBuyNum(:old.cgsqdhwid, :old.cpid, v_sl-v_oldsl, v_ishssl);
    END IF;
  END IF;
END TG_CG_HTHW;
/

prompt
prompt Creating trigger TG_CG_HTJHD
prompt ============================
prompt
CREATE OR REPLACE TRIGGER TG_CG_HTJHD
  BEFORE INSERT OR UPDATE ON cg_htjhd
  FOR EACH ROW
DECLARE
  -- local variables here
  --采购进货单触发器
  v_flag INT; --是否是审批通过:1,取消审批:-1
  v_sl   cg_htjhdhw.sl%TYPE;
  v_hssl cg_htjhdhw.hssl%TYPE;
  v_ishssl BOOLEAN;
  v_approvecode VARCHAR2(32);
BEGIN
  IF(nvl(:new.djlx, 1) = -1) THEN
    v_approvecode := 'unbuy_ordergoods';
  ELSE
    v_approvecode := 'buy_ordergoods';
  END IF;
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    v_flag := 1;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    v_flag := -1;
    :new.isrefer := 0;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  FOR c_mx IN( SELECT d.hthwid, d.sl, d.hssl FROM cg_htjhdhw d WHERE d.jhdid=:old.jhdid)
  LOOP
    v_sl := nvl(c_mx.sl,0);
    v_hssl := nvl(c_mx.hssl, 0);
    --更新合同货物实际进货数量
    IF(c_mx.hthwid IS NOT NULL)THEN
      v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', :old.fgsid) = '1';
      pck_store.updateBuyOrderInNum(c_mx.hthwid, v_flag*v_sl, v_flag*v_hssl, v_ishssl);
    END IF;
  END LOOP;
END TG_CG_HTJHD;
/

prompt
prompt Creating trigger TG_CG_HTJHDHW
prompt ==============================
prompt
CREATE OR REPLACE TRIGGER TG_CG_HTJHDHW
  AFTER INSERT OR UPDATE OR DELETE ON cg_htjhdhw
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步库存数量
  -- local variables here
  v_zt      cg_htjhd.zt%TYPE;
  v_fgsid   cg_htjhd.fgsid%TYPE;
  v_isrefer Cg_Htjhd.isrefer%TYPE;
  v_jhdid   cg_htjhdhw.jhdid%TYPE;
  v_oldsl   cg_htjhdhw.sl%TYPE;
  v_sl      cg_htjhdhw.sl%TYPE;
  v_oldhssl cg_htjhdhw.hssl%TYPE;
  v_hssl    cg_htjhdhw.hssl%TYPE;
  v_ishssl  BOOLEAN;
BEGIN
  IF((inserting AND :new.hthwid IS NULL) OR (NOT inserting AND :old.hthwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_jhdid := :new.jhdid;
  ELSE
    v_jhdid := :old.jhdid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.isrefer INTO v_zt, v_fgsid, v_isrefer
  FROM cg_htjhd m WHERE m.jhdid = v_jhdid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sl := nvl(:new.sl,0);
    v_hssl := nvl(:new.hssl,0);
    --更新实进货单数量
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    pck_store.updateBuyOrderInNum(:new.hthwid, v_sl, v_hssl, v_ishssl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    --更新实进货单数量
    v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    pck_store.updateBuyOrderInNum(:old.hthwid, -1*v_oldsl, -1*v_oldhssl, v_ishssl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_sl := nvl(:new.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    v_hssl := nvl(:new.hssl,0);
    IF(:old.hthwid=:new.hthwid AND v_oldsl = v_sl AND v_oldhssl = v_hssl) THEN
      RETURN;
    END IF;
    --更新实进货单数量
    IF(:old.hthwid<>:new.hthwid) THEN
      v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
      pck_store.updateBuyOrderInNum(:new.hthwid, v_sl, v_hssl, v_ishssl);
      pck_store.updateBuyOrderInNum(:old.hthwid, -1*v_oldsl, -1*v_oldhssl, v_ishssl);
    ELSIF(v_oldsl <> v_sl OR v_oldhssl <> v_hssl) THEN
      v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
      pck_store.updateBuyOrderInNum(:old.hthwid, v_sl-v_oldsl, v_hssl-v_oldhssl, v_ishssl);
    END IF;
  END IF;
END TG_CG_HTJHDHW;
/

prompt
prompt Creating trigger TG_CG_SQD
prompt ==========================
prompt
CREATE OR REPLACE TRIGGER TG_CG_SQD
  BEFORE INSERT OR UPDATE ON cg_sqd
  FOR EACH ROW
DECLARE
  --采购申请单
  -- local variables here
  v_approvecode VARCHAR2(32) := 'buy_apply_list';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  ELSIF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
  END IF;
END TG_CG_SQD;
/

prompt
prompt Creating trigger TG_CW_CGFP
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_CW_CGFP
  BEFORE INSERT OR UPDATE ON cw_cgfp
  FOR EACH ROW
DECLARE
  -- local variables here
  --采购发票触发器
  v_flag   INT; --1:审批通过,-1取消审批
  --v_ishssl BOOLEAN;--是否以换算单位为基本单位
  v_approvecode VARCHAR2(32) := 'buy_invoice';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  --
  IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    v_flag := 1;
    :new.isrefer := 1;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    v_flag := -1;
    :new.isrefer := 0;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  --v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', :old.fgsid) = '1';
  FOR c_mx IN( SELECT d.jhdhwid, d.cpid, nvl(d.sl,0) sl, nvl(d.hssl,0) hssl
               FROM cw_cgfpmx d WHERE d.jhdhwid IS NOT NULL AND d.cgfpid= :old.cgfpid)
  LOOP
    --回填已开票量
    UPDATE cg_htjhdhw h
    SET h.skpsl = nvl(h.skpsl,0)  + v_flag*c_mx.sl,
        h.skphsl = nvl(h.skphsl,0)+ v_flag*c_mx.hssl
    WHERE h.jhdhwid = c_mx.jhdhwid;
    --pck_store.updateBuyInvoiceNum(c_mx.jhdhwid, c_mx.cpid, v_flag*c_mx.sl, v_ishssl);
  END LOOP;
END TG_CW_CGFP;
/

prompt
prompt Creating trigger TG_CW_CGFPMX
prompt =============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_CGFPMX
  AFTER INSERT OR UPDATE OR DELETE ON cw_cgfpmx
  FOR EACH ROW
DECLARE
  --采购发票明细触发器，用于同步库存数量
  -- local variables here
  v_zt      cw_cgfp.zt%TYPE;
  v_fgsid   cw_cgfp.fgsid%TYPE;
  v_isrefer cw_cgfp.isrefer%TYPE;
  v_cgfpid  cw_cgfpmx.cgfpid%TYPE;
  v_oldsl   cw_cgfpmx.sl%TYPE;
  v_sl      cw_cgfpmx.sl%TYPE;
  v_oldhssl cw_cgfpmx.hssl%TYPE;
  v_hssl    cw_cgfpmx.hssl%TYPE;
  --v_ishssl  BOOLEAN;
BEGIN
  --进货单货物ID必须不为空
  IF((inserting AND :new.jhdhwid IS NULL) OR (NOT inserting AND :old.jhdhwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_cgfpid := :new.cgfpid;
  ELSE
    v_cgfpid := :old.cgfpid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.isrefer INTO v_zt, v_fgsid, v_isrefer
  FROM cw_cgfp m WHERE m.cgfpid = v_cgfpid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sl := nvl(:new.sl,0);
    v_hssl := nvl(:new.hssl,0);
    --回填已开票量. 2004.5.10 添加hssl后，不需要用换算比例来计算换算数量
    --v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    UPDATE cg_htjhdhw h
    SET h.skpsl = nvl(h.skpsl,0)  + v_sl,
        h.skphsl = nvl(h.skphsl,0)+ v_hssl
    WHERE h.jhdhwid = :new.jhdhwid;
    --pck_store.updateBuyInvoiceNum(:new.jhdhwid, :new.cpid, v_sl, v_ishssl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    --回填已开票量
    --v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    UPDATE cg_htjhdhw h
    SET h.skpsl = nvl(h.skpsl,0)  - v_oldsl,
        h.skphsl = nvl(h.skphsl,0)- v_oldhssl
    WHERE h.jhdhwid = :old.jhdhwid;
    --pck_store.updateBuyInvoiceNum(:old.jhdhwid, :old.cpid, -1*v_oldsl, v_ishssl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    v_sl := nvl(:new.sl,0);
    v_hssl := nvl(:new.hssl,0);
    IF(v_oldsl = v_sl AND v_oldhssl = v_hssl) THEN
      RETURN;
    END IF;
    --回填已开票量
    --v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
    UPDATE cg_htjhdhw h
    SET h.skpsl = nvl(h.skpsl,0)  + v_sl-v_oldsl,
        h.skphsl = nvl(h.skphsl,0)+ v_hssl-v_oldhssl
    WHERE h.jhdhwid = :new.jhdhwid;
    /*
    IF(:old.jhdhwid<>:new.jhdhwid) THEN
      pck_store.updateBuyInvoiceNum(:new.jhdhwid, :new.cpid, v_sl, v_ishssl);
      pck_store.updateBuyInvoiceNum(:old.jhdhwid, :old.cpid, -1*v_oldsl, v_ishssl);
    ELSE
      pck_store.updateBuyInvoiceNum(:old.jhdhwid, :old.cpid, v_sl-v_oldsl, v_ishssl);
    END IF;*/
  END IF;
END TG_CW_CGFPMX;
/

prompt
prompt Creating trigger TG_CW_CGJS
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_CW_CGJS
  BEFORE INSERT OR UPDATE OR DELETE ON cw_cgjs
  FOR EACH ROW
DECLARE
  --销售结算核销(明细)触发器
  -- local variables here
  v_approvecode VARCHAR2(32) := 'buy_balance';
BEGIN
  IF(inserting) THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
      --冲减预付款
      IF(nvl(:new.cjyf,0) >0) THEN
        UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
      END IF;
    ELSE
      :new.isrefer := 0;
    END IF;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    --冲减单位变更
    IF(updating AND :old.dwtxid <> :new.dwtxid) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+nvl(:old.cjyf,0)
      WHERE d.fgsid=:old.fgsid AND d.dwtxid=:old.dwtxid;
      --
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-nvl(:new.cjyf,0)
      WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    --冲减金额变更
    ELSIF(updating AND nvl(:old.cjyf,0) <> nvl(:new.cjyf,0)) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+nvl(:old.cjyf,0)-nvl(:new.cjyf,0)
      WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    ELSIF(deleting AND nvl(:old.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+:old.cjyf WHERE d.fgsid=:old.fgsid AND d.dwtxid=:old.dwtxid;
    END IF;
  ELSIF(updating AND (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    --冲减预付款
    IF(nvl(:new.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    END IF;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    --负冲减预付款
    IF(nvl(:new.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    END IF;
  --非法状态的变更
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
  END IF;
END TG_CW_CGJS;
/

prompt
prompt Creating trigger TG_CW_CGJSHX
prompt =============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_CGJSHX
  AFTER INSERT OR UPDATE OR DELETE ON cw_cgjshx
  FOR EACH ROW
DECLARE
  --销售结算核销(明细)触发器
  -- local variables here
  v_zt      cw_cgjs.zt%TYPE;
  v_fgsid   cw_cgjs.fgsid%TYPE;
  v_isrefer cw_cgjs.isrefer%TYPE;
  v_cgjsid  cw_cgjshx.cgjsid%TYPE;
  v_oldjsje cw_cgjshx.jsje%TYPE;
  v_jsje    cw_cgjshx.jsje%TYPE;
BEGIN
  IF((inserting AND :new.jhdhwid IS NULL) OR (NOT inserting AND :old.jhdhwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_cgjsid := :new.cgjsid;
  ELSE
    v_cgjsid := :old.cgjsid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.isrefer INTO v_zt, v_fgsid, v_isrefer
  FROM cw_cgjs m WHERE m.cgjsid = v_cgjsid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_jsje := nvl(:new.jsje,0);
    --回填已结算金额
    UPDATE cg_htjhdhw t SET t.sfje = nvl(t.sfje,0)+v_jsje WHERE t.jhdhwid = :new.jhdhwid;
  ELSIF(deleting) THEN
    v_oldjsje := nvl(:old.jsje,0);
    --回填已结算金额
    UPDATE cg_htjhdhw t SET t.sfje = nvl(t.sfje,0)-v_oldjsje WHERE t.jhdhwid = :old.jhdhwid;
  ELSIF(updating) THEN
    v_oldjsje := nvl(:old.jsje,0);
    v_jsje := nvl(:new.jsje,0);
    IF(:old.jhdhwid = :new.jhdhwid AND v_oldjsje = v_jsje) THEN
      RETURN;
    END IF;
    --回填已结算金额
    IF(:old.jhdhwid <> :new.jhdhwid)THEN
      UPDATE cg_htjhdhw t SET t.sfje = nvl(t.sfje,0) + v_jsje  WHERE t.jhdhwid = :new.jhdhwid;
      UPDATE cg_htjhdhw t SET t.sfje = nvl(t.sfje,0) - v_oldjsje WHERE t.jhdhwid = :old.jhdhwid;
    ELSE
      UPDATE cg_htjhdhw t SET t.sfje = nvl(t.sfje,0) + v_jsje - v_oldjsje
      WHERE t.jhdhwid = :old.jhdhwid;
    END IF;
  END IF;
END TG_CW_CGJSHX;
/

prompt
prompt Creating trigger TG_CW_CGYFK
prompt ============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_CGYFK
  BEFORE INSERT OR UPDATE OR DELETE ON cw_cgyfk
  FOR EACH ROW
DECLARE
  --采购预付款
  -- local variables here
  --cw_cgyfk.je
  v_approvecode VARCHAR2(32) := 'advance_payment';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+nvl(:new.je,0)
      WHERE  d.fgsid = :new.fgsid AND d.dwtxid = :new.dwtxid;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    IF(deleting) THEN
      --减少旧单位
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) - nvl(:old.je,0)
      WHERE  d.fgsid = :old.fgsid AND d.dwtxid = :old.dwtxid;
    ELSIF(:old.dwtxid <> :new.dwtxid) THEN
      --增加新单位
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) + nvl(:new.je,0)
      WHERE  d.fgsid = :new.fgsid AND d.dwtxid = :new.dwtxid;
      --减少旧单位
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) - nvl(:old.je,0)
      WHERE  d.fgsid = :old.fgsid AND d.dwtxid = :old.dwtxid;
    ELSIF(nvl(:old.je,0) <> nvl(:new.je,0))THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) + nvl(:new.je,0) - nvl(:old.je,0)
      WHERE  d.fgsid = :new.fgsid AND d.dwtxid = :new.dwtxid;
    END IF;
  ELSIF(updating AND (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) + nvl(:new.je,0)
    WHERE  d.fgsid = :new.fgsid AND d.dwtxid = :new.dwtxid;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 0) THEN--取消审批
    :new.isrefer := 0;
    UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0) - nvl(:new.je,0)
    WHERE  d.fgsid = :new.fgsid AND d.dwtxid = :new.dwtxid;
  --非法状态的变更
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
  END IF;
END TG_CW_CGYFK;
/

prompt
prompt Creating trigger TG_CW_WJGJS
prompt ============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_WJGJS
  BEFORE INSERT OR UPDATE ON cw_wjgjs
  FOR EACH ROW
DECLARE
  --外加工结算
  -- local variables here
  v_approvecode VARCHAR2(32) := 'out_process_balance';
BEGIN
  IF(inserting) THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
      --冲减预付款
      IF(nvl(:new.cjyf,0) >0) THEN
        UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
      END IF;
    ELSE
      :new.isrefer := 0;
    END IF;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    --冲减单位变更
    IF(updating AND :old.dwtxid <> :new.dwtxid) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+nvl(:old.cjyf,0)
      WHERE d.fgsid=:old.fgsid AND d.dwtxid=:old.dwtxid;
      --
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-nvl(:new.cjyf,0)
      WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    --冲减金额变更
    ELSIF(updating AND nvl(:old.cjyf,0) <> nvl(:new.cjyf,0)) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+nvl(:old.cjyf,0)-nvl(:new.cjyf,0)
      WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    ELSIF(deleting AND nvl(:old.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+:old.cjyf WHERE d.fgsid=:old.fgsid AND d.dwtxid=:old.dwtxid;
    END IF;
  ELSIF(updating AND (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    --冲减预付款
    IF(nvl(:new.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)-:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    END IF;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    --负冲减预付款
    IF(nvl(:new.cjyf,0) >0) THEN
      UPDATE dwtx d SET d.yfkje = nvl(d.yfkje,0)+:new.cjyf WHERE d.fgsid=:new.fgsid AND d.dwtxid=:new.dwtxid;
    END IF;
  --非法状态的变更
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
  END IF;
END TG_CW_WJGJS;
/

prompt
prompt Creating trigger TG_CW_WJGJSHX
prompt ==============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_WJGJSHX
  AFTER INSERT OR UPDATE OR DELETE ON cw_wjgjshx
  FOR EACH ROW
DECLARE
  --销售结算核销(明细)触发器
  -- local variables here
  v_fgsid   cw_wjgjs.fgsid%TYPE;
  v_isrefer cw_wjgjs.isrefer%TYPE;
  v_wjgjsid cw_wjgjshx.wjgjsid%TYPE;
  v_oldjsje cw_wjgjshx.jsje%TYPE;
  v_jsje    cw_wjgjshx.jsje%TYPE;
BEGIN
  IF((inserting AND :new.jgdmxid IS NULL) OR (NOT inserting AND :old.jgdmxid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_wjgjsid := :new.wjgjsid;
  ELSE
    v_wjgjsid := :old.wjgjsid;
  END IF;
  --
  SELECT m.fgsid, m.isrefer INTO v_fgsid, v_isrefer
  FROM cw_wjgjs m WHERE m.wjgjsid = v_wjgjsid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_jsje := nvl(:new.jsje,0);
    --回填已结算金额
    UPDATE sc_jgdmx t SET t.yfjgje = nvl(t.yfjgje,0)+v_jsje WHERE t.jgdmxid = :new.jgdmxid;
  ELSIF(deleting) THEN
    v_oldjsje := nvl(:old.jsje,0);
    --回填已结算金额
    UPDATE sc_jgdmx t SET t.yfjgje = nvl(t.yfjgje,0)-v_oldjsje WHERE t.jgdmxid = :old.jgdmxid;
  ELSIF(updating) THEN
    v_oldjsje := nvl(:old.jsje,0);
    v_jsje := nvl(:new.jsje,0);
    IF(:old.jgdmxid = :new.jgdmxid AND v_oldjsje = v_jsje) THEN
      RETURN;
    END IF;
    --回填已结算金额
    IF(:old.jgdmxid <> :new.jgdmxid)THEN
      UPDATE sc_jgdmx t SET t.yfjgje = nvl(t.yfjgje,0) + v_jsje  WHERE t.jgdmxid = :new.jgdmxid;
      UPDATE sc_jgdmx t SET t.yfjgje = nvl(t.yfjgje,0) - v_oldjsje WHERE t.jgdmxid = :old.jgdmxid;
    ELSE
      UPDATE sc_jgdmx t SET t.yfjgje = nvl(t.yfjgje,0) + v_jsje - v_oldjsje
      WHERE t.jgdmxid = :old.jgdmxid;
    END IF;
  END IF;
END TG_CW_WJGJSHX;
/

prompt
prompt Creating trigger TG_CW_XSFP
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_CW_XSFP
  BEFORE INSERT OR UPDATE ON cw_xsfp
  FOR EACH ROW
DECLARE
  -- local variables here
  --销售发票触发器
  v_flag   INT; --1:审批通过,-1取消审批
  v_approvecode VARCHAR2(32) := 'sale_invoice';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    v_flag := 1;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    v_flag := -1;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  FOR c_mx IN( SELECT d.tdhwid, d.cpid, nvl(d.sl,0) sl
               FROM cw_xsfpmx d WHERE d.tdhwid IS NOT NULL AND d.xsfpid = :old.xsfpid)
  LOOP
    --回填已开票量
    pck_store.updateLadingInvoiceNum(c_mx.tdhwid, v_flag*c_mx.sl);
  END LOOP;
END TG_CW_XSFP;
/

prompt
prompt Creating trigger TG_CW_XSFPMX
prompt =============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_XSFPMX
  AFTER INSERT OR UPDATE OR DELETE ON cw_xsfpmx
  FOR EACH ROW
DECLARE
  --销售发票明细触发器，用于同步库存数量
  -- local variables here
  v_zt      cw_xsfp.zt%TYPE;
  v_isrefer cw_xsfp.isrefer%TYPE;
  v_fgsid   cw_xsfp.fgsid%TYPE;
  v_xsfpid  cw_xsfpmx.xsfpid%TYPE;
  v_oldsl   cw_xsfpmx.sl%TYPE;
  v_sl      cw_xsfpmx.sl%TYPE;
  v_ishssl  BOOLEAN;
BEGIN
  IF((inserting AND :new.tdhwid IS NULL) OR (NOT inserting AND :old.tdhwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_xsfpid := :new.xsfpid;
  ELSE
    v_xsfpid := :old.xsfpid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.isrefer INTO v_zt, v_fgsid, v_isrefer
  FROM cw_xsfp m WHERE m.xsfpid = v_xsfpid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sl := nvl(:new.sl,0);
    --回填已开票量
    pck_store.updateLadingInvoiceNum(:new.tdhwid, v_sl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.sl,0);
    --回填已开票量
    pck_store.updateLadingInvoiceNum(:old.tdhwid, -1*v_oldsl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_sl := nvl(:new.sl,0);
    IF(:old.tdhwid=:new.tdhwid AND v_oldsl = v_sl) THEN
      RETURN;
    END IF;
    --回填已开票量
    IF(:old.tdhwid<>:new.tdhwid) THEN
      pck_store.updateLadingInvoiceNum(:new.tdhwid, v_sl);
      pck_store.updateLadingInvoiceNum(:old.tdhwid, -1*v_oldsl);
    ELSE
      pck_store.updateLadingInvoiceNum(:old.tdhwid, v_sl-v_oldsl);
    END IF;
  END IF;
END TG_CW_XSFPMX;
/

prompt
prompt Creating trigger TG_CW_XSJS
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_CW_XSJS
  BEFORE INSERT OR UPDATE OR DELETE ON cw_xsjs
  FOR EACH ROW
DECLARE
  -- local variables here
  --销售结算触发器
  v_flag   INT; --1:审批通过,-1取消审批
  v_approvecode VARCHAR2(32) := 'sale_balance';
  v_isafter     BOOLEAN;
BEGIN
  v_isafter := pck_approve.isafterapprove(v_approvecode);
  IF(inserting)THEN
    IF(v_isafter)THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
  END IF;
  IF(inserting AND (:new.zt=1 OR v_isafter) ) THEN
    :new.isrefer := 1;
    /*2004.7.29 用视图代替客户信誉额度锁定量--更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:new.dwtxid, -1*nvl(:new.je,0), :new.fgsid);
    --更新客户的应收款
    pck_store.updateCustReceivableAccount(:new.dwtxid, -1*nvl(:new.je,0), :new.fgsid);
    ELSIF(deleting AND (:old.zt=1 OR v_isafter) ) THEN
    --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, nvl(:old.je,0), :old.fgsid);
    --更新客户的应收款
    pck_store.updateCustReceivableAccount(:old.dwtxid, nvl(:old.je,0), :old.fgsid);
    --没有审批流程直接修改
    ELSIF(updating AND ((:old.zt=1 AND :new.zt=1) OR v_isafter) ) THEN
      IF(:old.dwtxid=:new.dwtxid AND :old.je=:new.je) THEN
        RETURN;
      END IF;
      --更新单位信誉度锁定量, 应收款
      IF(:old.dwtxid<>:new.dwtxid)THEN
        pck_store.updateCustCreditNum(:new.dwtxid, -1*nvl(:new.je,0), :new.fgsid);
        pck_store.updateCustCreditNum(:old.dwtxid, nvl(:old.je,0), :old.fgsid);
        --
        pck_store.updateCustReceivableAccount(:new.dwtxid, -1*nvl(:new.je,0), :new.fgsid);
        pck_store.updateCustReceivableAccount(:old.dwtxid, -1*nvl(:old.je,0), :old.fgsid);
      ELSE
        pck_store.updateCustCreditNum(:old.dwtxid, -1*nvl(:new.je,0)+nvl(:old.je,0), :old.fgsid);
        pck_store.updateCustReceivableAccount(:old.dwtxid, -1*nvl(:new.je,0)+nvl(:old.je,0), :old.fgsid);
      END IF;*/
  --若是事后审批，则返回
  ELSIF(v_isafter) THEN
    RETURN;
  --定义审批流程，将不会触发从表的触发器
  ELSIF(updating) THEN
    IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
      :new.isrefer := 1;
      v_flag := 1;
    ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
      :new.isrefer := 0;
      v_flag := -1;
    --非法状态的变更
    ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
      :new.zt := 1;
      RETURN;
    ELSE
      RETURN;
    END IF;
    --
    FOR c_mx IN( SELECT d.tdhwid, d.cpid, nvl(d.jsje,0) jsje
                 FROM cw_xsjshx d WHERE d.tdhwid IS NOT NULL AND d.xsjsid = :old.xsjsid)
    LOOP
      /*2004.7.29 用视图代替客户信誉额度锁定量
      --更新单位信誉度锁定量
      pck_store.updateCustCreditNum(:old.dwtxid, -1*v_flag*c_mx.jsje, :old.fgsid);
      --更新单位信誉度应收款
      pck_store.updateCustReceivableAccount(:old.dwtxid, -1*v_flag*c_mx.jsje, :old.fgsid);
      */
      --回填已结算金额
      UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0) + v_flag*c_mx.jsje
      WHERE t.tdhwid = c_mx.tdhwid;
    END LOOP;
  END IF;
END TG_CW_XSJS;
/

prompt
prompt Creating trigger TG_CW_XSJSHX
prompt =============================
prompt
CREATE OR REPLACE TRIGGER TG_CW_XSJSHX
  AFTER INSERT OR UPDATE OR DELETE ON cw_xsjshx
  FOR EACH ROW
DECLARE
  --销售结算核销(明细)触发器
  -- local variables here
  v_fgsid   cw_xsjs.fgsid%TYPE;
  v_isrefer cw_xsjs.isrefer%TYPE;
  v_xsjsid  cw_xsjshx.xsjsid%TYPE;
  v_oldjsje cw_xsjshx.jsje%TYPE;
  v_jsje    cw_xsjshx.jsje%TYPE;
BEGIN
  --注:单位信誉度锁定量与单位有关在主表触发,因为主表的dwtxid变动时，从表的触发器不可得到变动信息
  IF((inserting AND :new.tdhwid IS NULL) OR (NOT inserting AND :old.tdhwid IS NULL)) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_xsjsid := :new.xsjsid;
  ELSE
    v_xsjsid := :old.xsjsid;
  END IF;
  --
  SELECT m.isrefer, m.fgsid INTO v_isrefer, v_fgsid
  FROM cw_xsjs m WHERE m.xsjsid = v_xsjsid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_jsje := nvl(:new.jsje,0);
    --回填已结算金额
    UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0)+v_jsje WHERE t.tdhwid = :new.tdhwid;
  ELSIF(deleting) THEN
    v_oldjsje := nvl(:old.jsje,0);
    --回填已结算金额
    UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0)-v_oldjsje WHERE t.tdhwid = :old.tdhwid;
  ELSIF(updating) THEN
    v_oldjsje := nvl(:old.jsje,0);
    v_jsje := nvl(:new.jsje,0);
    IF(:old.tdhwid = :new.tdhwid AND v_oldjsje = v_jsje) THEN
      RETURN;
    END IF;
    --回填已结算金额
    IF(:old.tdhwid <> :new.tdhwid)THEN
      UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0) + v_jsje  WHERE t.tdhwid = :new.tdhwid;
      UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0) - v_oldjsje WHERE t.tdhwid = :old.tdhwid;
    ELSE
      UPDATE xs_tdhw t SET t.ssje = nvl(t.ssje,0) + v_jsje - v_oldjsje
      WHERE t.tdhwid = :old.tdhwid;
    END IF;
  END IF;
END TG_CW_XSJSHX;
/

prompt
prompt Creating trigger TG_KC_DM
prompt =========================
prompt
CREATE OR REPLACE TRIGGER TG_KC_DM
  BEFORE UPDATE OR DELETE ON kc_dm
  FOR EACH ROW
--将更改前的信息保存到物资代码更改的历史记录中。条件:new.isdelete=0
DECLARE
  -- local variables here
  ls kc_dm_ls%ROWTYPE;
BEGIN
  /*IF(deleting)THEN
    --
    INSERT INTO kc_dm_ls(cplsid, cpid, wzlb, cpbm, zjm, pm, gg, txm, th, abc,
      jjff, jldw, hsdw, hsbl, maxsl, minsl, jhdj, chxz, tqq, bz,
      isprops, issale, cscj, xgr, gxsj)
    VALUES (s_kc_dm_ls.NEXTVAL, :old.cpid, ls.wzlb, :old.cpbm, :old.zjm, :old.pm, :old.gg, :old.txm, :old.th, :old.abc,
      :old.jjff, :old.jldw, :old.hsdw, :old.hsbl, :old.maxsl, :old.minsl, :old.jhdj, :old.chxz, :old.tqq, :old.bz,
      :old.isprops, :old.issale, ls.cscj, :old.xgr, SYSDATE);
  */
  --
  IF (deleting OR (updating AND :new.isdelete=0 AND :old.ztqq=:new.ztqq)) THEN
    --是否更新了提前期
    /*IF(updating AND :old.tqq <> :new.tqq) THEN
      pck_produce.updateBomProduceTime(:new.cpid);
    END IF;*/
    SELECT s_kc_dm_ls.NEXTVAL INTO ls.cplsid FROM dual;
    --得到生产车间
    BEGIN
      SELECT b.mc INTO ls.cscj FROM bm b WHERE b.deptid = :old.deptid;
    EXCEPTION
      WHEN OTHERS THEN
        ls.cscj := '';
    END;
    --得到物资类别
    BEGIN
      SELECT l.mc INTO ls.wzlb FROM kc_dmlb l WHERE l.wzlbid = :old.wzlbid;
    EXCEPTION
      WHEN OTHERS THEN
        ls.wzlb := '';
    END;
    --得到仓库名称
    BEGIN
      SELECT c.ckmc INTO ls.ckmc FROM kc_ck c WHERE c.storeid = :old.storeid;
    EXCEPTION
      WHEN OTHERS THEN
        ls.ckmc := '';
    END;
    --
    ls.cpid := :old.cpid;
    ls.cpbm := :old.cpbm;
    ls.zjm  := :old.zjm;
    ls.pm   := :old.pm;
    ls.gg   := :old.gg;
    ls.txm  := :old.txm;
    ls.th   := :old.th;
    ls.abc  := :old.abc;
    ls.jjff := :old.jjff;
    ls.jldw := :old.jldw;
    ls.hsdw := :old.hsdw;
    ls.hsbl := :old.hsbl;
    ls.maxsl:= :old.maxsl;
    ls.minsl:= :old.minsl;
    ls.jhdj := :old.jhdj;
    ls.chxz := :old.chxz;
    ls.tqq  := :old.tqq;
    ls.bz   := :old.bz;
    ls.isprops := :old.isprops;
    ls.issale  := :old.issale;
    ls.xgr  := :old.xgr;
    ls.gxsj := SYSDATE;
    --
    INSERT INTO kc_dm_ls VALUES ls;
  END IF;
END TG_KC_DM;
/

prompt
prompt Creating trigger TG_KC_SFDJ
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER tg_kc_sfdj
  BEFORE UPDATE OR INSERT ON kc_sfdj
  FOR EACH ROW
DECLARE
  -- local variables here
  --库存收发单据触发器，用于减少库存数量
  --v_wzmxid  kc_wzmx.wzmxid%TYPE;
  v_djxz    kc_sfdj.djxz%TYPE;
  v_dwtxid  kc_sfdj.dwtxid%TYPE := NULL;
  --v_isrefer kc_sfdj.isrefer%TYPE;;
  --v_oldisrefer kc_sfdj.isrefer%TYPE;;
  --v_sl      kc_sfdjmx.sl%TYPE;
  --v_hssl    kc_sfdjmx.hssl%TYPE;
  --v_sign INT;
  v_iswzmxadd   BOOLEAN; --是否添加了物资明细id
  v_ishssl      BOOLEAN;
  v_flag        INT;
  v_approvecode VARCHAR2(32);
  v_isafter     BOOLEAN;
BEGIN
  v_djxz := :new.djxz;
  IF(v_djxz = 1) THEN
    v_approvecode := 'contract_instore_list';
  --ELSIF(v_djxz = 5) THEN
    --v_approvecode := 'process_instore_list';
  ELSIF(v_djxz = 7) THEN
    v_approvecode := 'report_destroy_list';
  ELSIF(v_djxz = 9) THEN
    v_approvecode := 'other_instore_list';
  ELSIF(v_djxz = 2) THEN
    v_approvecode := 'outputlist';--销售出库
  --ELSIF(v_djxz = 6) THEN
    --v_approvecode := 'process_issue_list';  --外加工发料
  ELSIF(v_djxz = 8) THEN
    v_approvecode := 'move_store_list';
  ELSIF(v_djxz = 10) THEN --05.01.28 新增 其它出库单djxz=10 yjg
    v_approvecode := 'other_outstore_list';
  END IF;
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSE
    v_isafter := pck_approve.isafterapprove(v_approvecode);
    IF(v_isafter)THEN
      RETURN;
    END IF;
  END IF;
  --注: 可能存在审批流程的更改;
  --1.事后审批->事前审批，此时已有的记录再进行审批,将不再记帐(:old.isrefer=1)
  --2.事前审批->事后审批, 此时审批通过的记录取消审批,将不反记帐
  --  此时存在风险: 若还有未审批的数据，必须需要全部审批通过，才可以更改审批流程的设置
  --  应为此时,触发器将不知道改单据是否属于改为事后审批后添加的单据。将会产生记帐的差距。
  --以下是事前审批的操作
  --------------------------------------------------------------------
  --1=合同入库单, 7=损溢单, 9=其他入库单 --(3=自制入库单5=外加工入库单)
  --------------------------------------------------------------------
  IF(v_djxz = 1 OR v_djxz = 7 OR v_djxz = 9)THEN --v_djxz = 3 v_djxz = 5
    --有审批流程, 审批通过或事后审批的
    --（审批通过或事后审批的）并且未记帐
    IF( (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN
      v_flag := 1;
      :new.isrefer := 1;
    --事前审批并取消审批, 则反记帐
    ELSIF( :old.zt = 1 AND :new.zt = 0) THEN
      v_flag := -1;
      :new.isrefer := 0;
    --非法状态的变更
    ELSIF( :old.zt = 1 AND :new.zt = 9) THEN
      :new.zt := 1;
      RETURN;
    ELSE
      RETURN;
    END IF;
    --
    --是否 合同入库单
    IF(v_djxz = 1) THEN
      v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', :old.fgsid) = '1';
      FOR c_mx IN(
        SELECT d.rkdmxid, d.cpid, d.dmsxid, d.kwid, d.wjid, nvl(d.sl,0) sl,
               d.ph, d.bz, nvl(d.hssl,0) hssl, d.wzmxid
        FROM kc_sfdjmx d WHERE d.sfdjid = :old.sfdjid AND d.wjid IS NOT NULL)
      LOOP
      --更新库存量
      --2004.6.12 用视图代替表
      --更新计划可供量 2004.2.28 增加规格属性ID有关, 2004.6.22 废弃计划可供量表
      --pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, v_flag*c_mx.sl);
      --更新合同进货量
        pck_store.updateBuyInStoreNum(c_mx.wjid, c_mx.cpid, v_flag*c_mx.sl, v_flag*c_mx.hssl, v_ishssl);
      END LOOP;
    END IF;
  --2003.4.5--(4=生产领料单, 6=外加工发料单 两单据在sc_resc_receiveProd)
  ------------------------------------------
  --2=销售出库单,
  ------------------------------------------
  ELSIF(v_djxz = 2 OR v_djxz = 10) THEN --v_djxz = 4 OR v_djxz = 6 --05.01.28 新增 or v_djxz=10 其它出库单 yjg
    --没有审批流程
    --2004.6.12 用视图代替表
    --有审批流程
    IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
      v_flag := 1;
      :new.isrefer := 1;
    ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
      v_flag := -1;
      :new.isrefer := 0;
    --非法状态的变更
    ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
      :new.zt := 1;
      RETURN;
    ELSE
      RETURN;
    END IF;
    --销售出库单
    IF(v_djxz = 2) THEN
      FOR c_mx IN(
        SELECT d.rkdmxid, d.cpid, d.dmsxid, d.kwid, d.wjid, nvl(d.sl,0) sl,
               d.ph, d.bz, nvl(d.hssl,0) hssl, d.wzmxid
        FROM kc_sfdjmx d WHERE d.sfdjid = :old.sfdjid)
      LOOP
        --2004.6.12 用视图代替表
        --更新实提数量
        IF(c_mx.wjid IS NOT NULL) THEN
          pck_store.updateSaleOutStoreNum(c_mx.wjid, c_mx.cpid, v_flag*c_mx.sl, v_flag*c_mx.hssl, :old.fgsid, :old.sfrq);
        END IF;
      END LOOP;
    END IF;
  ----------
  --8=移库单
  ----------
  ELSIF(v_djxz = 8) THEN
    --2004.6.12 用视图代替表
    IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
      v_flag := 1;
      :new.isrefer := 1;
    ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
      v_flag := -1;
      :new.isrefer := 0;
    --非法状态的变更
    ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
      :new.zt := 1;
      RETURN;
    ELSE
      RETURN;
    END IF;
    --
  END IF;
  /*
  IF(updating)THEN
    IF(:old.djxz IS NOT NULL)THEN
      NULL;--pck_store.updaDAFAockNumber(:old.wzmxid, nvl(:old.stzl,0), nvl(:old.stjs,0));
    END IF;
    IF(:new.djxz is NOT NULL)THEN
      NULL;--pck_store.updaDAFAockNumber(:new.wzmxid, -1*nvl(:new.stzl,0), -1*nvl(:new.stjs,0));
    END IF;
  ELSIF(deleting)THEN
    NULL;--pck_store.updaDAFAockNumber(:old.wzmxid, nvl(:old.stzl,0), nvl(:old.stjs,0));
  END IF;      */
END tg_kc_sfdj;
/

prompt
prompt Creating trigger TG_KC_SFDJMX
prompt =============================
prompt
CREATE OR REPLACE TRIGGER tg_kc_sfdjmx
  BEFORE INSERT OR UPDATE OR DELETE ON kc_sfdjmx
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步库存数量
  -- local variables here
  v_djxz    kc_sfdj.djxz%TYPE;
  v_zt      kc_sfdj.zt%TYPE;
  v_isrefer kc_sfdj.isrefer%TYPE;
  v_dwtxid  kc_sfdj.dwtxid%TYPE;
  v_fgsid   kc_sfdj.fgsid%TYPE;
  v_storeid kc_sfdj.storeid%TYPE;
  v_sfrq    kc_sfdj.sfrq%TYPE;
  v_in_storeid kc_sfdj.kc__storeid%TYPE;--调入仓库
  v_sfdjid  kc_sfdjmx.sfdjid%TYPE;
  v_wzmxid  kc_sfdjmx.wzmxid%TYPE;
  v_oldsl   kc_sfdjmx.sl%TYPE;
  v_sl      kc_sfdjmx.sl%TYPE;
  v_oldhssl kc_sfdjmx.hssl%TYPE;
  v_hssl    kc_sfdjmx.hssl%TYPE;
  v_ishssl  BOOLEAN;
BEGIN
  --表示主表触发器更新从表的wzmxid，不处理，以免报错
  IF(updating AND nvl(:old.wzmxid,0) <> nvl(:new.wzmxid,0)) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sfdjid := :new.sfdjid;
  ELSE
    v_sfdjid := :old.sfdjid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.djxz, m.storeid, m.kc__storeid,
         m.isrefer, decode(m.djxz,7,NULL,m.dwtxid), m.sfrq
  INTO   v_zt, v_fgsid, v_djxz, v_storeid, v_in_storeid,
         v_isrefer, v_dwtxid, v_sfrq
  FROM   kc_sfdj m WHERE m.sfdjid = v_sfdjid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --1=合同入库单,3=自制入库单,5=外加工入库单,7=报损单,9=其他入库单
  IF(v_djxz = 1 OR v_djxz = 3 OR v_djxz = 5 OR v_djxz = 7 OR v_djxz = 9)THEN
    IF(inserting) THEN
      --2004.6.12 用视图代替表
      v_sl := nvl(:new.sl,0);
      v_hssl := nvl(:new.hssl,0);
      --更新计划可供量 2004.6.22 废弃计划可供量表
      --pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, v_sl);
      --更新合同进货量
      IF(v_djxz = 1 AND :new.wjid IS NOT NULL)THEN
        v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
        pck_store.updateBuyInStoreNum(:new.wjid, :new.cpid, v_sl, v_hssl, v_ishssl);
      END IF;
    ELSIF(deleting) THEN
      v_oldsl := nvl(:old.sl,0);
      v_oldhssl := nvl(:old.hssl,0);
      --更新计划可供量 2004.6.22 废弃计划可供量表
      --pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, -1*v_oldsl);
      --更新合同进货量
      IF(v_djxz = 1 AND :old.wjid IS NOT NULL)THEN
        v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
        pck_store.updateBuyInStoreNum(:old.wjid, :old.cpid, -1*v_oldsl, -1*v_oldhssl, v_ishssl);
      END IF;
    ELSIF(updating) THEN
      v_oldsl := nvl(:old.sl,0);
      v_sl := nvl(:new.sl,0);
      v_oldhssl := nvl(:old.hssl,0);
      v_hssl := nvl(:new.hssl,0);
      IF(nvl(:old.cpid,-100)<>nvl(:new.cpid,-100) OR nvl(:old.kwid,-100)<>nvl(:new.kwid,-100) OR
         nvl(:old.dmsxid,-100)<>nvl(:new.dmsxid,-100) OR nvl(:old.ph,'@#$%^')<>nvl(:new.ph,'@#$%^')
        )THEN
        --更新计划可供量 2004.2.28 增加规格属性id有关的计划可供量 2004.6.22 废弃计划可供量表
        /*IF(nvl(:old.cpid,-100)<>nvl(:new.cpid,-100) OR nvl(:old.dmsxid,-100)<>nvl(:new.dmsxid,-100))THEN
          pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, -1*v_oldsl);
          pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, v_sl);
        ELSIF(v_oldsl <> v_sl OR v_oldhssl <> v_hssl) THEN
          pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_sl - v_oldsl);
        END IF;
        */
        --更新合同进货量
        IF(v_djxz = 1 AND :old.wjid IS NOT NULL AND (v_oldsl <> v_sl OR v_oldhssl <> v_hssl)) THEN
          v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
          pck_store.updateBuyInStoreNum(:old.wjid, :old.cpid, v_sl-v_oldsl, v_hssl-v_oldhssl, v_ishssl);
        END IF;
      ELSIF(v_oldsl <> v_sl OR v_oldhssl <> v_hssl) THEN
        --更新计划可供量 2004.6.22 废弃计划可供量表
        --pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_sl - v_oldsl);
        --更新合同进货量
        IF(v_djxz = 1 AND :old.wjid IS NOT NULL) THEN
          v_ishssl := pck_base.systemparam('BUY_PRICLE_METHOD', v_fgsid) = '1';
          pck_store.updateBuyInStoreNum(:old.wjid, :old.cpid, v_sl-v_oldsl, v_hssl-v_oldhssl, v_ishssl);
        END IF;
      END IF;
    END IF;
  --2=销售出库单, 4=生产领料单,6=外加工发料单
  ELSIF(v_djxz = 2 OR v_djxz = 4 OR v_djxz = 6) THEN --出库减锁定
    IF(inserting)THEN
      v_sl := nvl(:new.sl,0);
      v_hssl := nvl(:new.hssl,0);
      --更新实提数量
      IF(v_djxz = 2 AND :new.wjid IS NOT NULL) THEN
        pck_store.updateSaleOutStoreNum(:new.wjid, :new.cpid, v_sl, v_hssl, v_fgsid, v_sfrq);
      END IF;
    ELSIF(deleting) THEN
      v_oldsl := nvl(:old.sl,0);
      v_oldhssl := nvl(:old.hssl,0);
      --更新实提数量
      IF(v_djxz = 2 AND :old.wjid IS NOT NULL) THEN
        pck_store.updateSaleOutStoreNum(:old.wjid, :old.cpid, -1*v_oldsl, -1*v_oldhssl, v_fgsid, NULL);
      END IF;
    ELSIF(updating) THEN
      v_oldsl := nvl(:old.sl,0);
      v_sl := nvl(:new.sl,0);
      v_oldhssl := nvl(:old.hssl,0);
      v_hssl := nvl(:new.hssl,0);
      IF(nvl(:old.cpid,-100)<>nvl(:new.cpid,-100) OR nvl(:old.kwid,-100)<>nvl(:new.kwid,-100) OR
         nvl(:old.dmsxid,-100)<>nvl(:new.dmsxid,-100) OR nvl(:old.ph,'@#$%^')<>nvl(:new.ph,'@#$%^')
        )THEN
        --更新实提数量
        IF(:new.wjid IS NOT NULL AND v_djxz = 2 AND (v_oldsl <> v_sl OR v_oldhssl <> v_hssl)) THEN
          pck_store.updateSaleOutStoreNum(:old.wjid, :old.cpid, v_sl - v_oldsl, v_hssl - v_oldhssl, v_fgsid, v_sfrq);
        END IF;
      ELSIF(v_oldsl <> v_sl OR v_oldhssl <> v_hssl) THEN
        --更新实提数量
        IF(v_djxz = 2 AND :old.wjid IS NOT NULL) THEN
          pck_store.updateSaleOutStoreNum(:old.wjid, :old.cpid, v_sl - v_oldsl, v_hssl - v_oldhssl, v_fgsid, v_sfrq);
        END IF;
      END IF;
    END IF;
  --移库单
  ELSIF(v_djxz = 8) THEN
    NULL;
  END IF;
END tg_kc_sfdjmx;
/

prompt
prompt Creating trigger TG_RL_ZGXXBD
prompt =============================
prompt
CREATE OR REPLACE TRIGGER TG_RL_ZGXXBD
  BEFORE INSERT OR UPDATE ON RL_ZGXXBD
  FOR EACH ROW
DECLARE
  -- local variables here
  --员工变动信息触发器
  --1=职工离职,2=部门调动,3=类别变动,4=职务变迁, 5=职工复职
  v_approve  BOOLEAN; --true:通过审批, false:取消审批
  v_bdlx     rl_zgxxbd.bdlx%TYPE;
  v_off      emp.isdelete%TYPE;   --员工离职
  v_on       emp.isdelete%TYPE;   --员工复职
  v_approvecode VARCHAR2(32) := 'employee_change_detail';
BEGIN
  IF(pck_approve.isafterapprove(v_approvecode))THEN
    raise_application_error(-20000, '请将审批流程设置为事前审批！');
  END IF;
  --
  IF(updating AND (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    v_approve := TRUE;
    v_off := 2;
    v_on  := 0;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    v_approve := FALSE;
    v_off := 0;
    v_on  := 2;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  v_bdlx := :old.bdlx;
  --
  FOR c_mx IN( SELECT d.personid, d.bdqid, d.bdhid FROM rl_zgxxbdmx d WHERE d.zgxxid = :new.zgxxid)
  LOOP
    --员工离职
    IF (v_bdlx = 1) THEN
      UPDATE emp e SET e.isdelete=v_off WHERE e.personid = c_mx.personid;
    --职工复职
    ELSIF(v_bdlx = 5) THEN
      UPDATE emp e SET e.isdelete=v_on WHERE e.personid = c_mx.personid;
    --部门调动
    --bdqid和bdhid保存的是部门id
    ELSIF(v_bdlx = 2) THEN
      IF(v_approve) THEN
        UPDATE emp e SET e.deptid = c_mx.bdhid WHERE e.personid = c_mx.personid;
      ELSE
        UPDATE emp e SET e.deptid = c_mx.bdqid WHERE e.personid = c_mx.personid;
      END IF;
    --类别变动,职务变迁
    --bdqid和bdhid保存的是类别变动和职务变迁名称
    ELSIF(v_bdlx = 3 OR v_bdlx = 4) THEN
      IF(v_approve)THEN--员工辅助信息
        UPDATE emp e SET e.lb = c_mx.bdhid WHERE e.personid = c_mx.personid;
      ELSE
        UPDATE emp e SET e.lb = c_mx.bdqid WHERE e.personid = c_mx.personid;
      END IF;
    END IF;
  END LOOP;
END TG_RL_ZGXXBD;
/

prompt
prompt Creating trigger TG_SC_BMGZLMX
prompt ==============================
prompt
CREATE OR REPLACE TRIGGER TG_SC_BMGZLMX
  BEFORE UPDATE OR INSERT OR DELETE ON sc_bmgzlmx
  FOR EACH ROW
DECLARE
  -- local variables here
  --按部门输入工作量触发器，更新生产加工单已排任务量
  --插入数据到工人工作量
  /*v_gzlid   sc_grgzlmx.gzlid%TYPE;
  v_gzlmxid sc_grgzlmx.gzlmxid%TYPE;
  v_deptid  sc_bmgzl.deptid%TYPE;
  v_rq      sc_bmgzl.rq%TYPE;
  --v_zdrq    sc_bmgzl.zdrq%TYPE;
  --v_zdrid   sc_bmgzl.zdrid%TYPE;
  --v_zdr     sc_bmgzl.zdr%TYPE;
  v_fgsid   sc_bmgzl.fgsid%TYPE;
  v_sl      sc_bmgzlmx.sl%TYPE;
  v_jjgz    sc_bmgzlmx.jjgz%TYPE;
  v_isnew   BOOLEAN:=FALSE;--工人工作量主表是否是新添的
  v_count   INT;*/
BEGIN
  IF(inserting AND :new.jgdmxid IS NOT NULL AND :new.gx IS NOT NULL) THEN
    pck_produce.updateProduceProcessNum(:new.jgdmxid, :new.gx, nvl(:new.sl,0));
  ELSIF(deleting AND :old.jgdmxid IS NOT NULL AND :old.gx IS NOT NULL)THEN
    pck_produce.updateProduceProcessNum(:old.jgdmxid, :old.gx, -1*nvl(:old.sl,0));
  ELSIF(updating)THEN
    IF(:old.jgdmxid IS NOT NULL AND :old.gx IS NOT NULL) THEN
      pck_produce.updateProduceProcessNum(:old.jgdmxid, :old.gx, -1*nvl(:old.sl,0));
    END IF;
    --
    IF(:new.jgdmxid IS NOT NULL AND :new.gx IS NOT NULL)THEN
      pck_produce.updateProduceProcessNum(:new.jgdmxid, :new.gx, nvl(:new.sl,0));
    END IF;
  END IF;
  /*
  IF(inserting OR (updating AND :old.gzlmxid IS NOT NULL)) THEN
    v_sl := nvl(:new.sl, 0);
    v_jjgz := nvl(:new.jjgz, 0);
    SELECT m.deptid, m.rq, m.fgsid  INTO v_deptid, v_rq, v_fgsid
    FROM   sc_bmgzl m WHERE m.bmgzlid = :new.bmgzlid;
    --得到工人工作量主表的主键
    BEGIN
      SELECT a.gzlid  INTO v_gzlid FROM sc_grgzl a
      WHERE a.rq=v_rq AND a.lx=2 AND a.fgsid=v_fgsid
      AND a.deptid=v_deptid AND a.personid=:new.personid FOR UPDATE;
    EXCEPTION
      WHEN OTHERS THEN
        v_isnew := TRUE;
        SELECT s_sc_grgzl.NEXTVAL INTO v_gzlid FROM dual;
        --插入工人工作量主表
        INSERT INTO sc_grgzl(gzlid, deptid, personid, rq, je, zjjgz, fgsid, lx)
        VALUES(v_gzlid, v_deptid, :new.personid, v_rq, v_jjgz, v_jjgz, v_fgsid, 2);
    END;
    --
    SELECT s_sc_grgzlmx.NEXTVAL INTO v_gzlmxid FROM dual;
    --插入工人工作量从表
    INSERT INTO sc_grgzlmx(gzlmxid, gzlid, jgdmxid, gylxid,
      cpid, gx, sl, de, jjgs, jjgz, desl)
    VALUES(v_gzlmxid, v_gzlid, :new.jgdmxid, :new.gylxid,
      :new.cpid, :new.gx, v_sl, :new.jjdj, :new.jjgs, :new.jjgz, :new.desl);
    --
    :new.gzlmxid := v_gzlmxid;
    --如果主表不是添加的
    IF(v_isnew = FALSE) THEN
      SELECT nvl(SUM(nvl(b.jjgz,0)),0) INTO v_jjgz
      FROM   sc_grgzlmx b WHERE b.gzlid = v_gzlid;
      --
      UPDATE sc_grgzl a SET a.je = v_jjgz, a.zjjgz = v_jjgz
      WHERE a.gzlid = v_gzlid;
    END IF;
  ELSIF(deleting AND :old.gzlmxid IS NOT NULL)THEN
    SELECT b.gzlid INTO v_gzlid FROM sc_grgzlmx b WHERE b.gzlmxid = :old.gzlmxid;
    --删除工人工作量从表
    DELETE FROM sc_grgzlmx b WHERE b.gzlmxid = :old.gzlmxid;
    SELECT COUNT(*) INTO v_count FROM sc_grgzlmx b WHERE b.gzlid=v_gzlid;
    --从表是否没有记录
    IF(v_count > 0) THEN
      SELECT nvl(SUM(nvl(b.jjgz,0)),0) INTO v_jjgz
      FROM   sc_grgzlmx b WHERE b.gzlid = v_gzlid;
      --
      UPDATE sc_grgzl a SET a.je = v_jjgz, a.zjjgz = v_jjgz
      WHERE a.gzlid = v_gzlid;
    ELSE
      DELETE FROM sc_grgzl a
      WHERE (SELECT COUNT(*) FROM sc_grgzlmx b WHERE b.gzlid=v_gzlid) > 0 AND a.gzlid = v_gzlid;
    END IF;
  ELSIF(updating AND :old.gzlmxid IS NOT NULL)THEN
    SELECT m.deptid, m.rq INTO v_deptid, v_rq
    FROM   sc_bmgzl m WHERE m.bmgzlid = :new.bmgzlid;
    SELECT b.gzlid INTO v_gzlid FROM sc_grgzlmx b WHERE b.gzlmxid = :old.gzlmxid;
    --更新工人工作量主表
    UPDATE sc_grgzl a
    SET a.deptid = v_deptid, a.personid = :new.personid,
        a.rq = v_rq,  a.zjjgz = :new.jjgz, a.je = :new.jjgz
    WHERE a.gzlid = v_gzlid;
    --更新工人工作量从表
    UPDATE sc_grgzlmx b
    SET b.jgdmxid = :new.jgdmxid, b.gylxid = :new.gylxid,
        b.cpid = :new.cpid,       b.gx = :new.gx,
        b.sl = :new.sl,           b.de = :new.jjdj,
        b.jjgs = :new.jjgs,       b.jjgz = :new.jjgz,
        b.desl = :new.desl
    WHERE b.gzlmxid = :old.gzlmxid;
  END IF;
  */
END TG_SC_BMGZLMX;
/

prompt
prompt Creating trigger TG_SC_DRAWMATERIAL
prompt ===================================
prompt
CREATE OR REPLACE TRIGGER TG_SC_DRAWMATERIAL
  BEFORE INSERT OR UPDATE ON sc_drawmaterial
  FOR EACH ROW
DECLARE
  -- local variables here
  --库存收发单据触发器，用于减少库存数量
  --v_wzmxid  kc_wzmx.wzmxid%TYPE;
  v_approvecode VARCHAR2(32);-- := 'receive_material_list';
  v_isafter BOOLEAN;
  v_flag    INT;
BEGIN
  IF(nvl(:new.isout,0) = 1)THEN --外加工发料
    v_approvecode := 'process_issue_list';
  ELSE
    v_approvecode := 'receive_material_list'; --生产领料单
  END IF;
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSE
    v_isafter := pck_approve.isafterapprove(v_approvecode);
  END IF;
  --没有审批流程       --4=生产领料单
  IF((v_isafter OR (:old.state=1 AND :new.state=1)) AND :old.storeid<>:new.storeid) THEN
    FOR c_mx IN(
      SELECT d.drawdetailid, d.cpid, d.dmsxid, d.kwid, d.jgdmxid, nvl(d.drawnum,0) drawnum,
             d.batchno, d.memo, nvl(d.drawbignum,0) drawbignum, d.wzmxid, d.jgdwlid
      FROM sc_drawmaterialdetail d WHERE d.drawid = :old.drawid)
    LOOP
      --2004.6.12 用视图代替表
      --更新已经领料量
      IF(c_mx.jgdwlid IS NOT NULL) THEN
        UPDATE sc_jgdwl w
        SET w.ylsl=nvl(w.ylsl,0) + c_mx.drawnum, w.ylscsl=nvl(w.ylscsl,0) + c_mx.drawbignum
        WHERE  w.jgdwlid = c_mx.jgdwlid;
      END IF;
    END LOOP;
    RETURN;
  ELSIF(v_isafter)THEN
    RETURN;
  --有审批流程
  ELSIF((:old.state = 0 OR :old.state = 9) AND :new.state = 1) THEN--审批通过
    v_flag := 1;
    :new.isrefer := 1;
  ELSIF( :old.state = 1 AND :new.state = 0) THEN
    v_flag := -1;
    :new.isrefer := 0;
  --非法状态的变更
  ELSIF( :old.state = 1 AND :new.state = 9) THEN
    :new.state := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  FOR c_mx IN(
    SELECT d.drawdetailid, d.cpid, d.dmsxid, d.kwid, d.jgdmxid, nvl(d.drawnum,0) drawnum,
           d.batchno, d.memo, nvl(d.drawbignum,0) drawbignum, d.wzmxid, d.jgdwlid
    FROM sc_drawmaterialdetail d WHERE d.drawid = :old.drawid)
  LOOP
    --更新已经领料量
    IF(c_mx.jgdwlid IS NOT NULL) THEN
      UPDATE sc_jgdwl w
      SET w.ylsl=nvl(w.ylsl,0) + c_mx.drawnum, w.ylscsl=nvl(w.ylscsl,0) + c_mx.drawbignum
      WHERE  w.jgdwlid = c_mx.jgdwlid;
    END IF;
  END LOOP;
END TG_SC_DRAWMATERIAL;
/

prompt
prompt Creating trigger TG_SC_DRAWMATERIALDETAIL
prompt =========================================
prompt
CREATE OR REPLACE TRIGGER tg_sc_drawmaterialdetail
  BEFORE INSERT OR UPDATE OR DELETE ON sc_drawmaterialdetail
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步库存数量
  -- local variables here
  --v_state      sc_drawmaterial.state%TYPE;
  v_filialeid     sc_drawmaterial.filialeid%TYPE;
  v_storeid       sc_drawmaterial.storeid%TYPE;
  v_isrefer       sc_drawmaterial.isrefer%TYPE;
  v_drawid        sc_drawmaterialdetail.drawid%TYPE;
  v_wzmxid        sc_drawmaterialdetail.wzmxid%TYPE;
  v_olddrawnum    sc_drawmaterialdetail.drawnum%TYPE;
  v_drawnum       sc_drawmaterialdetail.drawnum%TYPE;
  v_olddrawbignum sc_drawmaterialdetail.drawbignum%TYPE;
  v_drawbignum    sc_drawmaterialdetail.drawbignum%TYPE;
BEGIN
  --表示主表触发器更新从表的wzmxid，不处理，以免报错
  IF(updating AND nvl(:old.wzmxid,0) <> nvl(:new.wzmxid,0)) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_drawid := :new.drawid;
  ELSE
    v_drawid := :old.drawid;
  END IF;
  --
  SELECT m.filialeid, m.storeid, m.isrefer
  INTO   v_filialeid, v_storeid, v_isrefer
  FROM   sc_drawmaterial m WHERE m.drawid = v_drawid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --4=生产领料单
  IF(inserting)THEN
    v_drawnum := nvl(:new.drawnum,0);
    v_drawbignum := nvl(:new.drawbignum,0);
    --2004.6.12 用视图代替表
    --更新已经领料量
    IF(:new.jgdwlid IS NOT NULL) THEN
      UPDATE sc_jgdwl w SET w.ylsl=nvl(w.ylsl,0)+v_drawnum, w.ylscsl=nvl(w.ylscsl,0)+v_drawbignum
      WHERE  w.jgdwlid = :new.jgdwlid;
    END IF;
  ELSIF(deleting) THEN
    v_drawnum := nvl(:old.drawnum,0);
    v_drawbignum := nvl(:old.drawbignum,0);
    --更新已经领料量
    IF(:old.jgdwlid IS NOT NULL) THEN
      UPDATE sc_jgdwl w SET w.ylsl=nvl(w.ylsl,0)-v_drawnum, w.ylscsl=nvl(w.ylscsl,0)-v_drawbignum
      WHERE  w.jgdwlid = :old.jgdwlid;
    END IF;
  ELSIF(updating) THEN
    v_olddrawnum := nvl(:old.drawnum,0);
    v_drawnum := nvl(:new.drawnum,0);
    v_olddrawbignum := nvl(:old.drawbignum,0);
    v_drawbignum := nvl(:new.drawbignum,0);
    --更新已经领料量
    IF(:old.jgdwlid IS NOT NULL) THEN
      IF(v_olddrawnum <> v_drawnum OR v_olddrawbignum <> v_drawbignum) THEN
        UPDATE sc_jgdwl w
        SET    w.ylsl=nvl(w.ylsl,0)+ v_drawnum - v_olddrawnum,
               w.ylscsl=nvl(w.ylscsl,0) + v_drawbignum - v_olddrawbignum
        WHERE  w.jgdwlid = :old.jgdwlid;
      END IF;
    END IF;
  END IF;
END tg_sc_drawmaterialdetail;
/

prompt
prompt Creating trigger TG_SC_GRGZLMX
prompt ==============================
prompt
CREATE OR REPLACE TRIGGER TG_SC_GRGZLMX
  AFTER UPDATE OR INSERT OR DELETE ON sc_grgzlmx
  FOR EACH ROW
DECLARE
  -- local variables here
  --工人工作量触发器，更新生产加工单已排任务量
BEGIN
  IF(inserting AND :new.jgdmxid IS NOT NULL AND :new.gx IS NOT NULL) THEN
    pck_produce.updateProduceProcessNum(:new.jgdmxid, :new.gx, nvl(:new.sl,0));
  ELSIF(deleting AND :old.jgdmxid IS NOT NULL AND :old.gx IS NOT NULL)THEN
    pck_produce.updateProduceProcessNum(:old.jgdmxid, :old.gx, -1*nvl(:old.sl,0));
  ELSIF(updating)THEN
    IF(:old.jgdmxid IS NOT NULL AND :old.gx IS NOT NULL) THEN
      pck_produce.updateProduceProcessNum(:old.jgdmxid, :old.gx, -1*nvl(:old.sl,0));
    END IF;
    --
    IF(:new.jgdmxid IS NOT NULL AND :new.gx IS NOT NULL)THEN
      pck_produce.updateProduceProcessNum(:new.jgdmxid, :new.gx, nvl(:new.sl,0));
    END IF;
  END IF;
END TG_SC_GRGZLMX;
/

prompt
prompt Creating trigger TG_SC_JGDMX
prompt ============================
prompt
CREATE OR REPLACE TRIGGER TG_SC_JGDMX
  BEFORE UPDATE OR INSERT OR DELETE ON sc_jgdmx
  FOR EACH ROW
DECLARE
  -- local variables here
  --生产加工单明细触发器，更新生产任务单已排加工量
BEGIN
  IF(inserting AND :new.rwdmxid IS NOT NULL) THEN
    pck_produce.updateProduceTaskNum(:new.rwdmxid, nvl(:new.sl,0), nvl(:new.scsl,0));
  ELSIF(deleting AND :old.rwdmxid IS NOT NULL) THEN
    pck_produce.updateProduceTaskNum(:old.rwdmxid, -1*nvl(:old.sl,0), -1*nvl(:old.scsl,0));
  ELSIF(updating) THEN
    IF(:old.rwdmxid IS NOT NULL) THEN
      pck_produce.updateProduceTaskNum(:old.rwdmxid, -1*nvl(:old.sl,0), -1*nvl(:old.scsl,0));
    END IF;
    --
    IF(:new.rwdmxid IS NOT NULL)THEN
      pck_produce.updateProduceTaskNum(:new.rwdmxid, nvl(:new.sl,0), nvl(:new.scsl,0));
    END IF;
  END IF;
END TG_SC_JGDMX;
/

prompt
prompt Creating trigger TG_SC_JH
prompt =========================
prompt
CREATE OR REPLACE TRIGGER tg_sc_jh
  BEFORE INSERT OR UPDATE ON sc_jh
  FOR EACH ROW
DECLARE
  -- local variables here
  --生产计划触发器，更新销售合同的已计划量和计划可供量
  --2004.2.28 增加更新计划可供量与规格属性id有关
  v_sl sc_jhmx.sl%TYPE;
  v_approvecode VARCHAR2(32);
BEGIN
  IF(nvl(:new.jhlx,0) = 1) THEN --分切计划
    v_approvecode := 'produce_subplan';
  ELSE
    v_approvecode := 'produce_plan';
  END IF;
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  IF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    FOR c_mx IN( SELECT d.scjhmxid, d.hthwid, d.cpid, d.dmsxid, d.sl
                 FROM sc_jhmx d WHERE d.scjhid= :new.scjhid)
    LOOP
      v_sl := nvl(c_mx.sl,0);
      --回填销售合同货物的计划量
      IF(c_mx.hthwid IS NOT NULL) THEN
        pck_produce.updateSaleOrderPlanNum(c_mx.scjhmxid, c_mx.hthwid, v_sl);
      END IF;
      --更新计划可供量 2004.6.22 废弃计划可供量表
      --pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, -1*v_sl);
    END LOOP;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    FOR c_mx IN( SELECT d.scjhmxid, d.hthwid, d.cpid, d.dmsxid, d.sl
                 FROM sc_jhmx d WHERE d.scjhid= :new.scjhid)
    LOOP
      v_sl := nvl(c_mx.sl,0);
      --回填销售合同货物的计划量
      IF(c_mx.hthwid IS NOT NULL) THEN
        pck_produce.updateSaleOrderPlanNum(c_mx.scjhmxid, c_mx.hthwid, -1*v_sl);
      END IF;
      --更新计划可供量 2004.6.22 废弃计划可供量表
      --pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, v_sl);
    END LOOP;
  --非法状态更新
  ELSIF(:old.zt = 1 AND :new.zt = 9)THEN
    :new.zt := 1;
  --更新完成状态
  /*ELSIF(:old.zt = :new.zt AND :old.zt <> 0 AND :old.zt <> 9) THEN
    IF () THEN
    END IF;*/
  END IF;
END tg_sc_jh;
/

prompt
prompt Creating trigger TG_SC_JHMX
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER tg_sc_jhmx
  AFTER INSERT OR UPDATE OR DELETE ON sc_jhmx
  FOR EACH ROW
DECLARE
  --生产计划明细触发器，用于同步库存数量
  --2004.2.28 增加更新计划可供量与规格属性id有关
  -- local variables here
  v_zt     sc_jh.zt%TYPE;
  v_isrefer sc_jh.isrefer%TYPE;
  v_scjhid sc_jhmx.scjhid%TYPE;
  v_oldsl  sc_jhmx.sl%TYPE;
  v_sl     sc_jhmx.sl%TYPE;
BEGIN
  IF(inserting) THEN
    v_scjhid := :new.scjhid;
  ELSE
    v_scjhid := :old.scjhid;
  END IF;
  --
  SELECT m.zt, m.isrefer INTO v_zt, v_isrefer
  FROM sc_jh m WHERE m.scjhid = v_scjhid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_sl := nvl(:new.sl,0);
    --回填销售合同货物的计划量
    IF(:new.hthwid IS NOT NULL) THEN
      pck_produce.updateSaleOrderPlanNum(:new.scjhmxid, :new.hthwid, v_sl);
    END IF;
    --更新计划可供量 2004.6.22 废弃计划可供量表
    --pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, -1*v_sl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.sl,0);
    --回填销售合同货物的计划量
    IF(:old.hthwid IS NOT NULL) THEN
      pck_produce.updateSaleOrderPlanNum(:old.scjhmxid, :old.hthwid, -1*v_oldsl);
    END IF;
    --更新计划可供量 2004.6.22 废弃计划可供量表
    --pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_oldsl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_sl := nvl(:new.sl,0);
    --回填销售合同货物的计划量
    IF(:old.hthwid IS NOT NULL AND v_oldsl <> v_sl) THEN
      pck_produce.updateSaleOrderPlanNum(:old.scjhmxid, :old.hthwid, v_sl - v_oldsl);--加增量
    END IF;
    IF(:new.cpid = :old.cpid AND nvl(:new.dmsxid,-100) = nvl(:old.dmsxid,-100) AND v_oldsl = v_sl) THEN
      RETURN;
    END IF;
    --更新计划可供量 2004.6.22 废弃计划可供量表
    /*IF(v_oldsl = v_sl)THEN
      pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, -1*v_sl);
      pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_oldsl);
    ELSE
      pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, -1*v_sl + v_oldsl);
    END IF;
    */
  END IF;
END tg_sc_jhmx;
/

prompt
prompt Creating trigger TG_SC_RECEIVEPROD
prompt ==================================
prompt
CREATE OR REPLACE TRIGGER tg_sc_receiveProd
  BEFORE INSERT OR UPDATE ON sc_receiveProd
  FOR EACH ROW
DECLARE
  -- local variables here
  --库存收发单据触发器，用于减少库存数量
  --v_wzmxid  kc_wzmx.wzmxid%TYPE;
  v_approvecode VARCHAR2(32);-- :='self_gain_list';
  v_isafter     BOOLEAN;
  v_dwtxid  sc_drawmaterial.dwtxid%TYPE;
  --v_iswzmxadd BOOLEAN; --是否添加了物资明细id
  --v_ishssl  BOOLEAN;
  v_flag    INT;
BEGIN
  IF(nvl(:new.isout,0) = 1)THEN--外加工入库单
    v_approvecode := 'process_instore_list';
    v_dwtxid := :new.dwtxid;
  ELSE
    v_approvecode := 'self_gain_list';
  END IF;
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSE
    v_isafter := pck_approve.isafterapprove(v_approvecode);
  END IF;
  --3=自制入库单
  --2004.6.12 用视图代替表
  IF(v_isafter) THEN
    RETURN;
  --有审批流程
  ELSIF((:old.state = 0 OR :old.state = 9) AND :new.state = 1) THEN--审批通过
    v_flag := 1;
    :new.isrefer := 1;
  ELSIF(:old.state = 1 AND :new.state = 0) THEN
    v_flag := -1;
    :new.isrefer := 0;
  --非法状态的变更
  ELSIF(:old.state = 1 AND :new.state = 9) THEN
    :new.state := 1;
    RETURN;
  ELSE
    RETURN;
  END IF;
  --
  FOR c_mx IN(
    SELECT d.receivedetailid, d.cpid, d.dmsxid, d.kwid, d.jgdmxid, nvl(d.drawnum,0) drawnum,
           d.batchno, d.memo, nvl(d.drawbignum,0) drawbignum, d.wzmxid
    FROM sc_receiveProdDetail d WHERE d.receiveid= :old.receiveid AND d.jgdmxid IS NOT NULL)
  LOOP
    --更新计划可供量 2004.2.28 增加规格属性ID有关 2004.6.22 废弃计划可供量表
    --pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, v_flag*c_mx.drawnum);
    --回填2004.4.29 加工单入库量
    --IF(c_mx.jgdmxid IS NOT NULL) THEN
    UPDATE sc_jgdmx m
    SET m.yrksl=nvl(m.yrksl,0) + c_mx.drawnum, m.yrkscsl=nvl(m.yrkscsl,0) + c_mx.drawbignum
    WHERE  m.jgdmxid = c_mx.jgdmxid;
  END LOOP;
END tg_sc_receiveProd;
/

prompt
prompt Creating trigger TG_SC_RECEIVEPRODDETAIL
prompt ========================================
prompt
CREATE OR REPLACE TRIGGER tg_sc_receiveProdDetail
  BEFORE INSERT OR UPDATE OR DELETE ON sc_receiveProdDetail
  FOR EACH ROW
DECLARE
  --自制入库单明细触发器，用于同步库存数量
  -- local variables here
  v_state      sc_receiveProd.state%TYPE;
  v_filialeid  sc_receiveProd.filialeid%TYPE;
  v_storeid    sc_receiveProd.storeid%TYPE;
  v_isrefer    sc_receiveProd.storeid%TYPE;
  v_receiveid  sc_receiveProdDetail.receiveid%TYPE;
  v_wzmxid     sc_receiveProdDetail.wzmxid%TYPE;
  v_olddrawnum sc_receiveProdDetail.drawnum%TYPE;
  v_drawnum    sc_receiveProdDetail.drawnum%TYPE;
  v_olddrawbignum sc_receiveProdDetail.drawbignum%TYPE;
  v_drawbignum sc_receiveProdDetail.drawbignum%TYPE;
  --v_oldhssl sc_receiveProdDetail.hssl%TYPE;
  --v_hssl    sc_receiveProdDetail.hssl%TYPE;
  --v_ishssl  BOOLEAN;
BEGIN
  --表示主表触发器更新从表的wzmxid，不处理，以免报错
  IF(updating AND nvl(:old.wzmxid,0) <> nvl(:new.wzmxid,0)) THEN
    RETURN;
  END IF;
  --
  IF(inserting) THEN
    v_receiveid := :new.receiveid;
  ELSE
    v_receiveid := :old.receiveid;
  END IF;
  --
  SELECT m.state, m.filialeid, m.storeid, m.isrefer
  INTO   v_state, v_filialeid, v_storeid, v_isrefer
  FROM   sc_receiveProd m WHERE m.receiveid = v_receiveid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --3=自制入库单
  IF(inserting) THEN
    v_drawnum := nvl(:new.drawnum,0);
    v_drawbignum := nvl(:new.drawbignum,0);
    --更新计划可供量 2004.6.22 废弃计划可供量表
    --pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, v_drawnum);
    --回填2004.4.29 加工单入库量
    IF(:new.jgdmxid IS NOT NULL) THEN
      UPDATE sc_jgdmx m
      SET m.yrksl=nvl(m.yrksl,0) + v_drawnum, m.yrkscsl=nvl(m.yrkscsl,0) + v_drawbignum
      WHERE  m.jgdmxid = :new.jgdmxid;
    END IF;
  ELSIF(deleting) THEN
    v_olddrawnum := nvl(:old.drawnum,0);
    v_olddrawbignum := nvl(:old.drawbignum,0);
    --更新计划可供量 2004.6.22 废弃计划可供量表
    --pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, -1*v_olddrawnum);
    --回填2004.4.29 加工单入库量
    IF(:old.jgdmxid IS NOT NULL) THEN
      UPDATE sc_jgdmx m
      SET m.yrksl=nvl(m.yrksl,0) - v_olddrawnum, m.yrkscsl=nvl(m.yrkscsl,0) - v_olddrawbignum
      WHERE  m.jgdmxid = :old.jgdmxid;
    END IF;
  ELSIF(updating) THEN
    v_olddrawnum := nvl(:old.drawnum,0);
    v_olddrawbignum := nvl(:old.drawbignum,0);
    v_drawnum := nvl(:new.drawnum,0);
    v_drawbignum := nvl(:new.drawbignum,0);
    /*2004.6.22 废弃计划可供量表
    IF(nvl(:old.cpid,-100)<>nvl(:new.cpid,-100) OR nvl(:old.kwid,-100)<>nvl(:new.kwid,-100) OR
       nvl(:old.dmsxid,-100)<>nvl(:new.dmsxid,-100) OR nvl(:old.batchno,'@#$%^')<>nvl(:new.batchno,'@#$%^')
      )THEN
      --更新计划可供量 2004.2.28 增加规格属性id有关的计划可供量
      IF(nvl(:old.cpid,-100)<>nvl(:new.cpid,-100) OR nvl(:old.dmsxid,-100)<>nvl(:new.dmsxid,-100))THEN
        pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, -1*v_olddrawnum);
        pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, v_drawnum);
      ELSIF(v_olddrawnum <> v_drawnum) THEN
        pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_drawnum - v_olddrawnum);
      END IF;
    ELSIF(v_olddrawnum <> v_drawnum) THEN
      --更新计划可供量
      pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_drawnum - v_olddrawnum);
    END IF;
    */
    --回填2004.4.29 加工单入库量
    IF(:old.jgdmxid IS NOT NULL AND (v_olddrawnum <> v_drawnum OR v_olddrawbignum<>v_drawbignum)) THEN
      UPDATE sc_jgdmx m
      SET m.yrksl=nvl(m.yrksl,0)+v_drawnum -v_olddrawnum, m.yrkscsl=nvl(m.yrkscsl,0)+v_drawbignum-v_olddrawbignum
      WHERE  m.jgdmxid = :old.jgdmxid;
    END IF;
  END IF;
END tg_sc_receiveProdDetail;
/

prompt
prompt Creating trigger TG_SC_RWD
prompt ==========================
prompt
CREATE OR REPLACE TRIGGER TG_SC_RWD
  BEFORE UPDATE OR INSERT ON sc_rwd
  FOR EACH ROW
DECLARE
  -- local variables here
  --生产任务单
  v_approvecode VARCHAR2(32) := 'produce_task';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  ELSIF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    --
    FOR c_mx IN( SELECT d.wlxqjhmxid, nvl(d.sl,0) sl, nvl(d.scsl,0) scsl
                 FROM sc_rwdmx d WHERE d.rwdid= :new.rwdid AND d.wlxqjhmxid IS NOT NULL)
    LOOP
      --更新物料需求(计划)已开任务量
      pck_produce.updatePlanOverNum(c_mx.wlxqjhmxid, c_mx.sl, c_mx.scsl);
    END LOOP;
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    --
    FOR c_mx IN( SELECT d.wlxqjhmxid, nvl(d.sl,0) sl, nvl(d.scsl,0) scsl
                 FROM sc_rwdmx d WHERE d.rwdid= :new.rwdid AND d.wlxqjhmxid IS NOT NULL)
    LOOP
      --更新物料需求(计划)已开任务量
      pck_produce.updatePlanOverNum(c_mx.wlxqjhmxid, -1*c_mx.sl, -1*c_mx.scsl);
    END LOOP;
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  END IF;
END TG_SC_RWD;
/

prompt
prompt Creating trigger TG_SC_RWDMX
prompt ============================
prompt
CREATE OR REPLACE TRIGGER TG_SC_RWDMX
  BEFORE UPDATE OR INSERT OR DELETE ON sc_rwdmx
  FOR EACH ROW
DECLARE
  -- local variables here
  --生产任务单明细触发器，更新生产计划已完成加工量,物料需求计划的已排任务量
  v_isrefer sc_rwd.isrefer%TYPE;
  v_rwdid   sc_rwd.rwdid%TYPE;
BEGIN
  IF(inserting) THEN
    v_rwdid := :new.rwdid;
  ELSE
    v_rwdid := :old.rwdid;
  END IF;
  SELECT m.isrefer INTO v_isrefer
  FROM   sc_rwd m WHERE m.rwdid = v_rwdid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  IF(inserting AND :new.wlxqjhmxid IS NOT NULL) THEN
    pck_produce.updatePlanOverNum(:new.wlxqjhmxid, nvl(:new.sl,0), nvl(:new.scsl,0));
  ELSIF(deleting AND :old.wlxqjhmxid IS NOT NULL) THEN
    pck_produce.updatePlanOverNum(:old.wlxqjhmxid, -1*nvl(:old.sl,0), -1*nvl(:old.scsl,0));
  ELSIF(updating) THEN
    IF(:old.wlxqjhmxid IS NOT NULL) THEN
      pck_produce.updatePlanOverNum(:old.wlxqjhmxid, -1*nvl(:old.sl,0), -1*nvl(:old.scsl,0));
    END IF;
    --
    IF(:new.wlxqjhmxid IS NOT NULL)THEN
      pck_produce.updatePlanOverNum(:new.wlxqjhmxid, nvl(:new.sl,0), nvl(:new.scsl,0));
    END IF;
  END IF;
END TG_SC_RWDMX;
/

prompt
prompt Creating trigger TG_SC_WLXQJH
prompt =============================
prompt
CREATE OR REPLACE TRIGGER tg_sc_wlxqjh
  BEFORE INSERT OR UPDATE ON sc_wlxqjh
  FOR EACH ROW
DECLARE
  -- local variables here
  --物料需求计划触发器，更新计划可供量
  --2004.2.28 增加更新计划可供量与规格属性id有关
  v_sl sc_wlxqjhmx.xql%TYPE;
  v_approvecode VARCHAR2(32) := 'mrp';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  ELSIF(pck_approve.isafterapprove(v_approvecode)) THEN
    RETURN;
  END IF;
  IF((:old.zt =0 OR :old.zt=9) AND :new.zt = 1) THEN--审批通过
    :new.isrefer := 1;
    /*2004.6.22 废弃计划可供量表
    FOR c_mx IN( SELECT d.cpid, d.dmsxid, d.xql FROM sc_wlxqjhmx d WHERE d.cc > 0 AND d.wlxqjhid= :new.wlxqjhid)--cc＝0 表示成品
    LOOP
      v_sl := nvl(c_mx.xql,0);
      --更新计划可供量
     pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, -1*v_sl);
    END LOOP;*/
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    /*2004.6.22 废弃计划可供量表
    FOR c_mx IN( SELECT d.cpid, d.dmsxid, d.xql FROM sc_wlxqjhmx d WHERE d.cc > 0 AND d.wlxqjhid= :new.wlxqjhid)
    LOOP
      v_sl := nvl(c_mx.xql,0);
      --更新计划可供量
      pck_store.updatePlanUsableGoods(c_mx.cpid, c_mx.dmsxid, v_sl);
    END LOOP;
    */
  --非法状态的变更
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  END IF;
END tg_sc_wlxqjh;
/

prompt
prompt Creating trigger TG_SC_WLXQJHMX
prompt ===============================
prompt
CREATE OR REPLACE TRIGGER tg_sc_wlxqjhmx
  AFTER INSERT OR UPDATE OR DELETE ON sc_wlxqjhmx
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步计划可供量
  -- local variables here
  --2004.2.28 增加更新计划可供量与规格属性id有关
  v_zt       sc_wlxqjh.zt%TYPE;
  v_isrefer  sc_wlxqjh.isrefer%TYPE;
  v_wlxqjhid sc_wlxqjhmx.wlxqjhid%TYPE;
  v_oldsl    sc_wlxqjhmx.xql%TYPE;
  v_sl       sc_wlxqjhmx.xql%TYPE;
BEGIN
  NULL;
  /*6.22 废弃计划可供量表
  IF(:old.cc = 0) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_wlxqjhid := :new.wlxqjhid;
  ELSE
    v_wlxqjhid := :old.wlxqjhid;
  END IF;
  SELECT m.zt, m.isrefer INTO v_zt, v_isrefer
  FROM sc_wlxqjh m WHERE m.wlxqjhid = v_wlxqjhid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_sl := nvl(:new.xql,0);
    --更新计划可供量
    pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, -1*v_sl);
  ELSIF(deleting) THEN
    v_oldsl := nvl(:old.xql,0);
    --更新计划可供量
    pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_oldsl);
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.xql,0);
    v_sl := nvl(:new.xql,0);
    IF(:new.cpid=:old.cpid AND nvl(:new.dmsxid,-100) = nvl(:old.dmsxid, -100) AND v_oldsl = v_sl)THEN
      RETURN;
    END IF;
    --更新计划可供量
    IF(v_oldsl = v_sl)THEN
      pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, -1*v_sl);
      pck_store.updatePlanUsableGoods(:old.cpid, :old.dmsxid, v_oldsl);
    ELSE
      pck_store.updatePlanUsableGoods(:new.cpid, :new.dmsxid, -1*v_sl + v_oldsl);
    END IF;
  END IF;
  */
END tg_sc_wlxqjhmx;
/

prompt
prompt Creating trigger TG_SP_XMLX
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_SP_XMLX
  AFTER UPDATE ON sp_xmlx
  FOR EACH ROW
DECLARE
  v_count  INT;
  v_sql    VARCHAR2(300);
  v_dybm   sp_xm.dybm%TYPE;
  v_ztzdm  sp_xm.ztzdm%TYPE;
  v_ztbtgz sp_xm.ztbtgz%TYPE;
  --注: 可能存在审批流程的更改;
  --1.事后审批->事前审批，此时已有的记录再进行审批,将不再记帐(:old.isrefer=1)
  --2.事前审批->事后审批, 此时审批通过的记录取消审批,将不反记帐
  --  此时存在风险: 若还有未审批的数据，必须需要全部审批通过，才可以更改审批流程的设置
  --  应为此时,触发器将不知道改单据是否属于改为事后审批后添加的单据。将会产生记帐的差距。
BEGIN
  SELECT x.dybm, x.ztzdm, x.ztbtgz INTO v_dybm, v_ztzdm, v_ztbtgz
  FROM  sp_xm x WHERE x.spxmid = :old.spxmid;
  --事前审批->事后审批 splx=1, 表示事后审批：保存就记帐,不需经过审批流程
  IF((nvl(:old.splx,0)<>1 AND :new.splx=1) OR (:old.splx=1 AND :new.splx<>1)) THEN
    v_sql := 'SELECT COUNT(*) FROM '|| v_dybm ||
            ' WHERE '|| v_ztzdm ||' ='''|| v_ztbtgz ||''' OR ' || v_ztzdm ||' = 9';
    EXECUTE IMMEDIATE v_sql INTO v_count;
    IF(v_count > 0) THEN
      raise_application_error(-20000, '切换状态前,需要将未审批的单据审批掉！');
    END IF;
  END IF;
END TG_SP_XMLX;
/

prompt
prompt Creating trigger TG_XS_HT
prompt =========================
prompt
CREATE OR REPLACE TRIGGER TG_XS_HT
  BEFORE INSERT OR UPDATE ON XS_HT
  FOR EACH ROW
DECLARE
  -- local variables here
  --销售合同触发器
  v_zk   xs_hthw.zk%TYPE;
  v_dj   xs_hthw.dj%TYPE;
  v_zje  xs_ht.zje%TYPE;
  v_approvecode VARCHAR2(32) := 'sale_order_list';
BEGIN
  IF(inserting)THEN
    IF(pck_approve.isafterapprove(v_approvecode))THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批
  ELSIF(pck_approve.isafterapprove(v_approvecode))THEN
    /*2004.7.29 用视图代替客户信誉额度锁定量 --做废
    IF(:old.zt <> 4 AND :new.zt = 4) THEN
      --更新单位信誉度锁定量
      pck_store.updateCustCreditNum(:old.dwtxid, -1*nvl(:old.zje,0), :old.fgsid);
    --完成
    ELSIF(:old.zt <> 8 AND :new.zt = 8) THEN
      SELECT nvl(SUM(nvl(h.jsje,0)),0) INTO v_zje FROM xs_hthw x, xs_tdhw t, cw_xsjshx h
      WHERE x.hthwid= t.hthwid AND t.tdhwid = h.tdhwid AND x.htid = :old.htid;
      --更新单位信誉度锁定量
      pck_store.updateCustCreditNum(:old.dwtxid, nvl(:old.zje,0)-v_zje, :old.fgsid);
    --其他情况
    ELSE
      --总金额变更
      IF(nvl(:old.zje,0)<>nvl(:new.zje,0)) THEN
        --更新单位信誉度锁定量
        pck_store.updateCustCreditNum(:old.dwtxid, nvl(:new.zje,0)-nvl(:old.zje,0), :old.fgsid);
      END IF;
    */
    --客户变更
    IF(:old.dwtxid<>:new.dwtxid)THEN
      FOR c_mx IN( SELECT j.cpid, d.dmsxid, nvl(d.zk,100) zk, nvl(d.dj,0) dj FROM xs_hthw d, xs_wzdj j
                   WHERE d.wzdjid=j.wzdjid AND d.htid =:old.htid)
      LOOP
        --更新客户产品历史记录
        pck_store.updateCustHistoryProd(:new.dwtxid, c_mx.cpid, c_mx.dmsxid, c_mx.zk, c_mx.dj, :new.fgsid);
      END LOOP;
    END IF;
    --END IF;
    RETURN;
  END IF;
  --事前审批
  /*IF(:old.zt = 1 AND :new.zt = 1 AND nvl(:old.zje,0)<>nvl(:new.zje,0)) THEN
    --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, nvl(:new.zje,0)-nvl(:old.zje,0), :old.fgsid);
  --
  ELS*/
  IF(:old.zt = 1 AND :new.zt = 1 AND :old.dwtxid<>:new.dwtxid) THEN
    FOR c_mx IN( SELECT j.cpid, d.dmsxid, nvl(d.zk,100) zk, nvl(d.dj,0) dj FROM xs_hthw d, xs_wzdj j
                 WHERE d.wzdjid=j.wzdjid AND d.htid =:old.htid)
    LOOP
      --更新客户产品历史记录
      pck_store.updateCustHistoryProd(:new.dwtxid, c_mx.cpid, c_mx.dmsxid, c_mx.zk, c_mx.dj, :new.fgsid);
    END LOOP;
  --审批通过
  ELSIF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN
    :new.isrefer := 1;
    /* 2004.7.29 用视图代替客户信誉额度锁定量 --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, nvl(:old.zje,0), :old.fgsid);*/
    FOR c_mx IN( SELECT j.cpid, d.dmsxid, nvl(d.zk,100) zk, nvl(d.dj,0) dj FROM xs_hthw d, xs_wzdj j
                 WHERE d.wzdjid=j.wzdjid AND d.htid =:old.htid)
    LOOP
      --更新客户产品历史记录
      pck_store.updateCustHistoryProd(:old.dwtxid, c_mx.cpid, c_mx.dmsxid, c_mx.zk, c_mx.dj, :old.fgsid);
    END LOOP;
  /*2004.7.29 用视图代替客户信誉额度锁定量 --取消审批
  ELSIF(:old.zt = 1 AND :new.zt = 0) THEN
    :new.isrefer := 0;
    --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, -1*nvl(:old.zje,0), :old.fgsid);*/
  --非法状态的变更. bug:会出现已审的单据变为审批中。在这里强制转变回去
  ELSIF(:old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  /*2004.7.29 用视图代替客户信誉额度锁定量 --做废
  ELSIF(:old.zt <> 4 AND :new.zt = 4) THEN
    --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, -1*nvl(:old.zje,0), :old.fgsid);
  --完成
  ELSIF(:old.zt <> 8 AND :new.zt = 8) THEN
    SELECT nvl(SUM(nvl(h.jsje,0)),0) INTO v_zje FROM xs_hthw x, xs_tdhw t, cw_xsjshx h
    WHERE x.hthwid= t.hthwid AND t.tdhwid = h.tdhwid AND x.htid = :old.htid;
    --更新单位信誉度锁定量
    pck_store.updateCustCreditNum(:old.dwtxid, nvl(:old.zje,0)-v_zje, :old.fgsid);*/
  END IF;
END TG_XS_HT;
/

prompt
prompt Creating trigger TG_XS_HTHW
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_XS_HTHW
  AFTER INSERT ON xs_hthw
  FOR EACH ROW
DECLARE
  --销售合同货物明细触发器
  -- local variables here
  v_fgsid  xs_ht.fgsid%TYPE;
  v_dwtxid xs_ht.dwtxid%TYPE;
  v_isrefer xs_ht.isrefer%TYPE;
  v_sl     xs_hthw.sl%TYPE;
  v_cpid   xs_wzdj.wzdjid%TYPE;
BEGIN
  SELECT m.fgsid, m.dwtxid, m.isrefer INTO v_fgsid, v_dwtxid, v_isrefer
  FROM xs_ht m WHERE m.htid = :new.htid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --更新客户产品历史记录
  SELECT w.cpid INTO v_cpid FROM xs_wzdj w WHERE w.wzdjid = :new.wzdjid;
  pck_store.updateCustHistoryProd(v_dwtxid, v_cpid, :new.dmsxid, nvl(:new.zk,100), nvl(:new.dj,0), v_fgsid);
END TG_XS_HTHW;
/

prompt
prompt Creating trigger TG_XS_TD
prompt =========================
prompt
CREATE OR REPLACE TRIGGER TG_XS_TD
  BEFORE INSERT OR UPDATE ON XS_TD
  FOR EACH ROW
DECLARE
  -- local variables here
  --销售提单触发器，更新更新需求计划的已购量
  v_sl     xs_tdhw.sl%TYPE;
  v_hssl   xs_tdhw.hssl%TYPE;
  v_oldzje xs_td.zje%TYPE;
  v_newzje xs_td.zje%TYPE;
  v_djlx   xs_td.djlx%TYPE;
  v_approvecode VARCHAR2(32);
  v_isafter BOOLEAN;
  v_flag INT;
BEGIN
  IF(nvl(:new.djlx, 1) = -1) THEN
    v_approvecode := 'unlading_bill';
  ELSE
    v_approvecode := 'lading_bill';
  END IF;
  v_isafter := pck_approve.isafterapprove(v_approvecode);
  IF(inserting)THEN
    --员业务员与输入的业务员相同
    :new.yywyid := :new.personid;
    IF(v_isafter)THEN
      :new.isrefer := 1;
    ELSE
      :new.isrefer := 0;
    END IF;
    RETURN;
  --若是事后审批的，则不需要操作主表. 平台对数据的操作只有在删除主从时，才先处理从表的数据
  END IF;

  --2004.7.13 提单出库确认往来单位的变更--bug
  IF(:old.zt = 1 OR :old.zt=2 OR :old.zt=8 OR :old.zt=9) THEN
    :new.dwtxid := :old.dwtxid;
  END IF;
  IF(:new.zt = 8)THEN
    :new.zsl := :old.zsl;
    :new.zje := :old.zje;
  END IF;
  --没有审批流程
  IF((:old.zt=1 AND :new.zt=1) OR v_isafter) THEN
    v_djlx := nvl(:old.djlx,1);
    IF(v_djlx <> 1) THEN
      v_djlx := -1;
    END IF;
    /*--更改仓库信息 2004.7.29 用视图代替客户信誉额度锁定量
    IF(:old.storeid<>:new.storeid OR :old.dwtxid<>:new.dwtxid) THEN
      FOR c_mx IN(SELECT d.hthwid, d.cpid, d.dmsxid, nvl(d.sl,0) sl, nvl(d.hssl,0) hssl, nvl(d.jje,0) jje
                  FROM xs_tdhw d WHERE d.tdid =:old.tdid)
      LOOP
        --更新物资锁定数量
        /*IF(:old.storeid<>:new.storeid) THEN
          pck_store.updateSaleGoodsLock(c_mx.cpid, c_mx.dmsxid, :old.storeid, :old.fgsid, -1*c_mx.sl, -1*c_mx.hssl);
          pck_store.updateSaleGoodsLock(c_mx.cpid, c_mx.dmsxid, :new.storeid, :old.fgsid,    c_mx.sl,    c_mx.hssl);
        END IF;

        --更新单位信誉度锁定量
        IF(:old.dwtxid<>:new.dwtxid AND c_mx.hthwid IS NULL) THEN
          pck_store.updateCustCreditNum(:new.dwtxid,    c_mx.jje, :old.fgsid);
          pck_store.updateCustCreditNum(:old.dwtxid, -1*c_mx.jje, :old.fgsid);
        END IF;
      END LOOP;
    END IF;
    */
    /*2004.2.27. 应收款在报表中即时统计
    v_oldzje := nvl(:old.zje,0);
    v_newzje := nvl(:new.zje,0);
    --更新单位的应收款
    IF(:old.dwtxid<>:new.dwtxid) THEN
      pck_store.updateCustReceivableAccount(:new.dwtxid,    v_newzje, :old.fgsid);
      pck_store.updateCustReceivableAccount(:old.dwtxid, -1*v_oldzje, :old.fgsid);
    ELSIF(v_oldzje<>v_newzje) THEN
      pck_store.updateCustReceivableAccount(:old.dwtxid, (v_newzje-v_oldzje), :old.fgsid);
    END IF;*/
    --
    RETURN;
  ELSIF(v_isafter) THEN
    RETURN;
  --有审批流程时,审批通过
  ELSIF((:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN
    :new.isrefer := 1;
    v_flag := 1;
  ELSIF( :old.zt = 1 AND :new.zt = 0) THEN
  :new.isrefer := 0;
    v_flag := -1;
  --非法状态的变更
  ELSIF( (:old.zt = 1 OR :old.zt=2 OR :old.zt=8) AND :new.zt = 9) THEN
    :new.zt := :old.zt;
    RETURN;
  ELSE
    RETURN;
  END IF;
  v_djlx := nvl(:old.djlx,1);
  IF(v_djlx <> 1) THEN
    v_djlx := -1;
  END IF;
  FOR c_mx IN(SELECT d.hthwid, d.cpid, d.dmsxid, d.sl, d.hssl, nvl(d.zk,100) zk, nvl(d.dj,0) dj
              FROM xs_tdhw d WHERE d.tdid =:old.tdid)
  LOOP
    v_sl := nvl(c_mx.sl,0);
    v_hssl := nvl(c_mx.hssl, 0);
    v_oldzje := nvl(:old.zje,0);
    --更新物资锁定数量
    --pck_store.updateSaleGoodsLock(c_mx.cpid, c_mx.dmsxid, :old.storeid, :old.fgsid, v_flag*v_sl, v_flag*v_hssl);
    --更新客户产品历史记录
    IF(v_flag > 0 AND v_djlx > 0) THEN
      pck_store.updateCustHistoryProd(:old.dwtxid, c_mx.cpid, c_mx.dmsxid, c_mx.zk, c_mx.dj, :old.fgsid);
    END IF;
    /*2004.5.3. 应收款在报表中即时统计
    --更新客户的应收款
    pck_store.updateCustReceivableAccount(:old.dwtxid, v_flag*v_oldzje, :old.fgsid);
    */
    --
    IF(c_mx.hthwid IS NOT NULL)THEN
      --更新合同货物实际开提单数量
      pck_store.updateSaleOrderLadingNum(c_mx.hthwid, v_flag*v_sl, v_flag*v_hssl, FALSE);
    END IF;
    /*2004.7.29 用视图代替客户信誉额度锁定量
      ELSE
      --更新单位信誉度锁定量(手工开的提单审核通过增加锁定量)
      pck_store.updateCustCreditNum(:old.dwtxid, v_flag*nvl(:old.zje,0), :old.fgsid);*/
  END LOOP;
  /*ELSIF(:old.zt <> 8 AND :new.zt = 8) THEN
    FOR c_mx IN( SELECT d.hthwid, d.cpid, d.sl, d.hssl FROM xs_tdhw d
                 WHERE  d.hthwid IS NOT NULL AND D.tdid =:old.tdid)
    LOOP
      v_sl := nvl(c_mx.sl,0);
      v_hssl := nvl(c_mx.hssl, 0);
      --更新合同货物实际开提单数量
      pck_store.updateSaleOrderLadingNum(c_mx.hthwid, -1*v_sl, -1*v_hssl, TRUE);
    END LOOP;*/
END TG_XS_TD;
/

prompt
prompt Creating trigger TG_XS_TDHW
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER TG_XS_TDHW
  AFTER UPDATE OR DELETE ON XS_TDHW
  FOR EACH ROW
DECLARE
  --库存收发单据明细触发器，用于同步库存数量
  -- local variables here
  v_zt    xs_td.zt%TYPE;
  v_fgsid xs_td.fgsid%TYPE;
  v_storeid xs_td.storeid%TYPE;
  v_dwtxid  xs_td.dwtxid%TYPE;
  v_djlx    xs_td.djlx%TYPE;  --提单性质1:提单,-1:退货单
  v_isrefer xs_td.isrefer%TYPE;
  v_tdid    xs_tdhw.tdid%TYPE;
  v_oldsl   xs_tdhw.sl%TYPE;
  v_sl      xs_tdhw.sl%TYPE;
  v_oldhssl xs_tdhw.hssl%TYPE;
  v_hssl    xs_tdhw.hssl%TYPE;
  v_isover  BOOLEAN:= FALSE;
  v_count   INT;
BEGIN
  IF(deleting)THEN
    --2004.10.21.增加约束
    SELECT COUNT(*) INTO v_count FROM kc_sfdjmx m WHERE m.wjid=:old.tdhwid AND m.djxz=2;
    IF(v_count > 0)THEN
      Raise_application_error(-20000, '该提单已经有出库单不能删除');
    END IF;
  END IF;
  IF(inserting)THEN
    v_tdid := :new.tdid;
  ELSE
    v_tdid := :old.tdid;
  END IF;
  --
  SELECT m.zt, m.fgsid, m.storeid, m.dwtxid, decode(m.djlx,1, 1, -1, -1, 1), m.isrefer
  INTO   v_zt, v_fgsid, v_storeid, v_dwtxid, v_djlx, v_isrefer
  FROM xs_td m WHERE m.tdid = v_tdid;
  IF(v_isrefer <> 1) THEN
    RETURN;
  END IF;
  --
  IF(inserting)THEN
    v_sl := nvl(:new.sl,0);
    v_hssl := nvl(:new.hssl,0);
    --更新物资锁定数量
    --pck_store.updateSaleGoodsLock(:new.cpid, :new.dmsxid, v_storeid, v_fgsid, v_sl, v_hssl);
    --更新实开提单数量
    IF(:new.hthwid IS NOT NULL) THEN
      --更新实开提单数量
      pck_store.updateSaleOrderLadingNum(:new.hthwid, v_sl, v_hssl, v_isover);
    /*2004.7.29 用视图代替客户信誉额度锁定量
      ELSE--更新单位信誉度锁定量(手工开的提单审核通过增加锁定量)
      pck_store.updateCustCreditNum(v_dwtxid, nvl(:new.jje,0), v_fgsid);*/
    END IF;
    --更新客户产品历史记录
    IF(v_djlx > 0) THEN
      pck_store.updateCustHistoryProd(v_dwtxid, :new.cpid, :new.dmsxid, nvl(:new.zk,100), nvl(:new.dj,0), v_fgsid);
    END IF;
  ELSIF(deleting)THEN
    --注:删除时将不更新客户历史产品记录
    v_oldsl := nvl(:old.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    --更新物资锁定数量
    --pck_store.updateSaleGoodsLock(:old.cpid, :old.dmsxid, v_storeid, v_fgsid, -1*v_oldsl, -1*v_oldhssl);
    --2004.10.21.增加约束
    SELECT COUNT(*) INTO v_count FROM kc_sfdjmx m WHERE m.wjid=:old.tdhwid AND m.djxz=2;
    IF(v_count > 0)THEN
      Raise_application_error(-20000, '该提单已经有出库单不能删除');
    END IF;

    --更新实开提单数量
    IF(:old.hthwid IS NOT NULL) THEN
      pck_store.updateSaleOrderLadingNum(:old.hthwid, -1*v_oldsl, -1*v_oldhssl, v_isover);
    /*2004.7.29 用视图代替客户信誉额度锁定量
    ELSE--更新单位信誉度锁定量(手工开的提单审核通过增加锁定量)
      pck_store.updateCustCreditNum(v_dwtxid, -1*nvl(:old.jje,0), v_fgsid);*/
    END IF;
  ELSIF(updating) THEN
    v_oldsl := nvl(:old.sl,0);
    v_sl := nvl(:new.sl,0);
    v_oldhssl := nvl(:old.hssl,0);
    v_hssl := nvl(:new.hssl,0);
    --更新物资锁定数量
    /*IF(:new.cpid <> :old.cpid) THEN
      pck_store.updateSaleGoodsLock(:new.cpid, :new.dmsxid, v_storeid, v_fgsid,    v_sl,       v_hssl);
      pck_store.updateSaleGoodsLock(:old.cpid, :old.dmsxid, v_storeid, v_fgsid, -1*v_oldsl, -1*v_oldhssl);
    ELSIF(v_oldsl <> v_sl) THEN
      pck_store.updateSaleGoodsLock(:old.cpid, :old.dmsxid, v_storeid, v_fgsid, (v_sl-v_oldsl), v_hssl-v_oldhssl);
    END IF;*/
    --更新实开提单数量
    IF(:old.hthwid IS NOT NULL AND (v_oldsl <> v_sl OR v_oldhssl <> v_hssl)) THEN
      pck_store.updateSaleOrderLadingNum(:old.hthwid, (v_sl-v_oldsl), (v_hssl-v_oldhssl), v_isover);
    END IF;
    /*
    --更新单位信誉度锁定量(手工开的提单审核通过增加锁定量)
    IF(:old.hthwid IS NULL AND nvl(:old.jje,0) <> nvl(:new.jje,0)) THEN
      pck_store.updateCustCreditNum(v_dwtxid, (nvl(:new.jje,0)-nvl(:old.jje,0)), v_fgsid);
    END IF;*/
    --更新客户产品历史记录
    IF(v_djlx>0 AND (:new.cpid <> :old.cpid OR nvl(:new.dmsxid,-100) <> nvl(:old.dmsxid,-100))) THEN
      pck_store.updateCustHistoryProd(v_dwtxid, :new.cpid, :new.dmsxid, nvl(:new.zk,100), nvl(:new.dj,0), v_fgsid);
    ELSE
      pck_store.updateCustHistoryProd(v_dwtxid, :old.cpid, :old.dmsxid, nvl(:old.zk,100), nvl(:old.dj,0), v_fgsid);
    END IF;
  END IF;
END TG_XS_TDHW;
/

prompt
prompt Creating trigger TG_XS_TDYJ
prompt ===========================
prompt
CREATE OR REPLACE TRIGGER tg_xs_tdyj
  BEFORE INSERT OR UPDATE ON xs_tdyj
  FOR EACH ROW
DECLARE
  --采购申请单
  -- local variables here
  v_approvecode VARCHAR2(32) := 'saler_handover';
  v_isafter BOOLEAN;
  v_count   INT;
BEGIN
  v_isafter := pck_approve.isafterapprove(v_approvecode);
  IF(v_isafter)THEN
    raise_application_error(-20000, '请将审批流程设置为事前审批！');
  END IF;
  --事前审批部分
  IF(updating AND (:old.zt = 0 OR :old.zt = 9) AND :new.zt = 1) THEN--审批通过
    UPDATE xs_td t SET t.personid=:old.afterid  WHERE t.tdid = :old.tdid;
    --:new.isrefer := 1;
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 0) THEN
    UPDATE xs_td t SET t.personid=:old.beforeid WHERE t.tdid = :old.tdid;
    --:new.isrefer := 0;
  --非法状态的变更
  ELSIF(updating AND :old.zt = 1 AND :new.zt = 9) THEN
    :new.zt := 1;
    RETURN;
  END IF;
END tg_xs_tdyj;
/

prompt
prompt Creating trigger TG_ZZ_APPROVE
prompt ==============================
prompt
CREATE OR REPLACE TRIGGER TG_ZZ_APPROVE
  BEFORE UPDATE ON kc_sfdj
  FOR EACH ROW
DECLARE
  -- local variables here
  --程序变更记录
  v_count INT;
BEGIN
  IF((:old.zt=0 OR :old.zt=9) AND :new.zt=1)THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('outstore approve', :old.sfdjid, :old.sfdjdh, SYSDATE);
  ELSIF(:old.zt=1 AND :new.zt=0) THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('outstore normal_unapprove', :old.sfdjid, :old.sfdjdh, SYSDATE);
  ELSIF(:old.zt=1 AND :new.zt=9) THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('outstore unnormal_unapprove', :old.sfdjid, :old.sfdjdh, SYSDATE);
  ELSE
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('outstore update', :old.sfdjid, :old.sfdjdh, SYSDATE);
  END IF;
END TG_ZZ_APPROVE;
/

prompt
prompt Creating trigger TG_ZZ_APPROVE_TD
prompt =================================
prompt
CREATE OR REPLACE TRIGGER TG_ZZ_APPROVE_TD
  BEFORE UPDATE ON xs_td
  FOR EACH ROW
DECLARE
  -- local variables here
  --程序变更记录
BEGIN
  IF((:old.zt=0 OR :old.zt=9) AND :new.zt=1)THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('xs_td approve', :old.tdid, :old.tdbh, SYSDATE);
  ELSIF(:old.zt=1 AND :new.zt=0) THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('xs_td normal_unapprove', :old.tdid, :old.tdbh, SYSDATE);
  ELSIF(:old.zt=1 AND :new.zt=9) THEN
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('xs_td unnormal_unapprove', :old.tdid, :old.tdbh, SYSDATE);
  ELSE
    INSERT INTO zz_approvelog(caption, billid, billcode, changedate)
    VALUES('xs_td update', :old.tdid, :old.tdbh, SYSDATE);
  END IF;
END TG_ZZ_APPROVE;
/


spool off
